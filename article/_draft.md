# draft

````plaintext

如何实现一个web服务器
    拓扑结构
        星型
        环型
        总线
            以太网
        ...
    模型
        七层模型 (由 OSI 提出的)
            应用层 Application
            表示层 Presentation
                负责转化数据格式，并处理数据加密和数据压缩。
                其实 tls 这这种协议可以归类到这一层里
            会话层 Session
                主要是用来管理网络设备的会话连接，建立会话，保持会话，断开会话
            传输层 Transport
            网际层 Internet/Network
            数据链路层 Link/Data link/Network interface
            物理层 Hardware/Physical
        四层模型 ip/tcp
            应用层
            传输层
            网际层
            网络接口层
        五层模型
            应用层 -> data (数据)
            传输层 ->
                TCP -> segment (段)
                UDP -> datagram (数据报文)
            网际层 -> packet (包)
            数据链路层 -> frame (帧)
            物理层 -> bit (比特)
        各层常用的协议
            应用层
                http
                    0.9 1.0 1.1 2 3
                mqtt
                telnet
                    rfc 97 137 153 318
                        854 855 856 857 859 860 861
                        2217
                ftp
                dns
                nntp
                    网络新闻传输协议（Network News Transfer Protocol）
                    USENET 和 NNTP 的关系，大概就是 网站 和 http 的关系差不多
                irc
                xmpp
                ntp
                    网络时间协议（Network Time Protocol）
                dhcp
                smtp
                pop3
                imap
                echo
                discard
                daytime
                chargen
                time
            传输层
                tcp
                    建立连接 三次握手
                    断开连接 四次挥手
                    流量控制
                        滑动窗口
                    拥堵控制
                        慢启动 与 拥塞避免
                            TCP 慢启动 / 14KB 规则 ？
                        快重传 与 快恢复
                    三个半事件
                        连接建立
                        连接断开
                        消息到达
                        消息发送完毕（这是半个事件）
                    沾包
                        根本原因
                        什么情况下会发生
                        解决方式
                        为什么udp没有沾包
                udp
                icmp
            网际层
                ip v4 v6
                ARP
                IPsec
            数据链路层
                以太网 (Ethernet)
                    以太网帧又分为 Ethernet II 和 IEEE 802.3
                    关注 Ethernet II 就可以了
                        帧间隙 来区分不同的 帧
        各层对应的硬件
            网关 (gateway)
            路由 (route)
            交换机 (switch)
            网桥 (bridge)
            集线器 (ethernet hub 又或者 简称 hub)
            中继器 (repeater)
            调制解调器 (modem modulator-demodulator 调制器-解调器)
            和安全相关的硬件
                IPS (Intrusion Prevention System) 入侵检测（旁路部署）
                IDS (Intrusion Detection System) 入侵防御（串行部署）
                FW (FireWall) 防火墙
                WAF (Web Application FireWall) 网页应用防火墙
                UTM (Unified Threat Management) 统一威胁管理
    路由表和路由算法
        静态路由
        动态路由
            迪达拉算法
    tcp 和 udp
    什么是socket
    从socket里读写内容
        一些限制
            输入输出只考虑 asni ，多字节编码不好处理，这里只关注网络连接
            一次通讯数据包最大的长度为 255 ，因为分包操作也挺麻烦的
        基本套路
            建立连接
                socket
                setsockopt
                服务端
                    bind
                    listen
                    accept
                客户端
                    connect
            发送和接收数据
                recv / send -> TCP
                recvfrom / sendto -> UDP
            关闭连接
                close
            io复用
                select poll epoll
        只输出一个 helloworld
        实现最简单的五个协议
            echo (RFC 862) 7 回显服务，把收到的数据发回客户端
            discard (RFC 863) 9 丢弃所有收到的数据
            chargen (RFC 864) 19 服务端 accept 连接之后，不停地发送测试数据
            daytime (RFC 867) 13 务端 accept 连接之后，以字符串形式发送当前时间，然后主动断开连接
            time (RFC 868) 87 服务端 accept 连接之后，以二进制形式发送当前时间的32位时间戳，然后主动断开连接
            只考虑 tcp 的
            用 netcat 作为客户端
        然后是基于 telnet 的 echo
        然后是基于 telnet 的聊天室
    http 服务器
        http 协议
            0.9 1.0 1.1 2 3
            请求码 和 响应码
            mime
            缓存
        基本套路
            建立连接
            接收数据
            解释请求
                请求行
                请求头
                请求体
            处理数据
            构造响应
                响应行
                响应头
                响应体
            输出响应
            根据实际情况决定 关闭连接 或 保持连接
        进程模型
            单进程单线程
            单进程多线程
            多进程单线程
            多进程多线程
            io 多路复用
                select
                poll
                epoll
                    水平触发 (level trigger, LT)
                    边缘触发 (edge trigger, ET)
        具体类型
            静态
            动态
                cgi
                fastcgi
            代理
                socket 双写
                反向代理
                正向代理
                    RFC 2616
                    RFC 7230
                    RFC 7231
                    RFC 1928 SOCKS5
                    pac
            websocket
                WebSocket Secure (wss)
        TLS
            1.2
            1.3
    其它
        带宽 和 宽带 和 位宽 的联系与区别
        代理 网关 隧道 的区别，还有 VPN 和 端口转发
            代理 proxy
                「代为处理」
                代理的类型和作用域
                在各种系统上的代理设置
                    windows
                    linux
                    安卓
                正向代理/转发代理 forward proxy
                反向代理 reverse proxy
            网关 gateway
                「网络关口」「网络海关」
            隧道 tunnel
            端口转发 port forwarding
            虚拟专用网 (Virtual Private Network , VPN)
            虚拟私有云 (Virtual Private Cloud , VPC)
            透明 transparent

以开发软件为目标的计算机入门简明指南
    计算机入门的前置知识
        如果只做业务相关，需要 初等数学 外加一点 数理逻辑
        如果涉及数据库的，还需要一点 集合论
        如果涉及到一些高深的算法，可能还需要 图论 和 组合数学
        如果涉及数据分析，还需要 概率论 和 数理统计
        如果涉及计算机图形，还需要 线性代数
        英语至少要有初中的水平 (要学会使用各类翻译服务 谷歌翻译 百度翻译 必应翻译 ...)
            具体一点就是
                多邻国英语测试（DET） 55 分 或
                国家英语等级考试（NETS） 三级 或
                雅思（LETLS） 3.5 分 或
                欧洲语言共同参考框架（CEFR） A2
            在没有翻译的帮助下达到 A2 的水平，加上翻译达到 B1 的水平（所以熟练地使用各类翻译工具也是一种重要的能力）
            专为程序员编写的英语学习指南
                https://github.com/yujiangshui/A-Programmers-Guide-to-English
                https://a-programmers-guide-to-english.harryyu.me/
        抽象是一个重要的概念，封装是一个重要的概念，递归是一个重要的概念
    计算机学科的相关概念
        计算理论（Theory of computation）
        计算理论的三个主要问题
            采用什么计算模型（即形式语言、自动机）
            解决哪些是可计算的、哪些是不可计算的（即可计算性理论及演算法）
            要用多少时间、要用多少存储（即计算复杂性理论）
        计算模型（model of computation）
            顺序模型（Sequential models）
                图灵机（Turing machine）
                寄存器机（Register machine）
                    随机存取机（英语：Random-access machine，缩写为RAM）
                    随机存取储存程式机（英语：Random-access stored-program machine，缩写为RASP）
            函数式模型（Functional models）
                λ演算（Lambda calculus）
                递归函数（recursive function）
                抽象重写系统（Abstract rewriting system，缩写为ARS）
                    马尔可夫算法（markov algorithm）
            同步模型（Concurrent models）
                元细胞自动机（Cellular automaton，缩写为CA）
                    生命游戏（Game of Life）
        抽象机器（Abstract machine） -> 自动机（Automata） -> 图灵机（Turing machine，缩写为TM）
            半在自动机的三元组
                状态集 字母表 转移函数
            自动机的五元组
            图灵机的七元组
        图灵机
            组成
                纸带
                读写头
                状态寄存器
        通用图灵机（Universal Turing Machine，又称UTM或Machine U）
        图灵完全/图灵完备（Turing complete）
        图灵等价/图灵等效（Turing equivalent）
        计算模型 -> 计算机系统架构 -> 指令集 -> 微架构
        寄存器机 -> 冯诺依曼架构 -> x86指令集 -> Zen4
        冯诺依曼结构
            以运算单元为中心
            数据和指令都以二进制编码
            数据和指令不加区别混合存储在同一个存储器中
            指令由操作码和地址码组成
            顺序执行程序的每一条指令
            由五个部件构成
                运算器 控制器 存储器 输入设备 输出设备
        计算问题（Computational problem）
            在理论计算机科学中，计算问题是可以通过算法解决的问题。
            分类
                决策问题
                搜索问题
                计数问题
                优化问题
                功能问题
                承诺问题
                    承诺问题 是 决策问题 的推广
        可计算性（Computability）
            可计算性理论的一个目标是确定在每个计算模型中可以解决哪些问题或问题类别。
                除了 可计算问题，不可计算问题，还有一种 近似可计算问题
            可判定性（Entscheidungsproblem）
            停机问题（halting problem）
                停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。
                该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。
                艾伦·图灵在1936年用对角论证法证明了，不存在解决停机问题的通用算法。这个证明的关键在于对计算机和程序的数学定义
                停机问题在图灵机上是不可判定问题
                停机问题包含了自我指涉，本质是一阶逻辑的不完备性，类似的命题有理发师悖论、全能悖论等。
        计算复杂性理论（Computational complexity theory）
            复杂度
                时间
                    确定性
                    非确定性
                空间
                    确定性
                    非确定性
                最好，最坏，平均
            复杂度类
                NP问题
                    N non-deterministic 非确定性的
                    P polynomial 多项式的
    计算机的发展历史
        早期工具
            算盘
            计算尺
        模拟计算机
            机械式
            电动式
        机电计算机
            继电器
        电子计算机
            真空管
            晶体管
            集成电路
            超大规模集成电路
    逻辑门的底层
    从与或非逻辑门到指令集和汇编语言的抽象
    计算机的组成
        抽象的计算机组成
            输入设备
            输出设备
            控制器
            运算器
            存储器
        具体的计算机组成
            主板
            电源
            cpu - 控制器 运算器
            内存 - 存储器
            硬盘 - 存储器
            显卡 - 运算器
            键盘 - 输入设备
            鼠标 - 输入设备
            屏幕 - 输出设备
            音箱 - 输出设备
    操作系统
        环境变量
        抽象的操作系统
            组成
                驱动
                内核
                    进程调度 -> cpu
                    内存分配 -> 内存
                    文件系统 -> 硬盘
                    网络栈 其实可以算到驱动里，但现代操作系统的网络很重要
                系统调用
                外围程序
                    shell
            可以简单但不严谨地理解
                微内核 仅包括了创建一个系统必需的几个部分 进程调度 内存分配 文件系统
                宏内核 在 微内核的基础上加上 驱动 和 系统调用
        linux 系统的一般使用
            系统安装
            启动过程
            shell 和 treminal
            查看系统信息
                硬件信息
                    cpu
                    内存
                    硬盘
                    网卡
                系统信息
                    linux内核版本
                    系统版本
                网络
                    有多少个网卡
                    ip地址 网关
                    tcp udp 的端口占用情况
                    防火墙
                进程
                用户
                    用户 用户组
                    当前登录的用户
            常用的软件
                gnu 工具链
                四剑客
                    grep
                    sed
                    awk
                    find
                在linux下查找文件
                    查找文件
                    find / -name httpd.conf
                    查找普通文件
                    find / -name httpd.conf -type f
                    查找文件夹
                    find / -name mysql -type d
                查找一个命令的位置
                    通过 ps 命令查找
                    type command
                    which command
                    whereis command
            包管理器
                apt
            守护进程
                systemd
            定时任务
                cron
                systemd 的 timer
                at 和 atq
            权限管理
                文件权限
                用户
                用户组
            网络
                设置ip
                设置hosts和dns
                设置代理
                设置防火墙
            图形界面
        windows
            配置文件ini和注册表
            策略组
            服务
            计划任务
            防火墙
            命令行，终端和脚本
            事件查看器
            任务管理器
            explorer.exe
    计算机语言
        机器语言
            指令集（机器指令的集合）
            机器指令
            微程序
            微指令
            微命令和微操作
        汇编 assembly
            汇编指令
            伪指令
            符号
        高级语言
            编程语言
                c
                c++
                c#
                java
                javascript
                python
                php
                更多
                    lisp go rust ruby lua bash powershell bat vbs
                ...
            标记语言
                xml
                    xsd
                    svg
                    mathml
                    ...
                html
                markdown
            查询语言
                sql
            层叠样式表
                css
        基于字符串的数据格式
            ini
            yaml
            json
        编译原理
            语义设计
                类型系统
                编程范式
                流程控制
            语法设计
            abnf
            实践
                四则运算
                    从左至右
                    有优先级的
                    能识别括号的
                lex/flex ， yacc/bison ， Antlr ， peg.js
                解释 ini yaml json xml
                一个简单的脚本语言
                正则表达式
    数据库
        抽象的数据库
            平面 flat
            层次 hierarchical
            网状 network
            关系 relational
                集合论和谓词逻辑
                各种范式
                sql
        OLAP OLTP HTAP
        ACID CAP BASE
        nosql 和 newsql
        mysql 的一般使用
    计算机网络
        网络模型
        各层中的协议
        使用系统api来读写网卡中的数据
    软件工程
    中间件
        定时任务
        缓存
        队列
        全文搜索引擎
    虚拟机和容器
    集群和分布式
    一些工具
        git 的一般使用
            github gitlab gitee 其它的 git 服务
        vscode 的一般使用
        chrome 和 firefox 开发者工具的使用
    参考

frp的使用
    下载和安装
    作为 Windows 远程桌面的代理
    作为 xdebug 远程调试的代理
    作为代理使得本地的网站能被外网访问
    使用子域名的方式在本地部署多个网站
在vscode里调试java
    如何手工编译java的项目
    一般的java项目
    使用springboot的java项目
    使用tomcat的javaweb项目
    maven的使用
捕获前端的错误
    捕获异常
    盲水印
    外部数据要先判断是否存在再调用，不要把接口的数据直接渲染到视图
    前端代码的配置要区分生产环境和开发环境
    要把git的commitid写进配置文件里
    打包时要保留map，map不能被外部访问
    如何记录用户的操作？
        焦点移动
        鼠标移动
        滚动条的移动
        窗口大小的变化
        各种事件（键盘，鼠标，滚动条，窗口）的记录
博客
    淘系前端团队 https://fed.taobao.org/
    百度前端 https://fex.baidu.com/
    腾讯 Alloy Team http://www.alloyteam.com/
    腾讯CDC https://cdc.tencent.com/
    美团技术团队 https://tech.meituan.com/
    360奇舞团 https://75.team/
    小米信息部技术团队 https://xiaomi-info.github.io/
    京东零售官方设计共享平台 https://jelly.jd.com/
    阮一峰 https://www.ruanyifeng.com/blog/
    廖雪峰 https://www.liaoxuefeng.com/
    并发编程网 https://ifeve.com/
    王垠 https://www.yinwang.org/
    风雪之隅 https://www.laruence.com/
    鳥哥的 Linux 私房菜 http://linux.vbird.org/
    Allen https://blog.csdn.net/q1007729991
    O 的笔记 https://ouonline.net/
    halfrost https://halfrost.com/
    blackglory https://blackglory.me/
    黄玄的博客 http://huangxuan.me/
微信公众号
    腾讯技术工程
    哔哩哔哩技术
    数据库开发
    InfoQ
    人人都是产品经理
一些网址
文档
    mdn
    msdn
教程
    https://www.runoob.com/
    https://www.edx.org/school/w3cx
    https://www.w3schools.com/
    https://www.w3school.com.cn/
    https://www.w3cschool.cn/
    https://www.yiibai.com/
    http://c.biancheng.net/
    https://zh.javascript.info/
    廖雪峰 和 阮一峰 的博客里也有不少的教程
    mdn 和 msdn 里也有不少的教程
    git 的教程
        https://github.com/pcottle/learnGitBranching
        https://www.liaoxuefeng.com/wiki/896043488029600
        http://git-scm.com/book/zh
        https://backlog.com/git-tutorial/cn/
        http://rogerdudler.github.io/git-guide/index.zh.html
        http://marklodato.github.io/visual-git-guide/index-zh-cn.html
    由 hulu 赞助的 oi wiki https://github.com/OI-wiki/OI-wiki/
    演算法笔记：台湾师范大学总结的教程 https://web.ntnu.edu.tw/~algo/
    云原生资料库 https://jimmysong.io/docs/
    除了这些文档外，更应该关注各项技术的官方文档
    现在网络上的教程真的非常多，问题不在于寻找教程，而在于选择哪一个去看
社区
    github
    思否
    v2ex
    知乎
    掘金
    learnku.com
    w3ctech
    简书
    StackOverflow
    StackExchange
    即时通讯网 www.52im.net
信息类网站/关注的新闻
    通用的
        新闻联播
        新加坡联合早报
    数码行业的
        cnbeta
        zol
        少数派
    软件行业的
        开源中国 https://www.oschina.net/news
git仓库
    github中文社区，一些github仓库的索引 https://www.githubs.cn
    分享 GitHub 上入门级、有趣的开源项目 https://hellogithub.com
书籍
    鸟哥私房菜
    穿越计算机的迷雾
    网络是怎么连接的
    编码：隐匿在计算机软硬件背后的语言
    图解密码学
    七周七并发
    设计模式：可复用面向对象软件的基础
    Unix 编程艺术
    Unix 环境高级编程
    设计数据密集型应用 https://github.com/Vonng/ddia
    数学之美
    浪潮之巅
    人月神话
    人件
    程序员的数学1~3
    这就是软件售前工程师! https://read.douban.com/ebook/322579268/
    编程语言实现模式 https://book.douban.com/subject/10482195/
    开源的书籍
        https://github.com/EbookFoundation/free-programming-books
        https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-zh.md
浏览器数据持久化缓存技术
    back/forward cache
    HTTP文件缓存
    cookie
    localStorage
    sessionStorage
    Application Cache 和 pwa 相关
    Cache Storage 和 service worker 相关
    WebSQL 关系型数据库，火狐不支持
    IndexedDB 非关系型数据库
    一些浏览器会对 favicon.ico 有特殊的缓存
使用 debian 作为日常用机的系统
    各类硬件驱动
        网卡
        声卡
        显卡
        摄像头
        无线鼠标、键盘
    网卡的配置
    apt源
    桌面环境
    deb snap
    中文输入法
    wine
    加入域
    替代 office
        office 365
        google docs
        wps
        libreoffice
        Calligra Suite(KOffice)
        GNOME Office
        openoffice
    一些常用的 gui 软件
        firefox
        vscode
vscode的使用技巧
    下载 vscode 安装包的墙内加速
        先直接下载 vscode
        复制下载链接
        把链接里的域名改成这个 vscode.cdn.azure.cn
    常用的拓展
        git
            Git History
            GitLens — Git supercharged
        php
            PHP Debug
            PHP Intelephense
        其它
            vscode-icons
            sftp https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp
            remote ssh
            Hex Editor 查看文件十六进制的插件 https://github.com/microsoft/vscode-hexeditor
            Excel Viewer https://github.com/jjuback/gc-excelviewer
    显示空格
        "editor.renderControlCharacters": true, // 显示控制字符
        "editor.renderWhitespace": "all", // 渲染全部空白
    显示 .git 文件夹
        "files.exclude": {
            "**/.git": false
        },
    使用 git
        关闭自动刷新
            选项->拓展->git->autorefresh
            "git.autorefresh": false
    搜索文档内容的技巧
        排除 或 包含
            可以用 , 表示多个条件，例如像这样 .jmx,.js,.css,.less,.xml,.md
            可以用 * 表示通配 app/**/*Test.php
        匹配空行的正则表达式
            ^\s*(?=\r?$)\n
            ^$
    搜索文件的技巧
        ctrl+p 按文件名搜索
    转跳到行数
        Ctrl + G 然后在弹出的框中输入行数
    task的配置
    调试各种语言
        php
        js
        java
        python
        c
    远程开发的配置
爬虫与反爬虫的经验
    爬虫
        无视 robots.txt
        使用正则表达式和 xpath 抓取数据
        修改 ua
        构造完整的请求包
        使用代理来规避请求频率的限制
        使用无头浏览器来执行 js
        即使速度慢也加载图片
        使用 playwright 这类工具打开页面，显示窗口，修改ua
        使用 autoit 这类工具模拟鼠标在页面上的移动
        打开页面后要模拟一下人的操作，例如 移动一下鼠标 移动一下滚动条
        应对验证码
            orc
                在 orc 时遇到闪烁的节点，就在同一位置多截几张图，多张图片合成后再进行 orc
            机器学习
            打码平台
        把步骤分成抓取数据和解释数据两步
        最终目标 抓取到完整的数据
    反爬虫
        站点使用https
        robots.txt 声明禁止爬虫
        使用 http 头 Referer 使图片等静态资源防盗链
        内容里混杂不可见的无用的字符，例如 随机地插入零宽字符
        部分文本使用 css 的伪元素或 svg 显示，例如 数字和英文字母
        禁止爬虫的 ua
        使用 tls 指纹识别爬虫
            指纹和 ua 要互相对比
        内容需要认证才能显示
        限制请求频率
        内容需要执行 js 才能显示，类似于 spa
        节点按一定频率闪烁，人眼无法分辨，用于预防 orc 识别内容
        使用验证码
            判断是否出现验证码
                是否加载图片
                判断 favicon.ico 是否有加载
                鼠标的移动轨迹
                判断 屏幕分辨率 浏览器高度 页面高度 这几个值
                无差别地随机出现
            验证码的类型
                图片字符验证码
                    数字
                    数字+大写英文或小写英文
                    数字+大小写英文
                    数字+大小写英文+噪点
                    数字+大小写英文+噪点+干扰线
                    数字+大小写英文+噪点+干扰线+旋转
                    数字+大小写英文+噪点+干扰线+旋转+多种字体
                    数字+大小写英文+中文+噪点+干扰线+旋转+多种字体
                    数字+大小写英文+中文+噪点+干扰线+旋转+多种字体+四则运算
                滑动验证码
                点击验证码
        防止页面的源码被获取
            全站 https
            js 的代码要经过打包，且不暴漏 map
            js 的代码里要有一个循环的 debugger
            js 的代码要检测开发者工具是否有打开，如果是就清空页面的内容
                https://github.com/AepKill/devtools-detector
                https://github.com/sindresorhus/devtools-detect
            js 的代码要检测是否在无头浏览器里打开，如果是就清空页面的内容
            js 的代码要检测是否在 selenium 等环境里，如果是就清空页面的内容
            js 的代码要判断当前的运行环境是否在 nodejs ，如果是就清空页面的内容
            禁用鼠标右键，禁止f12，ctrl+f10，ctrl+shift+i，禁止选中和复制
        最终目标
            只允许人访问，访问频率不能太高，限制的内容不能被抓取
            完全杜绝爬虫是很难的，但可以尽量地提高爬虫的成本
        反爬虫的措施太猛可能会使搜索引擎也抓取不了内容
            通过搜索引擎爬虫的ua和ip地址的反查，单独做一个供搜索引擎抓取的版本
                https://developers.google.com/search/docs/advanced/crawling/verifying-googlebot
                https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers
                dns 反查 nslookup -qt=ptr 74.125.128.106
寻找工作
    寻找合适的 岗位 和 公司
        各个招聘平台
        目标公司的官网
        leetcode 牛客 等刷题的平台
        各类程序员的社区 stackoverflow V2EX 思否 简书 知乎 掘金 learnku.com
        要关注的
            岗位描述
            任职要求
            工资福利
            上班地点
            上班时间
            加班情况
            公司的业务类型
            公司的规模
            公司在招聘平台的信息越详细越好
        判断目标公司的口碑
            996icu
            天眼查 企查查 类工具
            在 搜索引擎 和 各类社区 搜索公司 名字 产品 管理层的姓名
                主要是为了看一下公司有没有负面消息
            公司的参保人数
                参保人数太少，或人数和招聘平台的简介里差距有点大的话，这样的公司也可能是坑
            公司的股权结构是怎样的
                一些小公司获得投资后，往往会夸大自己的公司，例如，获得蚂蚁金服的某间子公司投资，就会自称蚂蚁金服旗下的xxx公司
    准备简历
        简历最好只用一种字体，最好是无衬线的字体
        最好要根据 岗位描述和任职要求 来准备简历，最好不要一份简历海投
        如果长得不好看，就不要在简历里放照片
        刚毕业简历尽量不要超过1张单面a4纸，工作五年内不要超过2张单面a4纸
        内容
            个人信息
                姓名 性别 出生年月 期望工位 期望工资 入职时间
                leetcode主页 github主页 blog
                联系方式
                    邮箱 手机
            教育经历，如果毕业太久了或者内容太多了就把学历放在个人信息里
                校内的经历，获奖情况，参加的社团活动，如果毕业太久了或者内容太多了就不要这段
                毕业的学校，专业，专业的主要课程，时间
            工作经历
                时间 公司名 公司规模 工资
                工作内容
                    STAR Situation（背景）、Task（任务）、Action(行动)、Result(结果)
            个人技能
                各种证书也可以放在这里
            自我评价，内容太多了就不要这段
                随便写一下就好，不要超过100字
        简历要用 word 文档写，但要保存成 pdf 格式
            直接保存成 pdf 又或者
            用 word 文档写完，然后预览，然后截图，然后把图片粘贴进一个新建的 word 文档，最后把有图片的 word 文档另存为 pdf
        简历可以放在 github 里或者写一个前端的页面
        简历命名为
            岗位-名字
            岗位-名字-联系方式
    投递简历
        目标公司的投递渠道
            通常在官网里都有投递简历的渠道
        各种招聘平台
    如何应对面试
        简历里提及的内容都要认真准备
        根据岗位描述和任职要求准备面试
        提前了解公司的业务类型和规模
        根据 岗位描述 任职要求 公司的业务类型 公司的规模 来预判公司在技术上可能存在的难点，并提前准备相关的解决方案
        背下一些常见的面试题
            面试八股的范围超级大，正常人无法记忆全部的
            背常见的问题（随便在百度搜一下就有了，这类内容简中网里非常多）
            再根据预判来背一些小众的问题（上一步的预判）
            笔者反对面试八股，但笔者依然会建议面试之前背下八股文
        准备一份简单的自我介绍
            我是谁
            做过什么项目
            这些项目的数据
                用户数多少
                日活多少
                qps多少这类
            这些项目用到的技术
                x 语言
                x 框架
                x 中间件
            准备一份英文的自我介绍
        技术面试
            网络笔试时，遇到不会的，就直接搜索，除非明确不能搜索答案且遇到一个很强的反作弊机制
            现场笔试时，遇到不会的，就用手机搜索，除非面试官明确不能上网搜索且一直看着你
            根据简历里的内容发散地提问
                在做 xx 时要没有遇到什么问题
                如何解决某个问题
                为什么要用这种方法解决某个问题
                出现某个问题的原因是什么
                这种方法的原理是什么
                解决x问题还有更好的方法吗
                解决方法a和解决方法b有什么区别，什么时候用解决方法a，什么时候用解决方法b
            根据某一技术的提问
                可以参考这个 软件技术通用的学习套路
            递归式提问
                例子
                    如何实现 x 功能
                    实现 x 功能要注意些什么
                    除了用 a 方式实现 x 功能之外还能用什么方式实现
                    用 a 方式实现和用 b 方式实现有什么区别
                    为什么能用 a 方式实现 x 功能
                    ...
                提问的方向可能是纵向的也可能是横向的
                    横向的
                        rest -> aoap -> graphql
                    纵向的
                        https -> http -> tls -> tcp -> ip -> Ethernet
                递归式寻找答案
                技术的边界
                    数学原理
                        例子
                            并发模型 -> 函数式并发 -> 函数式编程 -> Lambda 表达式 -> λ演算 -> 数理逻辑
                            关系型数据库 -> sql -> 一阶谓词演算 -> 数理逻辑
                    物理实现 -> 物理原理
                        关注四种硬件
                            cpu -> 数据处理
                            内存 -> 数据存储
                            硬盘 -> 数据存储 - 持久性的
                            网卡 -> 数据传输
                        例子
                            并发模型 -> 多线程 -> 锁 -> 异常和中断 -> cpu的指令 -> APIC
                            关系型数据库 -> 索引 -> 文件系统 -> 硬盘
            一些常见问题的解决方案（系统设计的问题）
                通过反问让问题具体化，然后具体问题具体分析不要宽泛地描述，例如
                    如何设计一个秒杀
                        问题的业务流程是怎样的
                            业务流程是否已经确定下来了
                                我能不能修改或影响业务流程
                        预计会有多少用户
                        库存有多少
                        有多少预算
                            我能不能增加预算
                        服务器的环境是怎样的
                            只有一台服务器，还是有多台服务器
                            如果是多台服务器，是使用了集群还是就简单的负载均衡
                            我能不能修改服务器的环境
                        工期是多久
                        预测可能存在的瓶颈
                        针对瓶颈做特别的设计
            一些基础的问题
                tcp握手
                线程和进程
                cookie和session
                ...
                八股的五个方向
                    数据传输
                        计算机网络
                    数据存储
                        数据库
                            mysql
                            mongodb
                            es
                            redis
                        数据结构
                    数据处理
                        操作系统
                        算法
                        各种语言
                            语言的语法
                                基本语法
                                标准库的使用
                            语言的框架
                                例子
                                    java -> Spring
                                    php -> Laravel
                            语言的实现
                                例子
                                    java -> jvm
                                    php -> zend
                        中间件
                            应用防火墙
                            反代
                            缓存
                            队列
                            定时任务
                    数据的可视化
                        前端全家桶
                    系统设计
                        4S分析法
                            Scenario（场景），Service（服务），Storage（存储），Scale（扩展）
                        系统设计原则
                            合适优于先进 > 演化优于一步到位 > 简单优于复杂
                        服务治理
                        集群和分布式
                八股的三种类型
                    细节
                    底层
                    极端
            不同类型公司的提问套路
                小公司会问前端相关的
                外包会问框架相关的
                大公司会问系统底层和算法
                有自己项目的公司会问一些场景下问题的解决方法
            遇到手写 leetcode 题目或手写红黑树这类问题时要怎么办
                leetcode 题目太多，背不完的
                平时要多做 leetcode 的题目，要保持那种做题的思维
                按着直觉把代码写出来就可以的了，写不完的话，就描述一下自己的思路，写错了也没关系，要把关键集中在自己解题的思路
                手写红黑树可能真的太难了，但一些简单的，例如 二叉树反转 二分搜索 冒泡排序 快速排序 这些全都背下来其实也没多少
            遇到真的不会的问题时怎么办
                为什么不会这个问题
                    没有接触过的新技术
                        例如 平时用 redis 实现队列，但面试时问到了 kafka
                    没有接触过的新场景
                        例如 平时做 curd ，但面试时问到了 音视频处理
                    一些技术细节没有背到
                        例如 问 nginx 配置文件里，某个冷门的配置项的作用
                    在缺少必要资源的情况下解决问题
                        例如 没有mysql和其它数据库软件的情况下如何保存数据，并确保数据的acid
                    极端情况下的设计
                        例子
                            并发放大10倍甚至100倍
                            数据库的数据量放大10倍
                            响应的时间缩小10倍
                        如何应对
                            大公司披露的一些数据
                                让面试官知道你知道业界的上限在哪里
                            成本和效率
                            人的感受
                            物理限制
                            决策者的偏好和取舍
                要传达出一种能力，我不会，是因为没有遇过，我的学习能力很强，只要我遇到了，我就能解决
            遇到对回答不认可的情况怎么办
            还有什么问题
                目的1 了解岗位信息
                    假设成功入职会负责哪方面的工作
                    这个岗位是新增的还是补缺的
                    假设我成功入职，你会是我的上级吗
                    你现在的岗位是什么（如果一开始时面试官没有介绍）
                    你的岗位在这个公司处于一个怎样的位置？（技术合伙人？高管？中层干部？基层打工人？）
                    项目管理的流程是怎样的
                        有使用项目管理工具吗？使用什么样的项目管理工具
                    项目多久进行一次迭代
                    入职后所在的团队有几个成员？他们分别负责哪些工作
                    你们的项目有文档吗
                        代码规范
                        git规范
                        开发流程
                        api文档 -> 给开发者看的，通常是给前端看的，但外部调用的都会用到吧
                        开发文档 -> 给开发者看的
                        项目的使用手册/终端用户文档 -> 给用户看的，对于开发者而言是用来理解业务流程的
                    项目能在本地完整地运行吗
                    项目的测试是如何进行的，有单独的测试岗位吗
                        功能测试？压力测试的？
                    什么时候会有面试的结果
                    后续还有什么流程
                        后续还会有来自人事部门的面试吗
                            如果没有，可以把 人事面试 反问的问题移动到这里询问
                    假设顺利入职，有针对新员工的培训吗
                目的2 了解自己还有哪些方面需要完善
                    这个岗位在我之前，你们已经面试了多少个人了
                        这是第一个面试 或 不知道
                            从我面试的表现来看，你觉得我还有哪些方面需要完善
                        前面有 x 人
                            你觉得我和前面面试的人有哪些劣势
                            你觉得我和前面面试的人有哪些优势
                                如果这个问题没有正面回答，就回到
                                    从我面试的表现来看，你觉得我还有哪些方面需要完善
                    我的简历是由你来筛选的吗
                        如果是
                            我的简历里有哪些地方点吸引到你们，让你们给了我这个面试的机会
                        如果不是
                            你觉得我的简历写得怎样，如果让你来筛选简历，我的简历能获得面试机会吗
                                如果能
                                    回到前一个 如果是 的问题
                                如果不能
                                    你觉得我的简历还有哪些方面需要完善
                    你觉得我笔试题目做得怎样（如果有笔试，且你确认面试官看过你的笔试答案）
                    把前面的某一个问题复述一次，问面试官这类问题你们在工作中是怎么解决的
        人事面试
            常见的问题
                个人职业规划
                有什么缺点
                    至少描述一个缺点，但这个缺点不会影响工作
                有什么优点
                    至少描述一个优点，而且这个优点会促进工作
                上一份工作离职的原因是什么
                你遇到的最大问题或者是困难是什么
                记忆深刻的事情
                有什么崇拜的人吗
                希望去哪里就业
                有什么兴趣爱好，能拿得上台表演的有吗
                你了解这家公司吗
                你能为企业带来什么
                你为什么选择这家公司
                MBIT职业性格测试
                一些迷信的问题
                    八字 生肖 星座 血型
            还有什么问题
                工资多少
                工资的结构是怎样的
                劳动合同上写的工资是多少
                有没有社保
                有没有公积金
                公积金的比例是多少
                试用期是多久
                试用期的工资怎么计算
                上班时间
                下班时间
                上班下班是否需要打卡，如果需要则怎样打卡
                每天需要写日报吗 每周需要写周报吗 每月需要写月报吗 还有季度 年中 年末
                平时工作用什么交流
                    钉钉 企业微信 微信 qq
                有没有双休
                有没有年假
                有没有加班费
                    怎样计算加班费
                请假的流程是怎样的
                中午在哪里吃饭
                是否有团建
                    上一次团建的时间是在工作日吗
                如果是现场面试，还要问一下，上班地点和面试地点是否一致
                你们是几号发工资的
                当前公司大概有多少名员工，主要是和 参保人数对比一下 ，如果 参保人数远小于公司当前员工，那么这家公司就可能是坑
                你在这家公司工作多久了 通过员工的在职时间判断公司是否是好的公司
                什么时候会有面试的结果
                后续还有什么流程
                有针对新员工的培训吗
        如果一些问题面试官没有正面回答的，就不要追问了，不要把气氛弄得太尴尬
        如果觉得面试的公司没有太多诚意的话，就不要勉强自己
        如果是现场面试，还要观察一下公司的办公环境
        一天只面试一场，每次面试完都要记录下面试的过程（如果记不住，就带一支录音笔，手机的电池未必能续航这么久）
            例如，技术面有哪些问题，反问的时候对方是怎么回答的
            一方面可以查漏补缺，另一方面在收到多个 offer 时，可以更好地对比不同的公司
            列一个表格，对比各家公司的条件
                公司规模 办公环境 工作地点 是否双休 上班时间 有没有加班费 工资 试用期工资 试用期长度 社保 公积金 其它补贴（补充医疗 餐补 通勤补贴 通讯补贴 租房补贴） 奖金 期权 工作内容 技术栈 调薪或晋升体系 。。。
        去面试之前，一定要先认真地准备，最好预留一周的时间，认真地准备面试
            主要是复习各类基础知识和背面试题目
        可以先找几家不是目标公司面试，先积累一下面试的感觉
        先准备一周，然后随便面试一周，最后才是目标公司的面试（但准备这么久目标公司的岗位可能已经没有了）
        面试的关键在于 预判面试官的问题，预判面试官对问题答案的期待
    拒绝不合适的公司
        要对比已经收到的 offer
    试用期期间要考虑去留
        面试时承诺的工资福利是否给到位
            工资发放是否准时
        工作内容
            是否和面试时描述的一致
            是否能提升自己的能力
            是否为自己感兴趣的
        工作氛围
            和同事相处是否融洽
            和上级相处是否融洽
        工作环境
            办公室里是否有 wifi ，办公室的网速如何
            办公用的电脑性能是否足够
            工位坐得舒服吗 办公椅和工位面积
            办公室是否有茶水间
            办公室有没有免费的茶或咖啡提供
            洗手间的环境怎样
            新装修的，有甲醛
            写字楼太残旧了
    如何融入工作环境
        刚入职时遇到问题要多问同事和上级
        要重视第一个工作任务
        要记录工作任务和解决问题的流程
    如何离职
        要先了解离职的流程
            问人事
            问其它同事
            从员工手册里寻找相关流程
            最好入职时就找人事问清楚，等到真的要离职时才找人事问离职的流程，就很容易暴露自己离职的想法了
        要在各个招聘平台屏蔽当前公司，最好就是离职完了，才开始找下一份工作
        不要被其它同事察觉你要离职
        一旦提了离职，就必须跑路
    实在找不到合适的公司时怎么办
        继续坚持
        通过面试的记录（就是面试完之后记录了），判断自己哪方面薄弱，着重加强哪方面
        先停下来，别去面试，先完善好自己薄弱的地方再出去面试（一周左右就差不多了）
        如果没钱了怎么办
            先找一家小公司入职，然后在试用期结束之前跑路（快则一个月，慢则三个月），期间要保持学习
    为什么总是找不到好的工作
        主观的原因
            年龄大了
            不愿意或没有勇气 润
                不是出国才叫润，润去更好的省份，更好的城市也可以算润
            没有能力 润
                有没有勇气润和有没有能力润是两个不一样的问题
            基础还是不够好
            准备不够充分
            面试时太紧张了，未能完整地向招聘的企业展示自己的能力
            一些情况下 OverQuality 也是面试失败的原因
        客观的原因
            市场已经萎缩 这是根本原因
                求职者多，岗位少
                招聘的企业会不断地提供入职的门槛，即使远超岗位要求
                招聘的企业会不断地附加入职的条件，即使和工作一点也不相关
            面试的时候，面试官的水平太低
                只想着用困难的题目拦着求职者，而忽略公司实际的业务需求和工作环境
                这使得求职者的情况和公司的需求即使互相适合，求职者也无法顺利地通过面试
            面试时的问题和 岗位描述 任职要求 差距很大，面试之前又刚好没准备到相关的知识，导致面试的表现不好
                例如，岗位描述里是后端开发，但在面试时又问了很多前端相关的知识
            用人单位没有能力准确地判断应聘者的水平
                通常情况下，招聘的企业会通过这几个方面了解应聘者的水平
                    简历
                    学历
                    证书
                    上一家公司的规模
                    上一份工作的内容
                    上一份工作的工资
                    面试的表现
                    笔试的表现
                    github
                    leetcode
                    博客
软件技术通用的学习套路？
    主要的应用场景
    出现的背景
        解决了什么问题
    相关概念
    如何使用
        下载
            官网
            github
            应用商店
        安装
            包管理器
            源码编译
            docker
            安装包
            绿色版
        有哪些配置项
        基本使用
            有哪些功能，每个功能对应的场景
            在各种场景下的使用方式
    常见问题及应对方法
    和其它同类技术的比较
        有什么优势
        有什么劣势
    底层实现原理
        这项技术 或 这项技术中得某个功能 是如何实现的
        这项技术 或 这项技术中得某个功能 为什么会这样实现
            做了哪些取舍
            例如 apache 为什么选择了 多进程模型 ， nginx 为什么选择了 epoll
    这个服务或产品背后的文档和标准
        例如 nginx 的文档 和 http 的 rfc
        标准是标准，实现是实现，
        很多时候实现不一定会跟着标准来
        标准有时会指导实现，实现有时又会被标准追认（例如 http 的代理 rfc 2730 2731）
    例子
        telnet inetd
这些年来的生活经验 学习如何学习 如何定位问题 如何寻找问题的解决办法
    这些年来的生活经验
        要有一个博客记录开发的经验
        要有一个 github 并上传一些代码
            每个仓库的代码尽量是完整的，可以运行的
            每个仓库都需要有一个 README.md
            仓库的 README.md 至少包含这几部分
                简单的介绍
                如何安装
                如何使用
                LICENSE
        尽量参与一些开源项目
        要在 leetcode 刷题，也不用刷很多，起码一星期一题保持手感
        要重视基础
            操作系统
            计算机网络
            数据库
            数据结构
            算法
            软件工程
            信息安全
        要了解新技术
            新技术出现的背景
            新技术解决了什么问题
            理解新技术相关的概念
            实践新技术
        要看新闻，特别是业界的新闻，但又不能只看业界的新闻，其他领域的新闻也要留意一下
        参与一些社群，多和同行交流
        英语水平起码要达到 能看懂文档，能在 issues 用英文和其它人交流
        即使不想跳槽，每年至少也要出去面试一次，这样能了解自己的水平，工资的行情，技术的发展方向
        即使不需要面试，也要每三个月更新一次简历，回顾这三个月自己的工作和学习，判断技能是否有提升
        要学会投资理财
        知识和经验是一个有向图，树形结构不能完整地表示
        知识原子化，理清楚知识之间的依赖，就像 composer 处理依赖那样，像管理 依赖/包 一样，管理知识和经验
        不谋全局者，不足以某一域，所以，计算机领域的知识应该要全都会，才能做好某一方面的工作
        不要只关注技术，其它领域也要留意
            平面设计
            产品设计
                产品需求文档
                原型设计
                竞品分析
            产品运营
                策划
                文案
            团队管理
            财务管理
        在实现财富自由之前，能赚钱的技术才是好的技术
        每年都要体检一次
        要尽力保持一个健康的生活方式
    学习如何学习
        从问题出发
        从兴趣出发
        要抓住关键的问题，不要沉迷在细节里
        各种标准
            rfc
            ieee
            w3c
            iso
        各种文档
            mdn
            msdn
            对应工具的官方文档
        各种教程
            对应工具的官方教程
            第三方教程
        教程文档要和实际使用的版本对应上
        各种社区，论坛和博客
        各种命令行提示
            h help -h --hep /h /? /help
            man
            info
        在 github 寻找相关仓库并阅读源码
            特别是各种协议的实现，有时候 rfc 文档也未能会写清楚，去看一下对应的开源实现是一个好的选择
        要主动地实践
        要记录经验
    如何发现问题
        开发者要理解业务流程才能改好地发现问题
        发现问题和寻找瓶颈的套路是基本一致的
        要重视测试
            最好要有单独的测试岗位
            开发者要测试自己写的代码
            开发者要写测试用例
            最好有单独的测试环境
            代码上线前最好先经过测试环境
        要有单元测试
            部署上线前要通过单元测试
        至少要有一个由用户上报问题的渠道
        平时要监控服务器的状态
            各种系统参数
                cpu 使用率
                内存 使用率
                磁盘 I/O
                网络 I/O
                内核参数
                    信号量
                    打开文件数
            Nginx 和 Apache
                nginx 错误日志
                nginx 响应日志
            fpm
                php-fpm的执行日志
                php-fpm的慢执行日志
            MySQL 慢查询日志
            redis
            定时任务
            守护进程
            各类中间件的监控
            日志记录要完整
                要有完整的调用链路
                要有完整的栈堆
                遇到 mysql 的死锁异常要记录死锁日志 show engine innodb status
                要尽可能地多记录一些信息
            等等。。。
        发现异常要及时警报
            短信 邮件
        通过 xdebug 的 profiler 和 trace
            但 xdebug 肯定不能用在生产环境
    如何定位问题
        判断问题是什么
            问题出现的环境
                浏览器版本 用户组 操作系统 之类的
            问题出现的业务场景
                注册 登录 浏览商品 下单 支付 之类的
            出现问题之前都进行了哪些操作
            问题是由谁发现的
                开发者 测试 运营 用户 上级同事 之类的
            发现问题的人是如何描述问题的
        尽量收集问题相关的信息
            有没有错误输出
            寻找对应的日志记录
                知道哪些位置有日志可以查看
                能看懂日志，从日志中获取有用的信息
                最好能把问题和日志记录对应上
        了解完整的调用链路
            从浏览器输入 url 到页面展现的完整过程
            请求经历了多少次转发，调用了哪些服务
            进程执行文件的位置，进程配置文件的位置，执行这个进程的用户
    如何寻找问题的解决办法
        解决问题要从简单的例子入手
        把一个大的问题分解为多个小的问题，然后逐个解决
        在 搜索引擎里搜索
            bing 国内版
            百度
                百度开发者搜索 https://kaifa.baidu.com/
            bing 国际版
            google
            用英文在 google 上搜索
        在q群里提问
            如何加q群？
                在qq添加那里直接搜索对应的关键字就可以了
                例如，直接搜 php 就会有php的群，然后就申请加入，最好一次多加几个，因为有可能不通过
            在q群里提问可以以 酬谢 红包感谢 这类字眼结尾
            除了q群之外，还可以找钉钉群 微信群之类的
        在 stackoverflow segmentfault 等技术类的网站搜索
        如果是某个特定软件的问题，
            去看官方的文档
            去官方的论坛（如果有）上搜索
            去 github iusess 上搜索
        如果用中文搜不到，就把问题翻译成英文再搜一次
        如果遇到英文网站看不懂就用谷歌翻译
        问一下朋友，同事，同学，把问题发到朋友圈上
        问一下 chatGPT newbing 这类 AI
        在 segmentfault 知乎 等网站找大佬，付费提问
        尝试一下大力奇迹
            把当前的问题特例化，不考虑通用的情况，把当前问题解决了再算
            不考虑内存和时间的消耗，内存不够就加内存，时间太久就升级cpu
        尝试换一种思路去解决问题
        问题解决之后要做一个记录
        如何描述问题
            描述目标
            描述问题
            描述问题出现的环境
            描述一下为解决这个问题做过的努力
        如何提问 https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md
如何进行技术选型
    要做什么
    当前有哪些资源可以使用
        有多少预算？
    我们能做什么
        在当前的资源下我们能做什么？
    时间限制？
    对项目发展的预期是怎样的
    大多数情况下，开发效率比运行效率重要
        因为大多数情况下，硬件成本比人力成本低
如何搭建一个邮件服务器
    单机的在不同用户间发送邮件
        apt install -y mailutils
        这句命令安装的是 exim
        如无意外，安装完后就能直接用 sendmail mail mailx 命令了
        发送邮件给其它用户
            使用 mailx 命令发送
            echo "test mail content" | mailx -s "test mail subject" root
            echo 邮件内容 | mailx -s 邮件主题 用户名
            使用 sendmail 命令发送
            echo -e "From: root\nTo: root\nSubject: 问候\n\n我是 root 用户，这是一封用 sendmail 命令发送的邮件。" | sendmail -t
            sendmail -t <<EOF
            From: root
            To: root
            Subject: 问候

            我是 root 用户，这是一封用 sendmail 命令发送的邮件。
            EOF;
        查看用户的邮件
            mail -u root
            mail -u 用户名
            mail -f /var/spool/mail/mail
            mail -f 用于保存邮件的文件路径
        邮件保存的位置
            目录
                /var/spool/mail 这个目录会软连接到 /var/mail
                /var/mail 这个是实际的目录
            文件
                /var/mail/root
                /var/mail/用户名
        日志
            日志文件的目录
                /var/log/exim4
            日志文件
                /var/log/exim4/mainlog
            预防万一可以先事先新建一个
                ls -l /var/log/exim4
                mkdir -p /var/log/exim4
                touch /var/log/exim4/mainlog
            查看日志
                cat /var/log/exim4/mainlog
    在局域网里自娱自乐
        至少需要搭建 smtp 和 imap
    能收发外网的邮件
        除了 搭建 smtp 和 imap 之外，还要做好域名的解释
        域名解释才是最困难的部分
        要确保这几个端口的开放
            25 465 143 993
            除了安全组，防火墙，还要向运营商确认这几个端口有没有开放
使用正则表达式实现的关键词过滤
    定义关键词列表
    把关键词转换为正则表达式
        一般的例子
            例子 -> /(?<tag>例子)/iu
        排除中间的干扰字符
            例子 -> /(?<tag>例[\s\x{3000}\.\-_]*子)/iu
    判断是否包含关键词
    把关键词替换成其它字符
    一般文本
        渲染文本->orc->文本->tts->语音识别->识别后的文本->语义分析->判断是否违规
            即使是一般文本也要渲染一次，因为 unicode 有组合字，有控制文本方向的字符，还有各种不可见的空格
            可以通过控制文本方向来规避检测，例如这样
                rlo词键关 渲染后就是 关键词
    富文本
        渲染文本->orc->文本->tts->语音识别->识别后的文本->语义分析->判断是否违规
    后台管理员要随机抽查
    要有一个由用户举报的渠道
KiB 和 KB 和 Kb 和 Kbps 的联系与区别
    b 是 bit 的缩写 比特
    B 是 Byte 的缩写 字节
    bit 是计算机里最小的单位，只有 0 和 1
    byte 是程序访问内存的最小单位
        绝大多数情况下 1 Byte = 8 bit
    byte 是 SI 里用于描述信息量的单位
    国际电工委员会IEC的单位
        1KiB = 1 Kibibyte = 1 kilo binary byte = 2^10 byte = 1024 byte
        1MiB = 1 Mebibyte = 1 Mega binary byte = 2^20 byte = 1048576 byte
        1GiB = 1 Gibibyte = 1 Giga binary byte = 2^30 byte = 1073741824 byte
        1TiB = 1 Tebibyte = 1 Tera binary byte = 2^40 byte = 1099511627776 byte
        1PiB = 1 Pebibyte = 1 Peta binary byte = 2^50 byte = 1125899906842624 byte
        1EiB = 1 Exbibyte = 1 Exa binary byte = 2^60 byte = 1152921504606846976 byte
        1ZiB = 1 Zebibyte = 1 Zetta binary byte = 2^70 byte = 1180591620717411303424 byte
        1YiB = 1 Yobibyte = 1 Yotta binary byte = 2^80 byte = 1208925819614629174706176 byte
    国际单位制SI的单位
        SI的单位都是十进制的
        1KB = 1 Kilo byte = 10^3B = 1000 byte
        1MB = 1 Mega byte = 10^6B = 1000000 byte
        1GB = 1 Giga byte = 10^9B = 1000000000 byte
        1TB = 1 Tera byte = 10^12B = 1000000000000 byte
        1PB = 1 Peta byte = 10^15B = 1000000000000000 byte
        1EB = 1 Exa byte = 10^18B = 1000000000000000000 byte
        1ZB = 1 Zetta byte = 10^21B = 1000000000000000000000 byte
        1YB = 1 Yotta byte = 10^24B = 1000000000000000000000000 byte
    乘数词头对应的中文
        kilo 千
        mega 兆
        giga 吉
        tera 太
        peta 拍
        exa 艾
        zetta 泽
        yotta 尧
    KiB 和 KB
        KiB 是基于2次冥
        KB 是基于10次方
        在 windows 里 KB 就是 KiB
        在 linux 和 mac 里会区分 KB 和 KiB
        KB 这种单位一般用于描述硬盘或内存的容量
        换算
            1. 找到同级单位的比例
            2. 乘以同级单位的比例
            例子
                1KiB = 1.024KB
                2KB = ?
                    1 * x=1.024
                    x = 1 / 1.024
                2KB = 2 * x
                     = 2 * 1 / 1.024
                     = 1.953125KiB
                2KiB = ?
                     1 = 1.024 * x
                     x = 1.024 / 1
                2KiB = 2 * x
                     = 2 * 1.024
                     = 2.024
    Kbps
        bps
            bit per second
            位  每   秒
            每秒能传输的位
        1 Kbps = 1 Kilo per second = 1000 per second
        1 Mbps = 1 Mega per second = 1000000 per second
        1M 带宽是指 1Mbps
            实际速度还要考虑各种头信息和各种控制信号
        带宽用2次冥还是10次方？维基里显示的是用10次方，但中文互联网很多文章都是用2次冥
            个人倾向于应该是用10次方的，因为一般硬件厂商都是用10次方的
        这种单位一般用于描述网速
    KiB/sec
        KiB/sec = KiB/s
        sec = second
        1 KiB/sec = 1 KiB 每秒
        这种单位一般用于描述硬盘的读写速度
    总结
        b 是 bit
            类推 Kb 是 Kilo bit
        B 是 byte
            类推 KB 是 Kilo byte
        中间没有 i 的是基于10次方，中间有 i 的是基于2次冥
        后面带着 ps 或 sec 的是每秒的意思，一般用于描述速度
        硬件一般用基于10次方
        软件一般用基于2次冥
        2次冥 > 10 次方
            单位越大差距越大
        大多数语境下 KB 和 KiB 会混用
            特别是口语里只会说 xxK 或 xxM 很少会说 xxKiB 这种
        在编程开发中，尽量使用 KiB
        http://www.elecfans.com/tools/zijiehuansuan.html
带宽 和 宽带 和 位宽 的联系与区别
    带宽（Bandwidth）一开始的意思是电磁波频率的范围，最高频率和最低频率之间的差值
    在计算机领域中的带宽一般是指数据传输的速度，包括但不限于，网速，内存速度，接口速度
    计算机领域的带宽，其实是在描述理论上的最高速度
        例如 512Kbps 的带宽，是指最高速度达到 512Kbps ，实际上的速度应该是会小于等于 512Kbps 的
    带宽的单位是 bps
    宽带（Broadband）是指较宽的带宽，一般是指比较快的网速
        最开始是把 56Kbps 以上的带宽称为宽带，56kbps 以下的称为窄带（Narrowband）
        后来又变成了 512Kbps 以上的带宽才能称为宽带
        再后来又变成了 4Mbps 以上的带宽才能称为宽带
        感觉宽带就是一个营销术语
        ps 墙内的运营商的家用宽带一般都是指下行速度
    位宽是指一次能传输的数据量，就是一次能传输的比特位数
        例如， 64位的位宽就是指一次能传输64个比特位，通常位简称为 64位（64bit）
        内存带宽一般是 内存频率*内存位宽 ，显存带宽也是一样的计算
浏览器引擎 渲染引擎 js引擎 的联系与区别
    各种名词
        浏览器（Browser）
        浏览器引擎（Browser Engine）
        浏览器内核（Browser Kernel）
        排版引擎（Layout Engine）
        渲染引擎（Rendering Engine）
        JavaScript 引擎（JavaScript Engine）
        WebView
    理解
        Browser = Browser Engine + 一堆外围功能
        Browser Engine = Browser Kernel
        Rendering Engine = Layout Engine
        Browser Engine
            广义的 Browser Engine = Rendering Engine + JavaScript Engine
            狭义的 Browser Engine = Rendering Engine
        JavaScript Engine
            在浏览器引擎中的 JavaScript 运行时
        WebView
            嵌入在其它应用的浏览器 或 一个精减版的浏览器
            webviw 通常以组件的形式出现，不能单独运行
            现代操作系统大多会提供 webview 组件
        Chrome Chromium Blink 之间的联系
            Chromium 是一个基于 Blink 的开源的浏览器
            Chrome = Chromium + 谷歌服务 类似于 安卓 = AOSP + 谷歌服务
            新版的 Edge = Chromium + 微软服务
            Blink 是一个派生自 Webkit 的开源的引擎
            古早版本的 Chromium = Webkit + v8 ， Webkit 中的 JavaScriptCore 被 v8 替换了
    常见的浏览器引擎
        Khtml -> Konqueror
        Gecko -> firefox
        Webkit -> safari
            在 webkit 的文档中有明确地提及到
            WebCore 是 Rendering Engine
            JavaScriptCore 是 JavaScript Engine
        Blink -> chrome, 新版的 Edge, 新版的 Opera
        Trident -> ie
        EdgeHTML -> 旧版的 Edge
            EdgeHTML 是 Trident 的一个分支
        Presto -> 旧版的 Opera
    常见的 JavaScript 引擎
        monkey -> firefox
        KJS -> Konqueror
        V8 -> chrome, 新版的 Edge, 新版的 Opera
        JavaScriptCore -> Webkit
        Jscript -> 旧版的 ie
        Chakra -> 新版的 ie, 旧版的 Edge
        Carakan -> 旧版的 Opera
    安卓的浏览器
        Chrome和Android在Google属于完全不同的两个团队，Android是收购来的项目
        Android的原生浏览器是一个基于Webkit的实现
        所以原生的安卓webview也是WebKit内核
        但4.4之后，安卓的原生浏览器就换成使用 Chromium 实现的了
        同样地4.4之后的 webview 也是 Chromium
        一些浏览器的实现会直接使用系统的 webview 例如 chrome lite
        一些浏览器则会自己带着一个 webview 例如 chrome
            可以在系统设置里修改 webview 的实现，前提是有安装其它 webview
        ios 里的浏览器和webview全都是safari的套壳
    无头浏览器（headless）
        无头浏览器起码要能执行js
        常见的无头浏览器
            基于 Webkit 的 PhantomJS
            基于 Gecko 的 SlimerJS
            基于 Rhnio 的 HtmlUnit
            基于 Webkit 的 Splash
        浏览器的无头模式
            chrome edge firefox 都有无头模式
        Playwright 和 Selenium 都要配合浏览器使用，不是无头浏览器
    除了浏览器之外的 js 运行环境
        nodejs 基于 V8
        deno 基于 JavaScriptCore
        bun 基于 TypeJavaScript
        QuickJS
        在java中的
            Rhino
            Nashorn
    文本浏览器/终端浏览器/命令行浏览器
        能运行在 终端 中的浏览器
        w3m
        Lynx
        Links
程序 软件 应用 的联系与区别
    英文
        软件 software
        应用 application
        程序 progrem
    含义的范围
        software > application > progrem
    具体的解释
        application 是为最终用户设计的 software
            application 有时会被翻译为 应用程序
            application 是 application software 的缩写，是一种 software
            除了 application software 还有 system software 还有 middleware
        software 由 程序、数据、文档 组成
        progrem 是 software 的组成部分，一个软件至少包含一个 progrem
    更多的名词
        软件 software
        应用 application
        命令行 command line
        命令 command
        内置命令 builtin command / built-in command
            普通的命令，shell 会 fork 一个子进程来运行
            内置命令，shell 自己就能解释，一般不会 fork 子进程
        文件 File
        文件夹 Folder
            文件夹（Folder）是GUI对象，是一个逻辑概念，不一定映射到物理目录，
            文件夹概念一般用在Windows操作系统或者Linux的图形界面。
            目录（Directory）是文件系统对象，大部分时候可以与文件夹概念互换。
            在命令行控制台中查看时通常称为目录，
            但如果通过图形文件管理器访问，有时可将其称为文件夹。
        目录 Directory
        文本文件 Text File
        二进制文件 Binary File
        可执行文件 Executable File
        程序 progrem
        进程 process
        线程 thread
        协程 coroutine
        异步 asynchronous
        同步 synchronous
        文档 document
        数据 data
        配置 configuration
        中间件 middleware
        网页 webpage
        网站 website
        常量 constant
        变量 variable
        值 value
        开关 switch
        选项 option
        代码 code
        脚本 script
        拓展 extension
        插件 plugin
        组件 component
        模块 module
        框架 framework
        库 library
        包 package
        代码片段 code snippet
        函数 function
        功能 function
        方法 method
        对象 object
        类 class
        实体 entity
        预装 pre-install
        服务 service
        平台 platform
        产品 product
        解决方案 solution
        小部件 widgets
        工具 Utils Utility
        杂项 MISC Miscellaneous
        加载项
            plugins
            addins
            addons
            add-ins
            add-ons
            plugin
            addin
            addon
            加 s 是一个版本，加 - 是一个版本
            根据现有的 api 重新组合新功能的是 拓展
            通过增加 api 而添加新功能的是 插件
            其实多数情况下会被混用
            个人的理解
                脚本 重新组织 api 的使用
                插件 编译后的脚本
                扩展 增加新的 api
        计算
            operation
            arithmetic
            calculation
            compute
            counting
            algorism
        参数
            parameter
            argument
        属性
            attribute attributes
            property properties
            attribute 和 property 在不同的编程语言下会有不同的含义
            通常都能翻译成 属性
            有时会把 attribute 翻译成 特性 ， 把 property 翻译成 属性
        解决方案=以解决问题为导向的，产品和服务的集合
        产品=软件产品
        服务=软件服务
        平台=一堆服务的集合
        系统=服务+数据存储
        应用=面向终端用户的软件
        软件=程序+数据
        程序=算法+数据结构
        算法=逻辑+控制
        数学=逻辑+计算（计算这个词有歧义）
        进程=运行中的程序
        守护进程=在后台一直运行的进程
        定时任务=一个不断判断是否有任务需要执行的守护进程
        操作系统=一堆守护进程的集合
        中间件=服务于其它软件的软件
        数据结构=类型+结构
        控制=顺序+分支+跳转（goto）
        循环可以用分支+跳转实现
        逻辑=推理+归纳？
        命令=可执行文件名/内置命令 + 参数
        站点=网站
        网站=一堆网页的集合
        网页=一个经过浏览器渲染的html文件
        互联网/英特网 internet
        以太网 Ethernet
        万维网 World Wide Web
        IT 行业中各种名词的解释？
        IT 是 Information Technology 信息技术
        信息 information
        数据 data
        信号 signal
        知识 knowledge
        消息 message
        新闻 news
        讯息 在英文里没有直接对应的单词，一般翻译成 message
            在新文化运动时出现的新词
            权威的消息 最新的消息
        资讯 在英文里没有直接对应的单词，一般翻译成 news 或者 information
            资讯是一种信息，涵盖的不只是新闻，还可以包括其他媒介。
            资讯有时效性和地域性，它必须被消费者利用。
            并且“提供－使用（阅读或利用）－反馈”之间能够形成一个长期稳定的消费链，
            具有这些特点的消息才可以称之为资讯。
        情报 在英文里没有直接对应的单词，一般翻译成 information 或者 intelligence
        资料 在英文里没有直接对应的单词，一般翻译成 data 或者 information
        信息 和 数据 的区别？
            可以套用字符编码里的概念
            信息 -> 抽象的汉字 一
            数据 -> 具体的编码 E4B880
        信号是指数据的电气或电磁表现
            电磁 电气 的区别？
            电磁 简单但不严谨地理解 就是 无线信号 就是 电磁波
            电气 简单但不严谨地理解 就是 有线信号 就是 电流的高低电平
            信号 -> 传输介质的变化？
如何做一个npm库
    去npm官方文档注册账号,并验证邮箱 官网地址:https://www.npmjs.com/
    在github新建一个空仓库，并克隆到本地
    在仓库根目录内执行初始化指令(npm init)并设置包的参数
        接着就依次填写, 不想填写的话也可以一路Enter
        name: 模块名，之后发布之后就可以让用户npm install xxxx来引用你的开源模块了
        version: 版本号，语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。
            如果只是修复bug，需要更新Z位。 如果是新增了功能，但是向下兼容，需要更新Y位。
            如果有大变动，向下不兼容，需要更新X位。
        description: 简单介绍自己的模块
        main: 入口文件，必要，当通过require('xxx')时，是读取main里声明的文件
        test command: 测试命令
        git repository: git仓库地址
        keywords: 关键词，可以通过npm搜索你填写的关键词找到你的模块
        author: 作者信息，可以之后编辑更详细一些
        license(ISC): 代码授权许可
        以上放心可以大胆写，因为之后反正要改。
        初始化项目完成，可以看到目录中出现了一个叫 package.json 的文件
    新建一个 index.js 文件，并写入你的 js 方法
    执行 npm install -g 检查是否报错
    执行 npm link (旨在安装开发包并实时查看更改，而无需继续重新安装)
    执行 npm login 登录npm账号
    执行 npm publish 上传代码到npm包管理库
spa 的 ssr
一些文章
  原文链接 快照链接
git的一般使用指南
如何制作一个 php 框架
    组件
        解释http请求 和 发送响应 symfony/http-foundation
        路由组件 symfony/routing
        渲染视图 原生php 或 twig/twig
        控制器 symfony/http-kernel
        事件调度 symfony/event-dispatcher
        依赖注入 symfony/dependency-injection
        错误处理 symfony/error-handler
        日志 monolog/monolog
        文件管理 symfony/finder
        数据库 doctrine/orm
        命令行 symfony/console
        缓存 symfony/cache
        邮件 swiftmailer/swiftmailer
        数据库迁移 doctrine/migrations
        测试数据 fzaninotto/faker 虽然作者已经声明不维护了，但好像没有更好的实现
        国际化 symfony/intl
        http客户端 symfony/http-client
        认证和授权 symfony/security-core
        转义 ezyang/htmlpurifier
        验证 respect/validation
        单元测试 phpunit
        静态分析 vimeo/psalm
        格式检查 friendsofphp/php-cs-fixer
        突变测试 infection/infection
    php的小型框架
        https://github.com/slimphp/Slim
        https://github.com/jadephp/jade
        https://github.com/silexphp/Silex 基于 Symfony2 的，现在已经不更新了
    php的大型框架
        ci
        thinkphp
        laravel
        yii
        cakephp
        symfony
        yaf
        ZendFramework
        Phalcon
        workman
            GatewayWorker
            webman
        swoole
            easyswoole
            hyperf
    模板引擎
        Smarty
        Twig
        Blade
    参考
        https://symfony.com/doc/current/the-fast-track/zh_CN/index.html
        https://symfony.com/doc/current/create_framework/index.html
        http://www.symfonychina.com/doc/current/create_framework/index.html
        https://github.com/CraryPrimitiveMan/create-your-own-php-framework
        https://github.com/learnku-xxh-cds/php_frame
        https://github.com/yeszao/fastphp
        https://github.com/coolephp/skeleton
        https://www.awaimai.com/128.html
        https://learnku.com/articles/6271/build-a-micro-framework-for-your-project-using-composer
        https://learnku.com/articles/52099
        https://learnku.com/laravel/t/9365/teach-you-to-write-modern-php-code-without-using-a-framework
    把框架做成一个 composer project template
    框架的各个部分都用了哪些设计模式
    一般的运行流程
        先加载 composer
        再加载配置文件
        根据配置实例化 app 类
        接收和解释输入
        根据输入匹配路由
        根据匹配的路由实例化控制器
        执行控制器获得输出
        输出结果
一些未能分类的经验
    如何做一个 composer 包
        申请一个 composer 账号
        新建一个 github 仓库
        clone 到本地
        在仓库根目录里运行这句 composer init
    如何给其它 github 仓库提交 pr
        假设已经拥有一个 github 账号
        fork 仓库
        把 fork 的仓库 clone 到本地
        在本地修改，提交，推送到 github
        在原本的仓库新建一个 pr
一般的项目开发流程
    工具
        注册域名
        tls 证书
            自动申请 tls 证书的脚本 https://github.com/acmesh-official/acme.sh
            windows 需要用 git bash 或者用这个库 https://github.com/win-acme/win-acme
            其实不少域名注册商都能根据域名提供一个免费的证书
        LDAP
            openldap
            PhpLDAPAdmin
            linux 的账号管理
            公司内网的域管理
            其它信息系统的关联
                email
                oa
                hrm
                erp
                itam
                crm
        邮箱
            自建邮箱服务
                域名解释
                    A 记录
                        @ 指向 ip
                    CNAME 记录
                        mail 指向 A 记录
                    MX 记录
                        @ 指向 CNAME 记录
                    TXT 记录
                        spf dkim dmarc
                    PTR 记录
                        域名 指向 ip
                各种代理
                    mua webmail RainLoop
                    mta exim Postfix sendmail
                        amavisd-new 调度 ClamAV 和 SpamAssassin
                        ClamAV 邮件反病毒
                        SpamAssassin 过滤垃圾邮件
                    mda Dovecot
                    msa
                    mra
                    maa
                opendkim
                还有更多？ bimi RUA RUF MTA-STS TLS-RPT
            企业邮箱
            通讯录
                CardDAV
                ad 域或 ldap 的组织架构
        项目管理
            Redmine
            开发新功能
            bug管理
        流水线
            jenkins GitLab-CI
            代码格式检测
            代码静态检测
            测试
                单元测试
                突变测试
            构建镜像并提交到镜像仓库
            把镜像部署到对应的服务器（测试，生产）
        git 仓库
            GitLab gitblit gitea
            分支模型
                Git Flow
                Github Flow
                Trunk Based Development
                Aone Flow
        容器运行时
            docker
        镜像仓库
            Harbor Portus
        容器编排
            k8s
        服务器监控
            Prometheus Grafana kiali Zabbix
        中间件
            搜索引擎/全文搜索
                ElasticSearch
            缓存
                redis
                memcache
                squid
                varnish
                Apache Traffic Server (ATS)
            队列
                redis 的 disque 模块
                RabbitMQ ActiveMQ RocketMQ ZeroMQ OpenMQ
                Kafka Artemis Apollo Distributedlog
        数据库
            关系型 mysql mariadb PostgreSQL
            文档型 MongoDB
            图
            时序
            列
        日志
            elk loki
        内部文档
            入职用的文档，让新成员能迅速地熟悉工作流程，最好有纸质版（最好过塑或者套个塑料封套，因为会多次使用），因为电脑的配置可能需要一些时间
            公司的一些规章制度，例如 员工手册 之类的
            项目部署和开发的文档，让新成员能迅速上手项目的开发
        im
            企业微信
            钉钉
            qq
            其它内部im
                XMPP
                    Openfire
        文件共享
            webdav
            smb
            ftp
            网盘
                自建的网盘
                第三方网盘
        防火墙
            网络防火墙
                ufw
                firewall
                iptables
                TCP_Wrappers
                Netfilter
            web 防火墙
                ModSecurity
                Naxsi
                OpenWAF
                unixhot
                VeryNginx
        堡垒机
            shell 审计
            sql 审计
magento2 配置 paypal
数据结构和算法的学习笔记
数据结构
    基本概念和术语
        数据结构研究的内容
        数据
        数据元素
        数据项
        数据对象
        数据类型
        抽象数据类型
    算法和算法分析
        算法的定义
        算法的特性
            有穷性
            正确性
            可行性
            输入
            输出
        算法分析
            评价算法优劣的基本标准
                正确性
                可读性
                健壮性
                高效性
            算法效率分析
                算法效率分析分析的目的
                    算法是否实际可行
                    从多个算法中选出最优算法
                算法效率分析的方法
                    事后统计法
                    事前分析估算法
                时间复杂度
                    定义
                    问题规模
                    语句频度
                    最好时间复杂度
                    最坏时间复杂度
                    平均时间复杂度
                空间复杂度
    数据运算
        生成
        销毁
        插入
        删除
        遍历
        修改
        查找
            基本概念
            线性表的查找
                顺序查找
                折半查找
                分块查找
            树表的查找
                二叉树排序
                平衡二叉树
                B-树
                B+树
            散列表的查找
                散列表的基本概念
                散列函数的构造方法
                处理冲突的方法
                散列表的查找
        排序
            基本概念
                排序
                排序的稳定性
                待排序记录的存储方式
                    顺序表
                    链表
                    地址排序
                排序算法效率的评价指标
                    执行时间
                    辅助空间
                排序的基础是查找
            内部排序
                插入排序
                    直接插入排序
                    折半插入排序
                    希尔排序
                交换排序
                    冒泡排序
                    快速排序
                选择排序
                    简单选择排序
                    树形选择排序
                    堆排序
                归并排序
                分配排序
                    基数排序
                        多关键字的排序
                        链式基数排序
            外部排序
                外部排序的基本方法
                多路平衡归并的实现
                置换-选择排序
                最佳归并树
    存储结构
        顺序结构
        链式结构
        索引
        散列（哈希）
    逻辑结构
        集合结构
        线性结构
            一般线性表
                线性表
                    定义
                    特点
                    ADT定义
                        数据对象
                        数据关系
                        基本操作
                    顺序表示和实现
                        顺序表
                    链式表示和实现
                        链表
                            单链表
                                循环单链表
                                双向单链表
                            双链表
                                循环双链表
                                双向双链表
                    顺序表和链表的比较
                        空间性能的比较
                        时间性能的比较
                    应用
                        线性表的合并
                        有序表的合并
            特殊线性表
                栈
                    定义
                    特点
                    ADT定义
                        数据对象
                        数据关系
                        基本操作
                    顺序表示和实现
                        顺序栈
                    链式表示和实现
                        链栈
                    栈与递归
                队列
                    定义
                    特点
                    ADT定义
                        数据对象
                        数据关系
                        基本操作
                    顺序表示和实现
                        循环队列
                    链式表示和实现
                        链队
                串
                    定义
                    ADT定义
                        数据对象
                        数据关系
                        基本操作
                    存储结构
                        顺序存储
                        链式存储
                    运算
            线性表的推广
                数组
                    ADT定义
                        数据对象
                        数据关系
                        基本操作
                    顺序存储
                    特殊矩阵的压缩存储
                广义表
                    定义
                    ADT定义
                        数据对象
                        数据关系
                        基本操作
                    存储结构
                        头尾链表的存储结构
                        拓展链表的存储结构
        树形结构
            树
                定义
                基本术语
                存储结构
                    双亲表示法
                    孩子表示法
                    孩子兄弟法
                        比较常用，把一般树转换为二叉树，孩子在左边，兄弟在右边
                种类
                    无序树
                    有序树
                        二叉树
                            定义
                            性质
                            ADT定义
                                数据对象
                                数据关系
                                基本操作
                            存储结构
                                顺序存储结构
                                链式存储结构
                            完全二叉树
                                满二叉树
                            遍历二叉树
                                前序
                                中序
                                后序
                            线索二叉树
                                如果没有左孩子，则指向前驱，如果没有右孩子则指向后继
                            应用
                                哈夫曼树
                                    基本概念
                                    构造算法
                                        构造过程
                                        算法实现
                                    哈夫曼编码
                                        主要思想
                                            关于编码的两个概念
                                                前缀编码
                                                哈夫曼编码
                                            性质
                                                哈夫曼编码是前缀编码
                                                哈夫曼编码是最优前缀编码
                                        算法实现
                                        文件的编码和译码
                遍历
                    先根遍历
                    后根遍历
                森林
                    遍历
                        先序遍历
                        中序遍历
                    与二叉树的转换
                        森林转换成二叉树
                        二叉树转换成森林
        图形结构
            图
                定义
                基本术语
                    顶点
                    边
                    弧
                    子图
                    完全图
                        有向完全图
                        无向完全图
                    稀疏图和稠密图
                        稀疏图
                        稠密图
                    权，网
                        权
                        网
                    邻接点
                    度，入度，出度
                        度
                        入度
                        出度
                    路劲和路劲长度
                        路径
                        路径长度
                    回路或环
                    简单路径，简单回路或简单环
                        简单路径
                        简单回路或简单环
                    连通，连通图，连通分量
                        连通
                        连通图
                        连通分量
                    强连通图，强连通分量
                        强连通图
                        强连通分量
                    连通图和生成树
                    有向树，生成森林
                        有向树
                        生成森林
                ADT定义
                    数据对象
                    数据关系
                    基本操作
                存储结构
                    邻接矩阵
                    邻接表
                    十字链表
                    邻接多重表
                种类
                    有向图
                    无向图
                遍历
                    深度优先搜索
                    广度优先搜索
                应用
                    最小生成树
                    最短路径
                    拓扑排序
                    关键路径

网站性能优化的一般思路
    第一步是要寻找可以优化的地方，这一步可以参考 如何发现问题
    cpu
        升级服务器
            增加cpu数量
            更换更先进的cpu架构
            换成计算型的服务器
        优化代码
        前端渲染
        更换语言
    io
        升级服务器
            换成速度更快的硬盘，例如ssd之类的
        使用缓存
        更换数据库
        使用协程
            现在的php使用协程也提升不了io
            协程必须配合多线程或异步io来使用
        使用多线程或多进程
        优化数据库
            优化sql语句
                limit
                当只要一行数据时使用LIMIT1
                减少select字段
                避免 SELECT *
                要显式声明字段
                别除非必须，查询时不要显式加锁
            获取数据尽量只查询一次
            添加索引
                为搜索字段建索引
                where 和 on 要尽量用到索引
                索引要遵循最左原则
                更新频繁字段不适合创建索引
                若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
                对于定义为text、image和bit的数据类型的列不要建立索引
            使用存储过程
                少了sql语句解释的过程，执行速度会快一点
            从PROCEDURE ANALYSE()取得建议
            使用 explain 来判断 sql 的执行效率
            使用ENUM而不是VARCHAR
                使用tinyint会更好
            固定长度的字段会更快
            使用mysql的分区
            数据库读写分离
                一主一从
                一主多从
            适当增加冗余，避免多表查询
            搞分布式数据库，或者搞数据库集群
            适当使用nosql或new sql
                根据数据结构和业务来选择数据持久化的方案，不用把全部数据都存进关系型数据库里的
                例如 MongoDB 和 es
            通过系统拆分或微服务来达到分库
            极端情况下，如果一个表确定不会有修改操作，在遇到性能瓶颈时可以使用MyISAM 
            使用单独的数据库
                最好在同一个地区，可以内网访问那种
                最好是ssd硬盘的
        关闭非必要的日志
        临时文件可以存放在 /dev/shm ，如果不想改变原本的路径可以加个软连接
    php
        缓存模板文件
        启用 opcode
        如果可以还可以使用预加载
        php8要启用jit
        composer
            composer dump-autoload
            composer dump-autoload -o 
            composer dump-autoload -o --no-dev
            composer dump-autoload -o --apcu --no-dev
            删掉无用的库
            升级到composer2
                一些旧的框架可能会不支持
        一些对象只在首次使用时初始化
            对象 延迟实例化
        对于可以异步处理的任务
            提前返回
                要记得关闭 session ，如果有开启 session
            用队列
        显式声明类型
        使用严格模式 declare(strict_types=1);
        不要总是数组一把梭，可以留意一下spl
        session存到 memcache 或者redis或者/dev/shm
        fpm环境下要使用pdo的持久连接
        不要有太多重的循环
        有时foreach会比for快
            因为少了一个判断
        那堆数组的函数性能都不怎么高，使用时要注意性能和可读性维护性的取舍
        curl请求要设置超时
        日志记录使用专门的时序数据库（例如 InfluxDB 这类），而不是写文件或写mysql
        对日志进行分级
            详细的记录
            一般的记录
            不记录
    带宽
        提升带宽
        压缩/合并 js和css文件
        静态资源缓存
        切图（雪碧图）
            合并一些图片，使用切图的方式展示，这样可以减少http请求
            SVG雪碧图 替代 css雪碧图
        使用cdn
        前端渲染
        减少HTTP请求
        减小HTTP响应内容的大小
            减少不必要的http头
                例如 X-Powered-By 这种
                这样可以稍微减少一点http响应的大小
        dns加速
        压缩图片
        使用压缩率高的图片格式
            webp
        开启gzip压缩/提高gizp压缩级别
            这个会增加cpu的压力
        域名分片
        使用http2
        启用 http2 的 服务端推送（Server Push）
        http缓存
            强缓存
            协商缓存
        更换https的加密方式
            用 ECDH 作为密钥交换算法
        开启hsts
        http 301 重定向至 https
        避免重定向
    内存
        升级服务器
            增加内存
            或者换成内存型的服务器
        优化代码
            主动释放变量
            使用逐行读取的方式读取大文件 
        更换语言
        swap
    前端
        页面渲染
            首屏使用后端渲染
            把js文件放在body的最后
            把css文件放在head里
            js异步加载
                HTML5新属性
                    defer
                        如果script标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染；
                        如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；
                        defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。
                        文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&渲染完毕后。 会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。
                    async
                        async脚本会在加载完毕后执行。
                        async脚本的加载不计入DOMContentLoaded事件统计
                    使用场景
                        如果不太能确定的话，用defer总是会比async稳定。。。
                        defer 和 async 在网络下载这块儿是一样的，相较于 HTML 解析都是异步的。不同点在于脚本下载完之后何时执行，defer是在HTML完全解析后再最后执行，async是下载完立即执行
                        async
                            如果你的脚本并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。
                            例如 百度统计
                        defer
                            如果你的脚本代码依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件依赖。
                            例如 评论框
                ajax加载
                    Injection（注入）
                        创建一个script标签插入到dom中
                    Eval
                        返回js代码，直接放到eval里执行
                onload时的异步加载
                    例如jq的ready事件
                Script In Irame
                    在父窗口插入一个iframe元素，然后再iframe中执行加载JS的操作。
                页内JS内容被注释，所以不会执行，在需要的时候，获取script中的text内容去掉注释，调用eval()执行
            减少dom查询，尽量把多次操作合并到一起
            dom 节点不要太多，dom 节点的深度不要太大
            减少内联 js
                dom 节点不能太多，dom 节点的深度不能太大
            减少内联css
            减少 iframe 的使用
            避免图片的src为空
            图片要显式声明宽度
            使用媒体查询加载不同尺寸的图片
                https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture
            页面的动画效果尽可能用css完成
                因为要减少重排
            避免使用table做布局
                table及其内部元素除外，它可能需要多次 计算才能确定好其在渲染树中节点的属性
            减少重排，重绘
                dom操作会引起重排和重绘
                修改样式会引起重绘
                页面样式的变动尽可能只使用css完成
            一些消耗cpu但有不用操作dom的，可以扔进worker里
            使用insights
                查看优化建议
                https://developers.google.com/speed/pagespeed/insights
            提高加载速度
        图片懒加载
            img 标签加上 lazy 属性
        加入友好的等待动画
    并发
        使用负载均衡
            nginx的负载均衡
            lvs的负载均衡
            基于域名的负载均衡
        消息队列
        并发读 加缓存
        并发写 加锁
        并发读写 加缓存 加锁
    其它
        禁用服务器不使用的模块
        热点数据都放在缓存，且不过时，只能主动更新
        缓存预热
        多级缓存
            前端
            http
            nginx
            redis或memcache
            最后才是数据库
        如果可以使用内网ip或Unix域套接字(Unix Domain Socket) 实现各个组件之间的通讯
            例如 nginx的fastcgi配置里
                php fpm 的 socket unix 可以放到 /dev/shm 那里
            如果是那种微服务架构的估计就不行了
        nginx 和 fpm 的 backlog 可以设置高一点，甚至设为 -1 无限制
            backlog数，设置 listen 的半连接队列长度
        使用原生部署，不要用容器
            这样会增加运维的难度
        预编译正则表达式
            虽然php里没有这个
        正则表达式里可以忽略不需要的分组
        从mysql的慢查询日志寻找可以优化的地方
        从fpm的慢执行日志寻找可以优化的地方
        调整一些linux参数
            Huagepage
            打开的最大文件数
            tcp参数调优
                开启TCP BBR
            linux内核调优
        针对业务调整配置文件
            nginx配置
            fpm配置
            php配置
            mysql配置
        限流 降级 熔断
            这个有点抽象
            一般就限流比较容易实现
        系统拆分/微服务
        优化要针对瓶颈，麻木优化会可能增加系统运维成本/风险
        达到预期效果就可以停止优化的了，不要麻木优化
        优化手段的实施顺序
            容易实现，效果明显
            容易实现，效果不明显
            不容易实现，效果明显
            不容易实现，效果不明显
        真的解决不了性能上的瓶颈就解决业务场景
        当无法有效提升『实际性能』时，可以考虑适当转移用户的注意力，来缩短某项操作的感知时间，改善感知性能。
        优化不应该只有技术层面上的，产品层面上的优化也很重要
安全
    常见攻击
        DOS
            DDOS
                当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，简称DDoS攻击）
            防范方式
                设置ip黑名单
                限制单个ip在短时间内的访问次数
                session，接口都要有访问频率的限制
                防火墙仅允许特定的端口和协议访问
                syn
                    网关超时设置
                        防火墙计数器到时，还没收到第3次握手包，则往服务器发送RST包，以使服务器从对列中删除该半连接。
                        网关超时设置，不宜过小也不宜过大。过小影响正常通讯，过大，影响防范SYN攻击的效果。
                    SYN网关
                         SYN网关将数据包转发给服务器，需要第3次握手包时，SYN网关以客户端名义给服务器发第3次握手包。
                        一般服务器所承受的连接数量比半连接数量大得多。可以减轻SYN攻击。
                    增加最大半连接数
                禁用icmp
                    仅允许白名单下的ip ping
                流量清洗 
                    通过DDoS防御软件的处理，将正常流量和恶意流量区分开，正常的流量则回注回客户网站，反之则屏蔽。这样一来可站点能够保持正常的运作，仅仅处理真实用户访问网站带来的合法流量。
                    但问题在于怎样区分恶意流量和正常流量
                购买云服务器提供的ddos防护
            带宽消耗型攻击
                UDP洪水攻击（User Datagram Protocol floods）
                ICMP洪水攻击（ICMP floods）
                死亡之Ping（ping of death）
                泪滴攻击
            资源消耗型攻击
                半连接攻击(SYN攻击)
                    发生在TCP 3次握手中。如果A向B发起TCP请求，B也按照正常情况进行响应了，但是A不进行第3次握手，这就是半连接攻击。 
                全连接攻击
                    客户端仅仅“连接”到服务器，然后再也不发送任何数据，直到服务器超时处理或者耗尽服务器的处理进程。
                CC
        SQL注入
            防范方式
                对输入进行严格的转义和过滤
                使用参数化
                使用存储过程
        XSRF/CSRF
            Cross Site Request Forgery
                跨站请求伪造
                客户端请求伪造
            防范方式
                阻止不明外域的访问
                    Samesite Cookie
                        Strict
                            这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外
                            在http头里这样设置
                                Set-Cookie: foo=1; Samesite=Strict
                        lax
                            这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie
                            在http头里这样设置
                                Set-Cookie: foo=2; Samesite=Lax
                        缺点
                            不支持子域
                            浏览器支持不够友好
                                好像只有谷歌和火狐支持
                    同源检测
                        Origin
                            因为要保护隐私的原因，这个值可能不够准确
                        Referer
                            可以参考 MDN 的 Referrer Policy 的规定
                        如果http头没有这两个参数就直接拒绝掉请求 403
                        直接在地址栏里输这个地址是没有这两个参数的
                        好像只有页面接口请求时才有这两个参数
                        验证 Sec-Fetch-* 
                            这些请求头都是Forbidden header ，理论上不能在浏览器里的js修改
                            旧版浏览器不支持
                提交时要求附加本域才能获取的信息
                    每一个请求都要携带一个token (CSRF Token)
                        最好是通过计算的方式校验
                            这样能减少io
                    双重Cookie验证
                        在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。
                        在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST  域名/comment?csrfcookie=v8g9e4ksfhw）。
                        后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。
                其它
                    保证页面的幂等性，后端接口不要在GET页面中做用户操作
                    http响应头添加Header X-Content-Type-Options: nosniff
                        下面两种情况的请求将被阻止：
                        请求类型是"style" 但是 MIME 类型不是 "text/css"，
                        请求类型是"script" 但是 MIME 类型不是  JavaScript MIME 类型
                    不要直接使用用户填写的链接
                        包括但不限于
                            图片链接
                            文件下载的链接
                            其他站点的链接
        XSS/CSS
            注入一段js代码
            反射型
            存储型
            Dom 型
            防范方式
                输出进行转义
                CSP
                    Content-Security-Policy
                        内容安全策略
                    在http头或meta标签里设置csp
                    例子
                        Content-Security-Policy: default-src 'self'
                            所有内容均来自站点的同一个源 (不包括其子域名)
                        Content-Security-Policy: default-src 'self' *.trusted.com
                            允许内容来自信任的域名及其子域名
                        更多例子可以查看 mdn 的文档，可以设置图片，媒体，脚本的域名来源
                Http Only cookie
                    那么通过js脚本将无法读取到cookie信息
                    响应头设置 cookie 的例子 Set-Cookie: timeout=30; Path=/test; HttpOnly
        SSRF
            服务请求伪造
            SSRF(Server-Side Request Forgery:服务请求伪造)是一种由攻击者构造，从而让服务端发起请求的一种安全漏洞，
            它将一个可以发起网络请求的服务当作跳板来攻击其他服务，SSRF的攻击目标一般是内网。
            当服务端提供了从其他服务器获取数据的功能(如:从指定URL地址获取网页文本内容、加载指定地址的图片、下载等)，
            但是没有对目标地址做过滤与限制时就会出现SSRF。
            防范方式
                过滤返回的信息，甚至必要情况下不返回
                限制http端口，仅可使用http https
                检查IP是否为内网IP，进行黑名单过滤
                禁止不需要的协议，gopher,ftp,file协议等
        文件上传
            防范方式
                检查文件后缀
                检查文件mime，mime要和后缀对应
                上传目录外网不能直接访问
                上传目录没有执行权限
                对上传的文件进行重命名且重命名的文件名要有随机性
            一般是用来上传木马
            zip炸弹
                上传一个小的zip文件，但解压后文件非常大，解压时会消耗cpu，解压完后会消耗硬盘容量
                动态检测解压文件的大小，超过某个大小就报错
                限制压缩包里文件的数量，超过某个数量也报错
        php独有的问题
        中间人攻击
            防范方式
                https
                hsts
                禁用了不安全的SSL/TLS协议
                参数的字段里带一个mac
            更多是在客户端层面的防范
        ShellCode
        XXE
            XML External Entity
                XML 外部实体
            由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的
            利用xxe漏洞可以进行文件读取，拒绝服务攻击，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等
            防范方式
                禁用外部实体的方法
                    其实把php升级到8就可以了，php8要开启外部实体的加载其实挺麻烦的
                过滤用户提交的XML数据
                    过滤关键词：<!DOCTYPE和<!ENTITY，或者SYSTEM和PUBLIC。
                把xmllib升级到2.9.0以后的版本
                    xmllib2.9.0以后，是默认不解析外部实体的
        IDOR
        来自业务逻辑的漏洞
    防御
        ssh不要用默认端口
        安全组和防火墙不要开放全部端口，要用端口白名单
        远程数据库只开放给对应的服务器ip，本地连接用ssh代理
        nginx fpm 之类用 www 用户执行，mysql 用 mysql 用户执行
    加密算法
        加密
            对称加密
                des
                3des
                aes
            不对称加密
                rsa
        数字摘要
            sha1
            md5
    漏洞

开发php扩展
    安装必要依赖
        更新源 apt-get update
        apt-get -y install \
            curl libxml2-dev libsqlite3-dev \
            gcc make autoconf automake pkg-config
        curl 是为了下载 php 源码
        gcc make pkg-config 编译主体必须的
        autoconf 编译拓展必须的
        autoconf 依赖 automake
        除非禁用了相关编译参数，不然这两个包是必须的 libxml2-dev libsqlite3-dev
    下载源码
        curl -L -C - https://www.php.net/distributions/php-7.4.23.tar.gz -o php-7.4.23.tar.gz
        tar -xzf php-7.4.23.tar.gz
    编译
        ./configure
            如果内存小于 1g ，要加上 --disable-fileinfo
            像这样 ./configure --disable-fileinfo
        make
        make install
    配置文件
        寻找php的安装目录
            直接运行这句 php-config
            其实可以在 configure 指定安装目录的，但默认情况下可以直接加入环境变量 ./configure --prefix=/root/php-7.4.23/target
        找到 --ini-path 的位置，把配置文件复制到 --ini-path
        cp php.ini-development /usr/local/lib/php.ini
    新建扩展骨架
        进入扩展目录
        运行 php ext_skel.php --ext helloworld
        这样就能生成一个示例扩展
        编译扩展
            phpize
            ./configure --with-php-config=/usr/local/bin/php-config
                --with-php-config 的路径要填绝对路径，
                    whereis php-config
                    whcih php-config
                    php-config 一般和 php 的可执行文件在同一个目录下
            make
            make install
            默认情况下扩展是动态编译的，就是直接把编译后的 so 文件路径加入到 php.ini 就可以了
        把扩展的路径加到 php.ini
            echo "extension=/root/php-7.4.23/ext/helloworld/modules/helloworld.so" >> /usr/local/lib/php.ini
        验证扩展
            php -m | grep helloworld
            php -r "helloworld_test1();"
            php -r "helloworld_test1();echo helloworld_test2('world');echo PHP_EOL;"
        helloworld_test1 和 helloworld_test2 是扩展骨架里自带的函数，可以根据这两个示例来开发自己的扩展
    docker
        dockerfile
            FROM debian:bullseye-slim
            ARG PHP_VERSION=7.4.23
            ARG PHP_DIR=/root
            WORKDIR ${PHP_DIR}
            RUN apt-get update
            RUN apt-get install -y curl
            RUN curl -L -C - https://www.php.net/distributions/php-${PHP_VERSION}.tar.gz -o php-${PHP_VERSION}.tar.gz && tar -xzf php-${PHP_VERSION}.tar.gz
            RUN apt-get -y install \
                gcc make automake autoconf pkg-config \
                libxml2-dev libsqlite3-dev
            RUN cd php-${PHP_VERSION} && ./configure --disable-fileinfo && make && make install
        docker build -t asd/php_ext:0.1 .
        docker run -it --rm asd/php_ext:0.1 /bin/bash
composer
    composer提供了四种方式加载第三方包，分别是
        PSR-0
        PSR-4
            psr-0 和 psr-4 都是根据命名空间名从文件系统中载入类文件
        class-map
            class-map 则是直接一个 命名空间 => 文件 的数组， 加载速度会比 psr-0 和 psr-4 快
        直接包含files
            files 直接包含文件，主要是为了包含一些 公共函数
    加载流程
        vendor/autoload.php
            vendor/composer/autoload_real.php
                vendor/composer/autoload_psr4.php
                vendor/composer/autoload_classmap.php
                vendor/composer/autoload_files.php
                vendor/composer/autoload_namespaces.php
        composer dumpautoload 命令会根据 composer.json 更新这四个文件
            autoload_psr4.php -> psr-4
            autoload_classmap.php -> classmap
            autoload_files.php -> files
            autoload_namespaces.php -> psr-0
        如果更新过 composer.json 的 autoload 或 autoload-dev ，就需要运行一次 composer dumpautoload
        composer dumpautoload 的参数
            -o PSR-4/PSR-0 的规则转化为了 classmap 的规则， 因为 classmap 中包含了所有类名与类文件路径的对应关系，所以加载器不再需要到文件系统中查找文件了。
                可以从 classmap 中直接找到类文件的路径。
            -a （权威的 Authoritative）在 classmap 搜索不到就会报错， -o 当加载器找不到目标类时，仍旧会根据PSR-4/PSR-0 的规则去文件系统中查找 
            --apcu 使用 apcu 缓存
            --no-dev 不加载 autoload-dev 规则
        install 和 update 运行完之后都会运行一次 没有参数的 dumpautoload
        spl_autoload_register 这个方法就是自动加载的关键
    在项目根目录下运行这句，能归档整个项目，可以用来备份代码
        composer archive --format=zip
        composer archive --format=zip --file=archiveFileName
        归档的文件名会自动加上 .zip 的后缀
        归档的代码并不包含 vendor
        可以在 composer.json 里设置忽略的归档文件
            "archive": {
                "exclude": ["var/cache/", "tmp", "/*.test", "!/var/di/"]
            }
    给composer里的库打补丁
        下载这个库 cweagans/composer-patches
            composer require cweagans/composer-patches
        在项目的根目录里新建一个 patches 文件夹
        在 patches 文件夹里新建补丁文件
        补丁文件通常是这样子的
            --- Model/Product/Copier.php    2022-02-23 15:08:21.521148335 +0800
            +++ Model/Product/Copier.php    2022-02-23 15:07:56.013242367 +0800
            @@ -104,10 +104,7 @@ class Copier
                    $this->setDefaultUrl($product, $duplicate);
                    $this->setStoresUrl($product, $duplicate);
                    $this->optionRepository->duplicate($product, $duplicate);
            -        $product->getResource()->duplicate(
            -            $product->getData($metadata->getLinkField()),
            -            $duplicate->getData($metadata->getLinkField())
            -        );
            +
                    return $duplicate;
                }
        可以用这样的方式生成 patch 文件
            找到需要修改的文件
            复制这个需要修改的文件
            在复制的文件里修改
            用diff命令输出两份文件不一样的地方
            例子
                假设现在有一个库，名为 username/test
                这个库的根目录下有一个名为 d1.php 的文件
                    这是d1.php 的内容
                        <?php
                        echo "d1";
                    可以用这样的方式生成 d1.php
                        echo -e '<?php\necho "d1";' > d1.php
                先 cd 进这个库的根目录
                复制 d1.php
                    cp d1.php d2.php
                修改 d2.php
                    sed -i 's/echo "d1";/echo "d2";/g' d2.php
                使用 diff 对比 d1.php 和 d2.php 并把结果输出到一个文件里
                    diff -up d1.php d2.php > d1.patch
                    一个 patch 可以包含多个文件的补丁，例如这样
                        diff -up a1.php a2.php >> d1.patch
                        diff -up b1.php b2.php >> d1.patch
                打开 d1.patch ，把文件开头的 d2.php 的路径修改为和 d1.php 一样的路径
                    开头的两个文件的路径，应该是相对于库根目录的路径
                把 d1.patch 文件复制进 patches 文件夹里
            大多数linux发行版和git for windows都有 diff 这个命令
        在composer.json里加上这段
            "extra": {
                "enable-patching": true,
                "patches": {
                    "drupal/core": { // 需要补丁的库名
                        "patch1 information": "patch1 file path", // 键是补丁的描述，值是补丁的路径
                        "test patch": "patches/d1.patch"
                    },
                    "需要补丁的库名": {
                        "补丁的描述": "补丁的路径"
                    }
                }
            }
        完成上面的步骤后，再运行一次 composer install
            环境变量里需要有 patch 这个命令
            一般情况下 windwos 的 cmd 和 powershell 都没有这个命令
            但 git for windows 的 bash 里有这个命令
            所以在 windows 环境下最好用 git for windows 的 bash 来运行 composer install
        如果遇到 patch 失败的情况，可以加上 -vvv 参数参看详细的输出 composer install -vvv
        patch 给文件打补丁的命令
            一次修改一个文件
                patch 源文件 < 差异文件
                patch -d 目录 源文件 < 差异文件
            一次修改一个文件，差异文件里要包含多个文件
                patch -d 目录 < 差异文件
        cweagans/composer-patches 会按照这样的格式生成 patch 命令
            patch %s --no-backup-if-mismatch -d %s < %s
        cweagans/composer-patches 会依次尝试四条命令，只要其中一条成功，就当是打补丁成功了
            patch -p1 --no-backup-if-mismatch -d 库目录的完整路径 < 差异文件
            patch -p0 --no-backup-if-mismatch -d 库目录的完整路径 < 差异文件
            patch -p2 --no-backup-if-mismatch -d 库目录的完整路径 < 差异文件
            patch -p4 --no-backup-if-mismatch -d 库目录的完整路径 < 差异文件
            -p1 -p4 这类参数的意思是忽略差异文件里目标文件路径前面的目录
            -p0 是都不忽略 -p1 是忽略一层目录
            --no-backup-if-mismatch 这个参数的意思是不生成备份文件
        cweagans/composer-patches 生成和运行 patch 命令的文件
            vendor\cweagans\composer-patches\src\Patches.php
                postInstall
                getAndApplyPatch
        cweagans/composer-patches 生成命令的例子
            windows环境
                patch -p1 --no-backup-if-mismatch -d "C:\Users\a\magento2\vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
                patch -p0 --no-backup-if-mismatch -d "C:\Users\a\magento2\vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
                patch -p2 --no-backup-if-mismatch -d "C:\Users\a\magento2\vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
                patch -p4 --no-backup-if-mismatch -d "C:\Users\a\magento2\vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
            linux环境
                patch -p1 --no-backup-if-mismatch -d "/var/www/magento2/vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
                patch -p0 --no-backup-if-mismatch -d "/var/www/magento2/vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
                patch -p2 --no-backup-if-mismatch -d "/var/www/magento2/vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
                patch -p4 --no-backup-if-mismatch -d "/var/www/magento2/vendor/magento/module-sales-rule" < patches/composer/sales_rule.patch
        在项目根目录里运行 patch ，可以不用绝对路径，像这样
            patch -p0 --no-backup-if-mismatch -d vendor/magento/module-sales-rule < patches/composer/sales_rule.patch
            需要根据 patch 文件的内容，适当地修改 -p 参数的值
            这种命令可以直接打补丁，不需要运行 composer 的命令
        另一个补丁库 https://github.com/vaimo/composer-patches
        git diff 命令也可以生成 patch 文件
    可以通过硬改 composer.lock 里的 url 和 shasum 的 方式来安装一些需要登录的包
        先从一个已经有对应包的项目里打包
            composer archive vendor-name/component-name version --format=zip
        然后生成 shasum
        把对应的包上传到可以下载的位置
            需要 https 和 不是自签证书，也可以让 composer 允许 http
        修改 url 和 shasum
    composer.lock 里的 shasum 是 sha1
        可以用 sha1sum 或 openssl 生成
            sha1sum 文件路径
            openssl dgst -sha1 文件路径
    让 composer 允许 http 下载
        composer 安装包里的路径有 http 会安装失败
        现在的 composer 会默认 https
        需要在 composer.json 的 config 加上这样一句
            "secure-http": false,
        例如象这样
            "config": {
                "secure-http": false,
                ...
            },
最简单的 pwa
    准备两张用于图标（icons）的图片，png格式的，一张512x512，一张192x192 
    在页面的head标签里加上这三行，具体参数要按照实际情况来修改
        <link rel="manifest" href="/manifest.webmanifest">
        <meta name="theme-color" content="#fff">
        <link rel="apple-touch-icon" href="/icons8-document-512.png">
    新建一个 manifest.json 文件，并至少拥有这几个属性， icons 声明的属性要和实际的属性一致
        {
            "name": "f2h2h1's blog",
            "short_name": "f2h2h1",
            "start_url": "./index.html",
            "display": "standalone",
            "theme_color":"#fff",
            "background_color": "#fff",
            "description": "This is a blog used by a programmers to record experience",
            "prefer_related_applications": true,
            "icons": [
                {
                    "src": "icons8-document-512.png",
                    "sizes": "512x512",
                    "type":"image/png",
                    "purpose": "any maskable"
                },
                {
                    "src": "icons8-document-512.png",
                    "sizes": "192x192",
                    "type":"image/png"
                }
            ]
        }
    新建一个 sw.js 文件，并页面里注册
        if ('serviceWorker' in navigator) {
            // 在 load 事件触发后注册 Service Worker，确保 Service Worker 的注册不会影响首屏速度
            window.addEventListener('load', function () {
                // 注册 Service Worker
                navigator.serviceWorker.register('/sw.js').then(function (registration) {
                    // 注册成功
                    console.log('ServiceWorker registration successful with scope: ', registration.scope)
                }).catch(function (err) {
                    // 注册失败 :(
                    console.warn('ServiceWorker registration failed: ', err)
                })
            })
        }
    sw.js 里要监听 install activate fetch 几个事件，并且能利用 CacheStorage ，让页面离线后，仍然能通过 CacheStorage 获取数据
    sw.js 的例子
        const CACHE_NAME = "fed-cache";
        var util = {
            fetchPut: function (request, callback) {
                return fetch(request).then(response => {
                    // 跨域的资源直接return
                    if (!response || response.status !== 200 || response.type !== "basic") {
                        return response;
                    }
                    util.putCache(request, response.clone());
                    typeof callback === "function" && callback();
                    return response;
                });
            },
            putCache: function (request, resource) {
                // 后台不要缓存，preview链接也不要缓存
                if (request.method === "GET" && request.url.indexOf("wp-admin") < 0 
                    && request.url.indexOf("preview_id") < 0) {
                    caches.open(CACHE_NAME).then(cache => {
                        cache.put(request, resource);
                    });
                }
            }
        };
        this.addEventListener("install", function(event) {
            // this.skipWaiting();
            console.log("install service worker");
            // 创建和打开一个缓存库
            caches.open(CACHE_NAME);
            // 首页
            let cacheResources = [
                '/index.html',
                '/static/marked.min.js',
                '/static/cc4.0.webp',
                '/articleList.json',
                '/exchangeList.json',
            ];
            event.waitUntil(
                // 请求资源并添加到缓存里面去
                caches.open(CACHE_NAME).then(cache => {
                    cache.addAll(cacheResources);
                })
            );
        });
        // 激活
        self.addEventListener('activate', function (e) {
            // 激活的状态，这里就做一做老的缓存的清理工作
        });
        this.addEventListener("fetch", function(event) {
            event.respondWith(
                caches.match(event.request).then(response => {
                    // cache hit
                    if (response) {
                        return response;
                    }

                    return util.fetchPut(event.request.clone());
                })
            );
        });
    PWA 有三个关键的技术
        Service Worker
        Manifest （应用清单）
        应用通知 （Web Push 和 Notification Api）
    参考
        https://github.com/lavas-project/pwa-book
        https://lavas-project.github.io/pwa-book/
前端的模块化方案
    早期的解决方式
        闭包
            moduleA = function（） {
                var a,b;
                return {
                    add: function (c){
                        return a + b + c;
                    };
                }
            }()
        命名空间
            Yahoo的YUI早期的做法
            app.tools.moduleA.add = function(c){
                return app.tools.moduleA.a + c;
            }
    commonJS
        nodejs的模块规范
        不兼容浏览器
        Common不兼容浏览器的原因是缺浏览器少一些Node环境的变量，例如 module exports require global
        Node以及Webpack是采用CommonJS的形式来写的
    AMD (Asynchronous Module Definition)
        requireJS是参照AMD规范实现的
        RequireJS是一个JavaScript文件和模块加载器。它针对浏览器内使用进行了优化，但可以在其他JavaScript环境中使用
        提前执行（异步加载：依赖先执行）+延迟执行
    CMD (Common Module Definition)
        CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。
        seajs是参照UMD规范实现的，requireJS的最新的几个版本也是部分参照了UMD规范的实现
        延迟执行（运行到需加载，根据顺序执行）
    UMD (Universal Module Definition)
        兼容AMD和commonJS规范的同时，还兼容全局引用的方式
        通常能兼容浏览器或服务器环境
        无导入导出规范，只有一个常规写法
    ES6 module
在 es6 之前如何写 js 的类和模块
js 中和二进制相关的对象
    File
    Blob
        Data URL
    ArrayBuffer
    FileReader
    TypedArray
    DataView
    Buffer
js 中的任务和微任务
    https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask
    https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide
    https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth
MutationObserver？
浏览器相关的经验
    启动参数
        --no-sandbox
        --headless
        --disable-gpu
        输出 pdf ， 输出 html ，截图
        --print-to-pdf --dump-dom --screenshot
        使用默认设置，通常和 --user-data-dir 一起使用，因为第一次启动时会询问各种设置
        --profile-directory=Default
        --auto-open-devtools-for-tabs
        --user-agent=
        自定义用户数据的存储目录
        --user-data-dir=
        --disk-cache-dir=
        --app 以 app 形式启动浏览器
            --app=http://www.baidu.com
        --new-window 在一个新窗口打开
        --disable-javascript
        --proxy-pac-url
        不使用图片
        --blink-settings=imagesEnabled=false
        忽略证书错误
        --ignore-certificate-errors
        允许不安全内容
        --allow-running-insecure-content
        允许从本地主机加载的资源使用无效证书
        --allow-insecure-localhost
        允许访问本地文件，这样chrome就能通过file协议加载文件
        --allow-file-access-from-files
        允许跨域，新版的 chrome 除了 --disable-web-security 设置还需要单独设置 --user-data-dir
        --disable-web-security
        --args --disable-web-security
        --args --disable-web-security --user-data-dir=C:\MyChromeDevUserData
        --args --disable-web-security --user-data-dir=C:\MyChromeDevUserData --profile-directory=Default
    清空 dns
        edge://net-internals/#dns
        chrome://net-internals/#dns
    输入 chrome://about 命令，将集中列出 Chrome 浏览器支持的所有的命令
    命令行参数 --enable-features=msEdgeAreaSelect ，启用新版 edge 不再支持的 网页选择 功能
    火狐不显示图片
        about:config
        permissions.default.image 把这个值由 1 改成 2
    火狐输出命令行帮助
        在 git bash 里运行 firefox --help
        只有在 git bash 里有效，在 bat powershell 里都没有效果
        https://wiki.mozilla.org/Firefox/CommandLineOptions
DNS
    域名
        FQDN(fully qualified domain name 完全限定域名)
            可以简单但不严谨地理解为 带有主机名的域名
        根域
        顶级域 TLD
        二级域 2LD
        三级域 3LD
        主机名
    DNS系统可以分为三层
        根 DNS 服务器
        顶级域 DNS 服务器
        权威域名服务器
    查询的流程
        迭代查询
        递归查询
    dns 客户端和服务器类型
        dns 客户端
        权威DNS
        递归DNS
        转发DNS
    请求报文 和 响应报文
        DNS报文格式，不论是请求报文还是DNS服务器返回的应答报文，都使用统一的格式
        Header 报文头
        Question 查询的问题
        Answer 应答
        Authority 授权应答
        Additional 附加信息
    domain 和 zone
        对应的翻译
            域名 domain name
            域 domain
            区域 zone
        domain 这个比较容易理解
            就是直接用域名来区分
            例如
                com 是一个域
                cloudflare.com 是一个域
                www.cloudflare.com 是一个域
                cloudflare.com 是 com 的子域
                www.cloudflare.com 是 cloudflare.com 的子域
        zone 比较难理解，起码不能直接通过域名区分
        domain 是以域名进行分界的，而 zone 是以授权范围来定界的。
            例子
                com 是一个 zone
                cloudflare.com 是一个 zone
                blog.cloudflare.com 是一个 zone
                cloudflare.com 由 com 授权
                blog.cloudflare.com 由 cloudflare.com 授权
                community.cloudflare.com 和 sopport.cloudflare.com 则不是一个 zone
                community.cloudflare.com 和 sopport.cloudflare.com 包含在 cloudflare.com 里
            参考 https://www.cloudflare.com/zh-cn/learning/dns/glossary/dns-zone/
    EDNS
    DNSSEC
    BIND
        BIND（Berkeley Internet Name Domain）是现今互联网上最常使用的DNS软件
        bind-utils
            host
            nslookup (name server lookup)
            dig (Domain Information Groper)
            bind
    DNSCrypt
    DoH 和 DoT
    powershell 的 Resolve-DnsName
    dns服务
        由isp提供的
        公共的
        自建的
    相关的 rfc
        1034
        1035
        2606
        7871
        8484 DoH
        2065 DNSSEC
        2535 DNSSEC
        3225 DNSSEC
        4033 DNSSEC
        4034 DNSSEC
        4035 DNSSEC
        2671 EDNS
        2673 EDNS
        6891 EDNS
        3490 IDNA
        4431 DLV DNSSEC
IT领域战争
    编辑器之战
        vim emacs
        笔者认为，在 gui 上是 vscode 取得了最后的胜利
        emace 的生态位似乎在被 vscode 侵占，看来还是 vim 笑到最后
    浏览器大战
    unix战争
    操作系统内核之争
        宏内核 和 微内核
    编程语言之争
    代码风格之战
        缩进
            空格和制表
            长度
                2 4 8
        右括号是否换行
        一行代码多少个字符
    协议战争
        tcp/ip 和 osi
    指令集？
        精简 和 复杂
    从结果上看，
        开源 战胜 闭源
        工程 战胜 学院
linux 中的各种 id
    用户ID (UID, User ID)
    父进程ID (PPID, Parent Process ID)
    进程ID (PID, Process ID)
    会话期ID (SID, Session ID)
        创建session的场景有两个：
            （1）一次登录会形成一个session（login session）。
            （2）系统的daemon进程会在各自的session中（daemon session）。
        无论哪一个场景，都是通过setsid函数建立一个新的session
    控制终端 (TT, TTY)
        ? 是没有控制终端
    进程组ID (PGID, Process Group ID)
        进程组（process group）也是一组进程的集合，进程组id就是这个进程组中leader的进程ID
        对大部分进程来说，它自己就是进程组的leader，并且进程组里面就只有它自己一个进程
        shell里面执行类似 ls|more 这样的以管道连接起来的命令时，两个进程就属于同一个进程组，ls是进程组的leader。
        shell里面启动一个进程后，一般都会将该进程放到一个单独的进程组，然后该进程fork的所有进程都会属于该进程组，
        比如多进程的程序，它的所有进程都会属于同一个进程组，当在shell里面按下CTRL+C时，该程序的所有进程都会收到SIGINT而退出。
    终端进程组ID (TPGID, TTY Process Group ID)
        TPGID == 在前台的进程组ID
        如果一个进程属于后台进程组 ，那么 TPGID 为 -1
        通过 TPGID 来判断一个进程是属于前台进程组，还是后台进程组
        TTY Process Group ID 的作用是用来控制终端设备的输入和输出，以及发送信号给相应的进程组。
        例如，当我们在终端上按下 Ctrl-C 时，就会发送一个 SIGINT 信号给当前的 TTY Process Group
    SPID System Process ID
        多数情况下就是 pid
    上面几个id都可以用这个命令查看 `ps axj -T`
        a: 显示所有
        x: 显示没有控制终端的进程
        j: 显示与作业有关的信息(显示的列): 包括会话期ID(SID), 进程组ID(PGID), 控制终端(TTY)和终端进程组ID(TPGID)
        T: 显示每个进程的线程信息，包括 SPID（线程ID）和 NLWP（线程数）等字段
    jobid ，用命令查看 jobs -l
        进程和作业的区别也不是很理解，但在实践的过程中 一个作业（job）等同于一个进程组
        jobid 其实是按当前的 job 来算的
        假设当前没有 job 那么新建一个 job 那么这个 job 的 jobid 就是 1
        然后再新建的 job 的 jobid 就是 2
        当 1 结束时，但 2 未结束，又新建了 job 那么新建的 job 的 jobid 就是 3
        如果 2 和 3 都结束了，再新建一个 job 那么这个新建的 job 的 jobid 就是 1
        kill 命令也可以用 jobid
            kill %1
            kill jobid 为 1 的 job
串行 并行 并发
    串行 依照顺序一次只执行一个任务
    并发 多个任务交替执行，因为交替的速度非常快，从人的主观感受看，这些任务也是同时执行
    并行 多个任务同时执行
    并发 和 并行 不是互斥的概念，往往都会同时存在
        例如 一个超级简化的例子
            cpu 有两个逻辑核心，然后当前运行的进程有四个线程，那么这四个线程看起来是并发的，
            然后又因为 cpu 有两个逻辑核心，所以同一时刻可以有两个线程运行，所以有两个线程并行
    多核cpu，超线程，逻辑核心，还有多个cpu的主机
    并行计算（parallel computing）
    并发计算（concurrent computing）
    分布式计算（distributed computing）
    并发模型
        并发模型往往会依赖
            io模型
            多进程 和 多线程 和 协程
            锁
            中断
        基于消息传递
            actor
            CSP
        io复用
            Reactor
            Proactor
        线程池
            Half-Sync/Half-Async HSHA
            Leader-Follower LF
        事件驱动
            libhv
            libevent
            libev
            libuv
    并行模型
        并行模型也有不少，但笔者工作时基本遇不到，所以就先不记录了
    异步 规范 Promises/A+ https://promisesaplus.com/
多进程 和 多线程 和 协程
    多进程讲究的是进程间通讯
    多线程讲究的是数据的一致性（多个线程操作同一个变量时不要有冲突）
        通常是通过锁来实现的
    多进程 和 多线程 是通过 中断 来实现的
    为什么进程的开销比线程大？
    为什么线程的开销比协程大？
    协程
        无栈协程
            生成器
        有栈协程
io 模型
    五种模型
        阻塞
            最传统的io
        非阻塞
            通过 fnctl 把 fd 加上非阻塞的 flg ，read 没完成是就会返回 EAGAIN 或 EWOULDBLOCK
            这似乎只有 linux 才有的特性
        信号驱动io
            信号驱动io 是 边缘触发
        io复用
            select poll epoll
            select 和 poll 是水平触发
            epoll 可以支持 水平触发 和 边缘触发
            虽然 epoll 被归类在 io多路复用 ，但我认为 epoll 更像是 poll 和 信号驱动io 的合体
        异步io
            异步io 更严谨的描述应该是 信号驱动的异步io
            信号驱动io和异步io都需要通过信号来接收内核的通知
            信号驱动io接收到通知后，依然需要通过系统调用把数据从内核复制到用户态
            异步io收到通知后，数据就已经在用户态了，内核已经把数据复制到用户态
    两种分类
        一个IO操作其实分成了两个步骤
            发起IO请求		向 cpu 发起 io 请求
            处理IO请求		把数据复制进用户态的内存
        阻塞和非阻塞
            如果 发起IO请求 是 阻塞的，就是 阻塞
            如果 发起IO请求 是 非阻塞的，就是 非阻塞
            所以，除了 阻塞io 之外，其它的都是非阻塞io
        同步和异步
            如果 处理IO请求 是 阻塞的，就是 同步
            如果 处理IO请求 是 非阻塞的，就是 异步
            所以，除了 异步io 之外，其它的都是同步io
锁（lock）
    锁的目的是避免数据的争用，避免脏数据的产生，保证数据的一致性
    原理
        原子操作 (atomic operation)
            不可中断的一个或一系列操作
            CAS 指令 Compare And Swap 指令 比较与交换
            TAS 指令 Test-And-Set 指令 测试与设置
            DCAS double-length CAS
            TTAS Test and test-and-set
            FFA Fetch-and-add
        竞争条件 (race condition)
        临界区 (critical region)
    理论上的锁
        乐观锁 (Optimistic Lock)
            先假设冲突不会发生，修改完数据后再判断是否有冲突
        悲观锁 (Pessimistic Lock)
            假设冲突会发生，先获得锁再修改数据
        劝告锁 (advisory lock)
            不是强制的锁
        强制锁 (mandatory lock)
            强制的锁
        死锁 (Deadlock)
    实现上的锁
        文件锁
            从写代码的角度来看，就是各种系统调用
        mysql锁
            死锁
        redis锁
    分布式锁
信号量 (semaphore)
管程 (monitors)
事务 (transaction)
中断和异常
    异常是一种中断
    现在的中断，大多最后都是 cpu 中的 apic
    软中断(softirq)和硬中断(hardirq)
    irq interrupt request 中断请求
    Kernel signal 内核信号
    system call 系统调用
    signal 信号
    interrupt 中断
    exception 异常
    traps 陷阱
CPU的工作模式
    CPU的工作模式是指CPU的寻址方式、寄存器大小等用来反应CPU在该环境下如何工作的概念。
    现代计算机只有在开机时CPU工作在实模式，而后的一切工作都是在保护模式下进行
    实模式
        实模式的“实”更多地体现在其地址是真实的物理地址
        实模式是不安全的，程序可以随意访问任何物理地址
        实模式是相对于保护模式而言的，在保护模式出现之前并没有实模式这样的称呼
    保护模式
        特权级别（Privilege Level）
            ring0 - ring3
        4个特权级 ring0 - ring3 是在保护模式下的
        0为最高特权级，为内核代码所运行级别，
        3为最低特权级，为用户程序所运行级别。
        1 和 2 是系统程序
        驱动一般也是运行在 1 和 2 ，但也可以运行在 0
        ring3 是用户态
        ring0 - 2 都可以算是内核态
        4个特权级是来自 x86 的概念， arm 里只有内核态和用户态
        对于一个写上层应用的程序员而言，绝大多数情况下只需要考虑 0 和 3
        CPU处于不同的特权级，它能访问的计算机资源范围不同，
        计算机资源包括内存段（代码段，数据段，栈段）,IO设备，核心数据结构。
        GDT 是在保护模式下一个重要的数据结构。
            Global Descriptor Table
            全局描述表
            特权级 和 GDT 密切相关
    长模式
        长模式可以简单但不严谨地理解为 运行在64位cpu上的保护模式
    实模式 和 保护模式 下的中断过程是不一样的
系统调用的本质是什么？
    系统调用 是应用程序和系统的接口，系统调用是操作系统提供的api
    现代cpu通常有多种特权级别，一般来说特权级总共有4个，编号从Ring 0（最高特权）到Ring 3（最低特权）
        在Linux上只用到Ring 0和RIng 3，用户态对应Ring 3，内核态对应Ring 0。
        一般的程序运行在用户态
        系统调用是运行在内核态的
    在没有保护模式之前的系统调用是怎样的？
        保护模式从 80286 就开始有了，
        80286 是 16 位 cpu
        linux 其实是从 80386 开始的
        80386 是 x86 的第一款 32 位 cpu
        好像直到 2012 年 linux 才停止支持 80386
ELF格式
    Executable and Linking Format
    可执行和可链接的格式
    ELF UNIX类操作系统中普遍采用的目标文件格式 
    目标文件有四种类型：
        1. 可重定位文件（Relocatable File）
        2. 可执行文件（Executable File）
        3. 共享目标文件（Shared Object File）
        4. 内核转储（core dumps）
    ELF文件格式提供了两种视图
        链接视图
            以节（section）为单位
            链接时用到的视图
            大致组成
                ELF头部 (ELF header)
                程序头部表 (Program header table)
                节区1 节区2 节区3 ... 节区n
                节区头部表 (Section header table)
        执行视图
            以段（segment）为单位
            执行时用到的视图
            大致组成
                ELF头部 (ELF header)
                程序头部表 (Program header table)
                段1 段2 段3 ... 段n
                    栈 和 堆 都在 .data 里
                节区头部表 (Section header table) 名称和链接视图的一样
        内存映射
            链接视图 到 执行视图 的映射
            执行视图 约等于 内存布局 约等于 内存寻址模型
    静态链接
    动态链接
    可执行文件的装载
        程序（可执行文件）和进程的区别
            程序是静态的概念，它就是躺在磁盘里的一个文件。
            进程是动态的概念，是动态运行起来的程序。
        现代操作系统如何装载可执行文件
            给进程分配独立的虚拟地址空间
            将可执行文件映射到进程的虚拟地址空间（mmap）
            将CPU指令寄存器设置到程序的入口地址，开始执行
    源码 -> 编译器 -> elf文件
    elf文件格式->elf可执行文件的装载->程序运行时的内存布局
    查看文件格式 `file 文件路径`
    查看 elf 文件类型 `readelf -h 文件路径`
    32位和64位的格式会有一些差异
acme
    ACME
        Automatic Certificate Management Environment
        自动 证书 管理 环境
    ACME 的 rfc
        rfc8555
    下载和安装
        acme.sh的GitHub仓库
            https://github.com/acmesh-official/acme.sh
        acme.sh 的中文说明
            https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E
            https://github.com/acmesh-official/acme.sh/wiki/Blogs-and-tutorials#%E4%B8%AD%E6%96%87
        直接下载安装
            curl https://get.acme.sh | sh -s email=my@example.com
        从源码安装
            git clone --depth 1 https://github.com/acmesh-official/acme.sh.git
            cd acme.sh
            ./acme.sh --install -m my@example.com
        安装完后把 .acme.sh 文件夹复制到用户的根目录下，类似这样 /root/.acme.sh/
        创建一个别名
            在 ~/.bashrc 加入这一行
                alias acme.sh=~/.acme.sh/acme.sh
            然后再运行这句 source ~/.bashrc
            如果没有 ~/.bashrc ，就新建一个 touch ~/.bashrc
        其实把安装后的目录复制到根目录和创建别名都不是必须的，但为了贴合文档的教程和方便使用，最好还是这样做
    申请证书
        运行这句命令，http服务需要已经启用，并且是监听 80 端口的
        这句命令运行后会输出证书生成的位置
            acme.sh --issue -d example.com -d www.example.com --webroot /home/wwwroot/example.com/
        acme.sh 临时运行一个 webserver, 临时听在80 端口，这是使用 socat 实现的，所以要先安装好 socat
            acme.sh --issue -d example.com -d www.example.com --webroot /home/wwwroot/example.com/ --standalone
    安装证书
        acme.sh --install-cert -d www.example.com \
            --cert-file      /c/nginx/crt/www.example.com/cert.pem  \
            --key-file       /c/nginx/crt/www.example.com/blog.complexcloud.site.key \
            --fullchain-file /c/nginx/crt/www.example.com/fullchain.cer \
            --reloadcmd     "service nginx force-reload"
        安装证书后 --reloadcmd 不能修改，要修改 --reloadcmd 命令，就重新安装一次证书，直接改配置文件也是可以的，但文档里不推荐这样做
        其实安装证书这步不是必须的，可以自己手动把证书复制到 nginx 对应的目录里，但没有安装证书这一步就不能自动续签
    自动续签证书
        一般的命令
            ./acme.sh/acme.sh --cron --home "/root/.acme.sh" > /dev/null
        写成 cron 表达式
            0 2 * * * /bin/bash /root/.acme.sh --cron --home "/root/.acme.sh" > /dev/null
    其它命令
        查看全部证书
            acme.sh --list
        产看全部证书，包括已过的
            acme.sh --list-archive
        查看已安装证书的信息
            acme.sh --info -d www.example.com
        更新
            acme.sh --upgrade
        开启自动更新
            acme.sh --upgrade --auto-upgrade
        关闭自动更新
            acme.sh --upgrade --auto-upgrade 0
    在 windows 里使用
        https://github.com/acmesh-official/acme.sh/wiki#4-how-to-run-on-windows-with-cygwin-or-git-bash
        先安装好 cygwin 环境，其实装好 git for windows 就可以了
        然后和 linux 的步骤基本一致
        需要注意
            路径都要写成 linux 的格式，例如 网站根目录 ， 证书安装路径 这些
                类似这样的 /c/nginx/crt/www.example.com/cert.pem
            安装证书时的 reloadcmd 命令
            自读续签证书的定时任务可以使用 windows 计划任务，但这样的写法，任务运行时会有一个黑框弹出来（我用了很多方法依然无法隐藏这个黑框，在服务器里每晚运行一次的话应该没关系的吧，即使有黑框也是一闪而过）
                Register-ScheduledTask -TaskName "acme_cron" -AsJob -Trigger (New-ScheduledTaskTrigger -Daily -At "2:00 AM") -Action (New-ScheduledTaskAction -Execute "PowerShell" -Argument "-Nolog -NonInteractive -WindowStyle Hidden -Command `"C:\Users\a\Git\usr\bin\bash.exe -l /c/Users/a/.acme.sh/acme.sh --cron --home /c/Users/a/.acme.sh`"")
定时任务
    cron
        安装
            centos
                yum install vixie-cron crontabs
            debian
                apt-get install cron
            大多数发行版都会自带 cron
        cron 通常分为三部分
            crond 是 cron 在系统内的守护进程，
            crontab 是管理 cron 任务的工具
            配置文件
                配置文件的位置？
        cron 表达式
            * * * * *
            分 时 日 月 星期
            特别的
                @yearly 0 0 1 1 * 每年运行一次
                @monthly 0 0 1 * * 每月运行一次
                @weekly 0 0 * * 0 每星期运行一次
                @daily 0 0 * * * 每日运行一次
                @hourly 0 * * * * 每小时运行一次
                        * * * * * 每分钟运行一次 这个就没有特殊的名称了
                @reboot
                    将作业配置为在守护程序启动时运行一次。
                    由于 cron 通常永远不会重新启动，因此这通常用于系统启动时运行的任务
        常用的命令
            crontab -l
            crontab -e
                和直接修改配置文件相比
                crontab -e 在退出时会检测一次语法
        cron 的实现
            vixie cron
                这个应该是现在最流行的 cron 版本了
                https://github.com/vixie/cron
            busybox 版的 cron
                https://github.com/mirror/busybox/blob/HEAD/miscutils/crond.c
                https://github.com/mirror/busybox/blob/HEAD/miscutils/crontab.c
            其他流行的实现包括 anacron dcron mcron cronie
            cron 的实现要比想象中的简单不少
            对于大多数发行版的 cron 而言
                cron 是无状态的，
                cron 在代码里写死了60秒扫描一次配置文件，
                    为什么cron没有秒级的任务？
                        因为代码里写死了60秒扫描一次配置文件
                    为什么是60秒？
                        大概可能因为是 祖宗之法不可变 吧
                扫描配置文件时，遇到符合规则的任务就会运行，
                对于单个任务的状态， cron 是不会判断的，不判断上次任务的成功或失败，不判断上次任务运行的时间
        使用bash脚本实现的隔秒运行和单例运行
            隔秒运行
                * * * * * cron.sh
                #!/bin/bash
                step=1 #间隔的秒数，不能大于60
                for (( i = 0; i < 60; i=(i+step) )); do
                    $(php test.php)
                    sleep $step
                done
                exit 0
            单例运行
                要使用文件锁确保当前只有一个脚本在运行
                flock命令
                    例子1
                    ```
                    #!/usr/bin/env bash
                    LOCK_FILE=/var/lock/test.lock
                    exec 99>"$LOCK_FILE"
                    flock -n 99
                    if [ "$?" != 0 ]; then
                        echo "$0 already running"
                        exit 1
                    fi
                    #脚本要做的其他事情
                    ```
                    例子2
                    ```
                    #!/usr/bin/env bash
                    [ "${FLOCKER}" != "$0" ] && exec env FLOCKER="$0" flock -en  "$0"  "$0"  "$@" || :
                    # 如果${FLOCKER}环境变量没有设置，则尝试将脚本本身加锁，如果加锁成功，则运行当前脚本，（并且带上原有的参数），否则的话静默退出。
                    #脚本要做的其他事情
                    ```
        其实现在的 cron 也是通过 systemd 运行的
            crond.service
            systemctl status crond.service
    systemd 的 timer
        创建一个 service
            /usr/lib/systemd/system/MyTimer.service
                [Unit]
                Description=MyTimer

                [Service]
                ExecStart=/bin/bash /path/to/MyTimer.sh
            可以像这样运行一次测试是否有生效
                systemctl start MyTimer.service
        然后创建一个 timer
            /usr/lib/systemd/system/MyTimer.timer
                [Unit]
                Description=Runs mytimer every hour

                [Timer]
                # 定时器
                OnUnitActiveSec=1h
                # 定时器触发的任务
                Unit=mytimer.service

                [Install]
                # 开机启动时的依赖项，大多数情况下都是填这个
                WantedBy=multi-user.target
            定时器的写法可以参考文档
                https://www.freedesktop.org/software/systemd/man/systemd.time.html
        最后把 timer 加入到开机启动中
            systemctl enable MyTimer.timer
        定时器的相关命令
            列出所有定时器
                systemctl list-timers
            systemctl 的命令也能直接用在 定时器中
                start stop status enable disable
            查看所有单元
                systemctl list-unit-files
            查看所有 Service 单元
                systemctl list-unit-files --type service
            查看所有 Timer 单元
                systemctl list-unit-files --type timer
        systemed 的 timer 可以实现 秒级 任务，但 crond 不可以
        systemed 的 timer 比 crond 的灵活很多，基本接近 windows 的计划任务了
    在 linux 下的一次性任务用 at 和 atq 命令
    windows 的 计划任务 包括了 开机启动 和 定时任务
        以前用 at 命令操作
        现在用 schtasks 命令操作
        当然啦，用图形界面也是可以的
            taskschd.msc
            https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/schtasks
            https://learn.microsoft.com/zh-cn/windows/win32/taskschd/task-scheduler-start-page
            https://learn.microsoft.com/zh-cn/windows/win32/taskschd/using-the-task-scheduler
        schtasks
            查询任务
                schtasks /Query
                schtasks /Query /TN "\Microsoft\Windows\WwanSvc\NotificationTask"
                schtasks /Query /V /TN "\Microsoft\Windows\WwanSvc\NotificationTask"
            删除任务
                schtasks /Delete /TN taskname /F
                taskname 是任务名
                /F 是强制执行
            创建任务
                schtasks /Create /TN taskname /TR taskrun
                定时任务的表达式有一点混乱，最好还是去看文档
                    每分钟运行一次
                        schtasks /create /sc minute /mo 1 /tn "task name" /tr "command"
                    开机启动，设置开机启动的任务需要管理员权限
                        schtasks /create /sc ONSTART /tn "task name onstart" /tr "command"
        用 powershell 的 cmdlets 也能创建 windows 的定时任务
            https://learn.microsoft.com/en-us/powershell/module/scheduledtasks
            https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/new-timespan
        使用 powershell 创建定时任务
            这是分开创建的，分开创建可以使用多个触发器
                $Act1 = New-ScheduledTaskAction -Execute "command";
                $Time = New-ScheduledTaskTrigger -Once -At (Get-Date)  -RepetitionInterval (New-TimeSpan -Minutes 1) ;
                Register-ScheduledTask -TaskName "SoftwareScan" -Trigger $Time -Action $Act1;
            这是合成一条命令
                每分钟运行一次
                Register-ScheduledTask -TaskName "SoftwareScan" -Trigger (New-ScheduledTaskTrigger -Once -At (Get-Date)  -RepetitionInterval (New-TimeSpan -Minutes 1)) -Action (New-ScheduledTaskAction -Execute "command");
                开机启动
                Register-ScheduledTask -TaskName "SoftwareScan" -Trigger (New-ScheduledTaskTrigger -AtStartup) -Action (New-ScheduledTaskAction -Execute "command");
            使用多个触发器的例子
                每天11:00和23:00运行一次
                $Act1 = New-ScheduledTaskAction -Execute "command";
                $Time1 = New-ScheduledTaskTrigger -Daily -At 11am;
                $Time2 = New-ScheduledTaskTrigger -Daily -At 11pm;
                Register-ScheduledTask -TaskName "SoftwareScan2" -Trigger ($Time1, $Time2) -Action $Act1;
        计划任务一个触发器只能设定一个时间，但一个任务可以有多个触发器，schtasks命令只能设置一个触发器
        如果计划任务运行的是 bat 或 ps 或 bash 脚本，任务运行时会弹出一个黑框
            如果要隐藏黑框，需要以管理员权限生成任务，或者用 vbs 的方式调用脚本，但vbs的方式很容易被杀毒软件拦截
                schtasks /create /sc minute /mo 1 /ru System /tn "acme_cron" /tr "command"
                Register-ScheduledTask -User System -TaskName "SoftwareScan" -Trigger (New-ScheduledTaskTrigger -Once -At (Get-Date)  -RepetitionInterval (New-TimeSpan -Minutes 1)) -Action (New-ScheduledTaskAction -Execute "command");
        通过 xml 文件你创建计划任务
             Register-ScheduledTask -Xml test.xml -TaskName "task name"
             schtasks /create /xml test.xml /tn "task name"
            xml 的具体语法
                https://learn.microsoft.com/zh-cn/windows/win32/taskschd/task-scheduler-schema
            通过 xml 创建的计划任务能实现多个触发器，和 gui 的功能基本一致了
    在 windows 下如何运行 cron ？
        关键是要能每分钟扫描一次 cron 的配置文件，然后执行符合规则的任务
            有一个能每分钟运行一次或持续运行的程序用来扫描 cron 的配置文件
                直接运行一个命令行，然后不关闭窗口
                让程序以服务的形式运行
                    可以直接在代码里写好
                    也可以用 nssm 或 winsw 这类工具把普通的程序封装成服务
                使用 计划任务 ，每分钟运行一次
            能解释 cron 表达式
                这种库在 github 十分的多，而且各种语言实现的都有，但怎样实现 @reboot ?
                        https://github.com/dragonmantank/cron-expression tag
                        https://github.com/peppeocchi/php-cron-scheduler
                    如果是 一直运行的命令行 或 服务 的形式
                        就一开始启动时运行一次，以后就忽略
                    如果是 计划任务 ，每分钟运行一次
                        通过 系统启动时间 或 系统运行时长 来判断是否需要运行 @reboot
                            wmic path Win32_OperatingSystem get LastBootUpTime
                            (get-date) - (gcim Win32_OperatingSystem).LastBootUpTime
                            (Get-Date (Get-CimInstance -ClassName win32_operatingsystem).LastBootUpTime -UFormat %s).ToString() // 开机时间的10位时间戳
                            锁定 注销 睡眠 休眠 都 不会计入停机时间
    mysql 的 事件调度器(Event Scheduler) 和 PostgreSQL 的 PgAgent 也能实现定时任务
    除了 crod 和 window 的计划任务之外，还有哪些好用的定时任务或计划任务工具？
    计划任务 schedule job
        触发器
            基于时间的
            基于事件的
                系统状态
                    开机/关机
                    用户登入/用户登出
                自定义事件
                    web hook 这类的
        任务
        任务监控
            记录任务的状态
                是否有出错，出错是否有错误的记录？
                运行开始时间
                运行时长
                运行结束时间
            失败后重试？
            任务超时后强制关闭？
            任务的miss？
            失败后的日志和通知？
        分布式的任务？distributed schedule job
MySQL 和 PostgreSQL
    比较 MySQL 和 PostgreSQL
        pg 和 mysql 在语法有一些差异
        mysql 可以使用多种存储引擎
        mysql 在集群上有更成熟的方案
        pg 更倾向于 OLAP 在 OLTP 的性能上可能追不上 mysql
        但因为 pg 的软件协议更加宽松，使得我在情感上更加倾向于 pg
        或许 MariaDB 是相对折中和务实的选择
    MySQL 为什么比 PostgreSQL 流行
        pg 早期版本不支持 windows
        lamp 的流行，还有 WordPress 这类博客
        阿里的去 ioe 使 mysql 更流行
        pg 的中文用户组到 2011 年才组建起来
        pg 的集群没有MySQL简单
        pg 的高级特性，互联网公司用不到
        据说 PostgreSQL 正在逐步超越 MySQL
    mysql 全家桶
        文档型数据
            用json类型的字段存储
        搜索
            用全文索引
        缓存
            用内存表
        定时任务
            用事件调度器(Event Scheduler)
        队列
            也是用内存表，其实不用内存表也可以
    PostgreSQL 全家桶
        文档型数据
            用这几种类型 json jsonb xml hstore
        全文搜索
            本来就支持，tsvector和tsquery 类型，gin索引
            中文的全文搜索和mysql一样要装插件
        缓存
            pg 中没有类似于 mysql 的内存表
            使用RAM Disk。创建一个表空间到Ram Disk上，然后建表的时候指定表空间到该 Ram Disk
            unlogged table
        定时任务
            pg_cron 扩展 或 PgAgent 扩展
        队列
            使用 PostgreSQL 的 listen/notify 机制 或 queue_classic 扩展
        pg 的扩展机制，使得 pg 的功能可以一直扩展
            时序数据库
            图数据库
            空间数据(gis)
openbsd-inetd
    ```
    # 拉取镜像
    docker pull debian:11
    # 运行容器
    docker run \
        -it \
        --rm \
        debian:11 /bin/bash
    # debian11 换成阿里云的源
    cp /etc/apt/sources.list /etc/apt/sources.list_bak && \
    sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list && \
    apt update
    # 安装必要的软件
    apt install -y vim && \
    apt install -y net-tools && \
    apt install -y netcat && \
    apt install -y openbsd-inetd && \
    apt install -y procps
    # 修改 inetd 的配置，启用相关的协议
    vim /etc/inetd.conf
        echo       stream  tcp     nowait  root    internal
        daytime    stream  tcp     nowait  root    internal
        time       stream  tcp     nowait  root    internal
        discard    stream  tcp     nowait  root    internal
        chargen    stream  tcp     nowait  root    internal
    # 启动 inetd
    /etc/init.d/openbsd-inetd start
    # 查看 inetd 的状态
    /etc/init.d/openbsd-inetd status
    # 查看当前系统端口的占用情况
    netstat -l
    netstat -a
    # 使用 nc 验证五个协议
    nc 127.0.0.1 7
    nc 127.0.0.1 9
    nc 127.0.0.1 19
    nc 127.0.0.1 13
    nc 127.0.0.1 37
    # RFC 868 输出的是二进制数据，需要经过转换才可读
    # 转换为 10 位时间戳
    nc 127.0.0.1 37 | od -t u4 --read-bytes=4 --endian=big --address-radix=n | awk '{print ($1-2209017600)}'
    # 转换为时间字符串
    nc 127.0.0.1 37 | od -t u4 --read-bytes=4 --endian=big --address-radix=n | awk '{print ($1-2209017600)}' | xargs -I{} date --date='TZ="Asia/Shanghai"' -d "@{}" +%FT%H:%M:%S%:z
    # 修改完 /etc/inetd.conf 文件后，需要重启 openbsd-inetd 服务
    /etc/init.d/openbsd-inetd restart
    ```
    inetd（internet daemon）
    感觉 inetd 就像是守护进程版的 nc
    和 nc 一样只处理连接，然后把socket的输入和输出重定向到标准输入和标准输出
nc netcat ncat socat
    nc 和 netcat 都是一样的
        nc 有两种实现
            GNU 版本，一般系统自带
            openbsd 版本
        GNU 版本的包名通常为 nc-traditional netcat-traditional
            https://snapshot.debian.org/package/netcat/
        openbsd 版本的包名通常为 nc-openbsd netcat-openbsd
            https://github.com/openbsd/src/blob/master/usr.bin/nc
        判断当前系统的 nc 版本
            先用 type nc
            再用 realpath 或 ls -l 查看 nc 的真实路径，最好用 realpath
            类似这样 realpath /bin/nc
    ncat 是 nmap 项目的组成部分。
        https://nmap.org/ncat/
        Nmap (“Network Mapper(网络映射器)”) 
        Nmap（“网络映射器”）是一个免费的开源实用程序，用于 网络发现和安全审核。
        除了经典的命令行 Nmap 可执行文件之外，Nmap 套件包括
        高级 GUI 和结果查看器 （Zenmap），一个灵活的数据 传输、重定向和调试工具 （Ncat），一个实用程序 比较扫描结果 （Ndiff） 和数据包生成和响应分析工具 （Nping）
        ncat 支持 tls
        ncat 的包名通常是 ncat nmap-ncat
        https://github.com/nmap/nmap/tree/master/ncat
    socat 是一个 nc 的替代品，可以称为 nc++。是 netcat 的 N 倍 加强版。
        socat 的官方文档描述它是 "netcat++" (extended design, new implementation)
        socat 的包名就是 socat
        socat 是 socket cat 的缩写
        http://www.dest-unreach.org/socat/
    BusyBox 里也有一个轻量版的 nc ，同样地 toybox 里也有一个 nc
        https://github.com/mirror/busybox/blob/master/networking/nc.c
    除此之外，还有一个 cryptcat
        cryptcat 是 netcat 的变体，基本上就是多了一个 密码 的参数
        cryptcat 好像是来自 kali linux
    从功能上看
        BusyBox nc < nc-traditional < nc-openbsd < ncat < socat
    nc 的原理是什么？
        只处理连接
        socket一部分参数可以通过命令行传入，例如 -w -u 这类
        把socket的输入和输出重定向到标准输入和标准输出
    有哪些通用的语法？
        似乎除了 -l 之外，其它参数都有变动
        最稳妥的方式还是通过 -h 来查看帮助
    这里有描述如何用 ncat 实现最简单的五个协议
        https://nmap.org/ncat/guide/ncat-simple-services.html
    echo
        while read -r line; do echo "$line"; done
        echo 123 | while read -r line; do echo "$line"; done
        echo -e "123\n321" | while read -r line; do echo "$line"; done
        nc -l -k -p 9901 -e "cat $@"
    daytime
        date -u "+%d %b %y %k:%M:%S %z"
        date -u --rfc-2822
        date -u --rfc-3339="seconds"
        date -u --iso-8601="seconds"
    time
        date +%s | awk '{printf "%#x", $1+2209017600}' | xxd -r
    discard
        while read -r line; do echo "$line" > /dev/null; done
    chargen
        lineLimit=72;offset=0;count=0;while true; do for ((i=0; i<$lineLimit; i++)); do tag=$((($i + $offset) % 95)); printf "\x$(printf %x $(($tag + 32)))"; done; offset=$(($offset + 1)); if [ $offset -ge 95 ]; then offset=0; fi; printf "\n";count=$(($count + 1)); done;
    nc 扫描端口
        nc -v -i 1 127.0.0.1 801
        nc -v -z -i 1 127.0.0.1 801
        nc -v -z -i 1 127.0.0.1 800-900
        不是所有版本的nc都支持 z 参数，不是所有版本的 nc 支持批量端口扫描
    nc 实现聊天
        最简单的一对一
            nc -l 801
            nc 127.0.0.1 801
    nc 传输文件
        接收端先运行一个 nc
            nc -l 801 > output.txt
        发送端再运行一个 nc
            nc 127.0.0.1 801 < input.txt
    nc 实现一个转发服务
        nc 自己调用自己
        nc -v -l -k -p 9901 -e "nc 127.0.0.1 9902"
        nc -v -l -k -p 9901 -e "bash -c \"nc 127.0.0.1 9902\""
        mkfifo pipe1;cat pipe1 | nc -v -l -p 9901 | /bin/bash -c "nc 127.0.0.1 9902" 2>&1 1>pipe1;
    nc 实现远程 shell
        远程 shell
            nc -v -l -p 9901 -e "bash"
        控制端
            nc -v 127.0.0.1 9901
        即使没有 -e 参数，也能通过管道实现各种奇技淫巧，虽然管道的奇技淫巧只能处理单个连接
            mkfifo pipe1;cat pipe1 | nc -v -l -p 9901 | /bin/bash 2>&1 1>pipe1;
    nc 实现远程反向 shell
        控制端先运行一个 nc
            nc -v -l -p 9901
        目标机器上连接控制机器的 9901 端口，并将其shell绑定到该连接上
            nc -v 127.0.0.1 9901 -e "bash"
            mkfifo pipe1; cat pipe1 | nc -v 127.0.0.1 9901 | /bin/bash 2>&1 1>pipe1;
            exec 3<>/dev/tcp/127.0.0.1/9901; exec 0>&3; exec 1<&3; /bin/bash 2>&1;
            exec 3<>/dev/tcp/127.0.0.1/9901; /bin/bash 2>&1 0>&3 1<&3; 这种写法似乎更好
    nc 如何模拟 telnet 客户端？
    nc 也可以像 telnet 那样模拟 http 客户端
        nc www.baidu.com 80
        连接后，快速地输入 GET / HTTP/1.0 然后连续输入两个回车，就能返回网页内容
        又或者直接一句命令
            printf 'GET / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\n' | nc www.baidu.com 80
    nc 如何模拟 http 服务器？静态的，动态的
        nc -v -l -k -p 9901 -c "echo \"HTTP/1.0 200 OK\\r\\nContent-Length: 11\\r\\n\\r\\nhelloworld\"";
        这一句是可行的，无法保持运行
        while true; do nc -v -l -k -p 9901 -c "echo \"HTTP/1.0 200 OK\\r\\nContent-Length: 11\\r\\n\\r\\nhelloworld\""; done;
        这一句是可行的，能保持运行，但每次只能处理一个请求，但无法退出
        trap "{ kill $$; }" SIGINT;while true; do nc -v -l -k -p 9901 -c "echo \"HTTP/1.0 200 OK\\r\\nContent-Length: 11\\r\\n\\r\\nhelloworld\""; sleep 1s; done;
        这一句是可行的，能保持运行，但每次只能处理一个请求，通过连续两次 ctrl+c 退出，但个请求都要等待一秒
        trap "{ kill $$; }" SIGINT;while true; do nc -v -l -k -p 9901 -c "echo \"HTTP/1.0 200 OK\\r\\nContent-Length: 11\\r\\n\\r\\nhelloworld\""; sleep 0.5s; done;
        这一句是可行的，能保持运行，但每次只能处理一个请求，通过连续两次 ctrl+c 退出，但个请求都要等待零点五秒，如果等待时间太短就无法通过连续两次 ctrl+c 退出了
        while true; do nc -v -l -k -p 9901 -c "echo \"HTTP/1.0 200 OK\\r\\nContent-Length: 11\\r\\n\\r\\nhelloworld\""; sleep 0.5s; done;
        这一句是可行的
        while true; do { echo -e 'HTTP/1.1 200 OK\r\nContent-Length: 11\r\n\r\n'; echo helloworld; } | nc -v -l -k -p 9901; sleep 0.5s; done
        这一句是可行的
        trap "{ kill $$; }" SIGINT;while true; do nc -v -l -k -p 9901 -e ./http.sh; sleep 0.5s; done;
        这是运行脚本文件的例子
        这是脚本文件的内容
            #!/bin/bash
            echo -n "HTTP/1.0 200 OK"
            echo -e -n "\r\n"
            echo -n "Content-Length: 11"
            echo -e -n "\r\n\r\n"
            echo "helloworld"
        测试用的命令
            curl -v 127.0.0.1:9901
            nc 127.0.0.1 9901
        已经有人做了类似的了
            https://github.com/avleen/bashttpd
            netcat -lp 9901 -e ./bashttpd
            我试过了，这个是可行的
    socat 和 ncat 和 nc-openbsd 都支持 tsl ，又可以搞各种奇技淫巧了。。。
    用 python 和 php 实现一个 nc ，只实现 -v -h -l 这三个参数即可
        如果 bash 有 /usr/lib/bash/accept 这个特性，那么直接用 bash 实现一个 nc 也不是不可以的
    windows 如何使用 nc
        github 上有好几个 windows 版的 nc ，但都很久没更新了
            https://github.com/diegocr/netcat
            https://github.com/int0x33/nc.exe
        先下载 windows 版的 busybox ，再使用 busybox 里的 nc
            https://frippery.org/busybox/
            https://github.com/rmyorston/busybox-w32
            要下载 busybox64u.exe 这个版本，64位且支持 unicode ，虽然这个版本只支持 win10和win11
        nmap 也有提供 windows 版的 nc
            https://nmap.org/ncat/
            https://sectools.org/tool/netcat/
            https://nmap.org/book/ncat-man.html
            https://nmap.org/ncat/guide/index.html
        windows 版的 ncat 最好还是在 bash 里运行。。。
        或者用 脚本 语言自己实现一个也可以。。。
    nc 的源码
        Nmap的nc
            https://github.com/nmap/nmap/tree/master/ncat
            https://github.com/nmap/nmap/blob/master/ncat/ncat_main.c
        BusyBox nc
            https://github.com/mirror/busybox/blob/master/networking/nc.c
        nc-openbsd
            https://github.com/openbsd/src/blob/master/usr.bin/nc/netcat.c
        nc-traditional
            可以下载到源码，但不能在线预览，bz2 的那个才是源码
            https://snapshot.debian.org/package/netcat/
            https://manpages.debian.org/bookworm/netcat-traditional/nc.traditional.1.en.html
        socat 的源码镜像，但很久没更新了
            https://github.com/3ndG4me/socat
            源码可以直接在官网里下载 gz 文件
            http://www.dest-unreach.org/socat/
        原始版本的nc，也是很久都没更新了
            https://sourceforge.net/p/nc110/git/ci/master/tree/
bash 如何实现并发
    使用 &
    使用 &+wait
    模拟一个队列
    使用 fifo
    使用 xargs -P
    使用 parallel
        parallel 通常不预装在系统里
bash 如何接收标准输入和环境变量？
    接收标准输入
        我突然意识到，判断 标准输入 里有没有数据 和 完整地读取 标准输入 里的数据，似乎也是一件困难的事
        这一段似乎只能用在文件里，可能和变量的作用域有关？
        stdin=""
        while read -r line; do
            echo "$line";
            stdin=$stdin$(echo "\n")$(echo "$line");
        done;
        echo -e $stdin
    环境变量
        echo $PATH;
        printenv PATH;
    如果遇到需要处理二进制数据的情况，可以尝试使用 xxd od hexdump 这类命令
bash 里如何实现多维数组？
termux
    下载和安装
        要先下载和安装 f-droid https://f-droid.org/
        然后 f-droid 换源 https://mirrors.tuna.tsinghua.edu.cn/help/fdroid/
        然后在 f-droid 里下载和安装 termux
            https://f-droid.org/en/packages/com.termux/
        termux 安装参考
            https://github.com/termux/termux-app#github
            https://github.com/termux/termux-app#f-droid
        termux 安装完后也要换源
            先运行这句 termux-change-repo
            在 tui 的界面里选 tua 的镜像源
            选好退出后再运行这句
            换源之后要运行这句 pkg update
            tremux 换源参考 https://mirrors.tuna.tsinghua.edu.cn/help/termux/
        运行这句 termux-setup-storage 获得 共享存储 和 外部存储 的访问权限
            运行这句 termux-setup-storage 后应该会弹出授权的确认框
            Termux 有三种不同的存储
                Internal storage 内部存储
                    Termux 的主目录，位于 /data/data/com.termux/files/home，只有 Termux 可以访问，不需要额外的权限
                    直接在 Termux 终端中输入命令，cd ~ 切换到主目录
                Shared storage 共享存储
                    在 Termux 终端中输入 termux-setup-storage 命令，并允许 Termux 访问存储权限。这样，Termux 主目录下会生成一个 storage 子目录，它是共享存储的符号链接
                External storage 外部存储
            如果不运行 termux-setup-storage ，就只能访问 Internal storage
        安装一些必要的包
            pkg install proot 模拟 root 环境
                安装完后，输入 termux-chroot 进入 proot 环境
                如果没有其它特别的设置或更新，每个新的会话都要先运行 termux-chroot 才能进入 proot 环境
            pkg install root-repo 对 root 用户有用的软件包
            pkg install vim
    sshd
        安装ssh: pkg install openssh ，提示全部按回车键默认即可。
        设置密码: passwd ，然后输入密码，第二次确认密码。
        开启sshd服务: sshd ，只要输入了这句命令就可以了， sshd 的默认端口是 8022
        查看IP地址：ifconfig（手机电脑在同一局域网内）
        在远程电脑连接
            ssh -o ServerAliveInterval=60 ip地址 -p 8022
            远程电脑就当作普通的 sshd 连接就可以了
        如果没有其它特别的设置或更新，每次重启都要手动启动 sshd
        可以通过 kill 的方式结束 kill 的进程
            通过 ps -elf 找到对应的 pid
                ps -elf 因为只要很少进程，所以直接运行 ps 也能很容易就找到 sshd 的进程
            通过 pid 杀掉对应的进程
                kill pid
    proot-distro
        可以模拟 arm 版的linux，不是虚拟机那种模拟，性能损失比较小
        pkg install proot-distro
        proot-distro list 可以通过这条命令查看发行版的信息
        proot-distro install debian
        proot-distro login debian
        安装完 debian 后也要记得换源 https://mirrors.tuna.tsinghua.edu.cn/help/debian/
    qemu
        只能运行在 proot-distro 中
        这就是完整的系统了，性能损失比较大
        可以模拟x86linux和windows
    docker
        只能运行在 proot-distro 或 qemu 中
        如果运行在 proot-distro 那么只支持 arm 的镜像
            按照官网的步骤一步一步安装就可以了， arm 版的的 docker
            很多镜像都没有 arm 版
    gui
        https://wiki.termux.com/wiki/Graphical_Environment
        pkg install x11-repo
        pkg install tigervnc
        运行 vncserver
            vncserver -localhost
                仅允许 本地连接
            vncserver -localhost no
                允许不是本地连接
        这句第一次运行时要设置密码
        查看 vnc 的守护进程
            ps -elf | grep vnc
        关闭 vncserver
            通过 kill pid 的形式
            或
            vncserver -kill :1
        查看 vncserver 的日志
            日志一般的路径
                /home/用户名/.vnc/localhost:端口号.log
                /home/用户名/.vnc/*.log
            通过查看日志获得 vncserver 监听的端口
            vncserver 监听的端口的规律
                vncserver :1 -> 监听 5091 端口
                vncserver :2 -> 监听 5092 端口
                如此类推
                vncserver -kill :1 这里的 :1 就是启动时的 :1
        可以通过 vncserver -list 查看当前的会话数量
        vncserver 启动后要设置环境变量
        pkg install xfce4
        ~/.vnc/xstartup 注释掉原本的内容，写入下面的内容
            #!/data/data/com.termux/files/usr/bin/sh
            xfce4-session &
        vnc -> x11/Wayland -> rdp
    vnc
        server
            apt install tightvncserver
        client
            vnc view 大部分应用商店都有这个
            如果vnc出现灰屏，就查看 vncserver 的日志
            似乎还差一点。现在打开vnc依然是黑屏
            使用 proot-distro debian 的 vncserver 是成功了
                全部工具都装在 proot-distro debian 里，分辨率应该还需要再调整一下
        termux 不支持 snap
    如何从外网访问 termux
        0 需要先有一台有公网ip的服务器
        1 在服务器的防火墙和安全组放行 8022 端口
        2 在 termux 里运行这句，运行这句之前要先确保 sshd 的服务已经启动了
            ssh -o ServerAliveInterval=60 -f -N -C -g -R 127.0.0.1:8022:127.0.0.1:8022 用户名@远程服务器地址
        3 在远程计算机里运行这句
            ssh -o ServerAliveInterval=60 -f -N -C -g -L 127.0.0.1:8022:127.0.0.1:8022 用户名@远程服务器地址
        4 在远程计算机里运行这句，这样就能通过外网连回手机的 termux 了
            ssh -o ServerAliveInterval=60  用户名@127.0.0.1 -p 8022
linux 应用的一般启动套路
    至少一个启动脚本
        检测或启动一些前置依赖
        设置一些环境变量
    至少一个主体程序
        主体程序启动时会依次读取配置文件
            全局的 和 用户的
        配置文件可以有多种方式声明
        配置文件的声明有优先级且可以覆盖
            默认的配置
            全局的配置文件
            用户的配置文件
            环境变量
            命令行里的配置文件
            命令行参数
        一些配置在运行时也可以更改
        配置的优先级
            默认的 < 环境变量 < 配置文件 < 命令行参数 < 运行时修改
    配置文件虽然一些有约定俗成的规定，但通常依然会散落到各个位置
    通过包管理安装的软件和编译安装的软件往往会有一些差异
    （现在我似乎有一点理解为什么 Gentoo 会坚持编译安装软件了）
垃圾回收
    什么是垃圾
    为什么要进行垃圾回收
    手动回收 -> 就是 c c++ 那一套
    自动回收 -> 这是讨论得最多的，特别是那些搞 java 的
        引用计数
        四色标记
        标记-清除
        三色标记
        分代收集
    php的垃圾回收
打包和压缩
    tar
        tape archive (磁带 存档)
        大多数linux发行版都会有 tar
        git fow windows 里也有一个 tar
        原版的 tar 只支持打包，新版的 tar 能自动调用压缩工具，需要系统里也包含 gzip
        所以现在的 tar 命令能同时执行打包和压缩的操作
        windows10 1803 及以后的版本都内置了 tar
        unix 上有一个名为 ar 的工具，但现在已经被 tar 取代
        例子
            tar -cvf test.tar test
                把名为 test 的文件或目录打包，最后生成的文件命名为 test.tar
            tar -zcvf test.tar.gz test
                把名为 test 的文件或目录打包并使用 gzip 压缩，最后生成的文件命名为 test.tar.gz
            tar -jcvf test.tar.bz2 test
                把名为 test 的文件或目录打包并使用 bzip2 压缩，最后生成的文件命名为 test.tar.bz2
            c 新建打包文件
            z 使用 gzip 压缩
            v 显示打包和压缩的过程
            f 指定生成的文件路径
    压缩
        算法 压缩格式 容器格式
            哈夫曼编码（Huffman Coding）
            Deflate
            LZMA
            LZMA2
            压缩 和 加密 似乎有紧密的联系
            压缩算法的专利保护，似乎只保护压缩，不保护解压
        工具
            lzip
            xz
            bzip2
            Info-ZIP
                zip 用于压缩
                unzip 用于解压
                在 windows 下是 wiz
            gzip 和 gunzip
                gzip 用于压缩
                gunzip 用于解压
                大多数 linux 发行版包含的是这两个
            7z
                7zfm.exe（7-zip File Manager）是7-Zip软件的GUI主程序，一般来说，只使用7zfm.exe就可以了
                7z.exe 是纯命令行工具
                7zg.exe 是7-Zip软件的GUI模块，也可以在命令行中使用，但会显示一个图形界面的进度窗口，7zfm实际上也是调用7zg
            windows 下的软件
                windows 的 explorer 能直接支持 zip ，从windows me开始
                winzip 也是商业软件，也支持多种格式
                winrar 支持 zip 和 rar 还有其它格式，是收费的商业软件，中国特供版有免费的但会有广告
                Bandizip 支持多种格式，有免费版和收费版
                国产全家桶里的压缩软件 好压 快压 速压 360压缩 2345压缩
    分卷压缩
        在linux环境下
            压缩完文件直接用 split 分割就可以了。。。
                两句命令
                    tar -zcvf test.tar.gz test; split -b 50m -d test.tar.gz test.tar.gz-
                一句命令
                    tar -zcf - test | split -b 50m -d - test.tar.gz-
                -b 50m 每个分片50m
                -d 使用数字编号
                - 来自标准输入
                test.tar.gz- 分片的前缀
            使用cat命令合并，要注意分卷文件的顺序，要按顺序合并
                cat test.tar.gz-* > test.tar.gz
                cat test.tar.gz-00 cat test.tar.gz-01 cat test.tar.gz-02 > test.tar.gz
            合并完后再解压
                tar -zxvf test.tar.gz
    自解压
        自释放压缩包（英语：self-extracting archive，缩写为SFX或SEA）是一种可执行程序，
        它包含一个被压缩的文件，以及一个用于提取压缩包内文件的计算机程序。
        此类压缩包不需要使用其他压缩程序就可以直接运行并解压缩。 
        主流的压缩软件都支持自解压，但 gzip 不支持
        在 linux 环境下的自解压？
        其实我觉得 自解压 可以作为软件的安装包
    密码保护
        在linux环境下
            压缩完文件直接用 openssl 加密就可以了。。。
                tar -zc test | openssl enc -e -des3 -salt -k 123456 -out test.tar.gz
            同样地，解密就是先用 openssl 解密，然后再解压
                openssl enc -d -des3 -salt -k 123456 -in test.tar.gz | tar -zxvf test
    压缩软件比较 https://en.wikipedia.org/wiki/Comparison_of_file_archivers
    HTTP 协议中的数据压缩 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Compression
        gzip
        br
    zlib https://github.com/madler/zlib
    归档格式
        仅归档
        仅压缩
        归档并压缩
        软件打包和分发
        容器文件技术
各种帮助文件
    man info
    hlp chm hsx mshc h1s
    javadoc 和 javahelp
        javadoc 是文档生成器，生成的是 html 文件
        javahelp 类似于 chm ，也是用 html ，最后生成的是一个 gui 程序
    documentation generator 文档生成器
    这类东西在维基百科里被称为 帮助系统(help system)
浏览器如何访问本地文件
    https://developer.mozilla.org/en-US/docs/Web/API/FileSystem
    https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API
    https://developer.mozilla.org/en-US/docs/Web/API/Window/requestFileSystem
如何用 history 和 hash 做一个路由
    初始化
    监听路由的变化
    匹配路由并渲染对应的内容
    放行不匹配的路由
telnet rlogin ssh
    telnet 是最古老的，通常 telnet 连接成功后启动的是 login 程序
    rexec/rlogin/rsh都属于rsh-server包，又或者叫做 Berkeley r-commands
        rlogin
        rexec
        rsh
        rcp
        rstat 从内核返回性能统计信息。
        ruptime 显示自上次重新启动以来 Unix 系统运行了多长时间
        rwho 列出登录到本地网络上所有多用户 Unix 系统的用户
    rlogin 类似于 telnet ，但因为是专用于远程shell的协议，所以实现起来比 telnet 更简单，连接速度也会稍微快一点，但也是只支持交互式的shell
    rexec 就是和 rlogin 差不多但只支持非交互式shell，就是一次只能执行一行命令
    rsh 和现代的 ssh 很类似了，只是少了加密的功能
    ssh
        和 telnet r-commands 相比，ssh 有完善的加密机制，可以有交互式的shell和非交互式的shell
    这几个是 windows 的
        r rcmd rscript rtrem
    图形界面的远程控制主要是 RFB 和 RDP ，RFB 就是 vnc 使用的协议， RDP 就是 windows 远程桌面使用的协议
如何用一条命令关闭windows的屏幕
    这一句只能运行在 cmd 里
        powershell (Add-Type '[DllImport(\"user32.dll\")]^public static extern int SendMessage(int hWnd, int hMsg, int wParam, int lParam);' -Name a -Pas)::SendMessage(-1,0x0112,0xF170,2)
    这一段效果是一样的，能运行在 powershell 里，但一个 powershell 窗口只能运行一次，因为类型不能重复定义
        $Code = @'
        [DllImport("user32.dll")]
        public static extern int SendMessage(int hWnd, int hMsg, int wParam, int lParam);
        '@
        (Add-Type -MemberDefinition $Code -Name a -Pas)::SendMessage(-1,0x0112,0xF170,2)
    这一句效果是一样的，能运行在 powershell 里，但一个 powershell 窗口只能运行一次，因为类型不能重复定义
        (Add-Type -MemberDefinition '[DllImport("user32.dll")] public static extern int SendMessage(int hWnd, int hMsg, int wParam, int lParam);' -Name a -Pas)::SendMessage(-1,0x0112,0xF170,2)
如何用命令行打开windows的控制面板
    按下 Win 键 + R 键，打开运行对话框，输入 control ，然后按回车键
    在 cmd 或 powershell 或 其他终端里，输入 control ，然后按回车键
在没有管理员权限的前提下运行需要管理员权限的程序
    运行前先设置好环境变量
        set __COMPAT_LAYER=RUNASINVOKER
        export __COMPAT_LAYER=RUNASINVOKER;
        [Environment]::SetEnvironmentVariable('__COMPAT_LAYER', 'RUNASINVOKER', [EnvironmentVariableTarget]::Process)
    如果是安装程序，那么安装的路径不能在系统盘里，
        安装的路径可以选择 %USERPROFILE%\AppData\Local
在windows中，通过 pid 获取进程的命令行
    $process = Get-WmiObject Win32_Process -Filter "ProcessId = 49532"; if ($process) {return $process.CommandLine} else {return $null}
    Get-WmiObject -Class Win32_Process -Filter "name = 'php-cgi.exe'"
计算机科学的五次浪潮
    大型机     1945 第一台通用的电子计算机
    个人计算机 1975 微软成立
    互联网     1990 互联网Internet第一个网页浏览器WorldWideWeb由提姆·柏纳-李设计面世
    移动互联网 2007 iphone 的出现
    ai        2012 AlexNet
nas
    软件
        虚拟化
            PVE ESXi
        文件系统
            磁盘阵列
        操作系统
        网络
            内网穿透 和 动态代理
        应用
            网盘
            笔记
    硬件
        就普通的服务器，然后再加上 ups
        至少两块硬盘
    网
        宽带
            双路宽带？
        蜂窝移动通信网络
            双卡双待？
    电
        市电
        ups
        超级电容
    nas 有哪些流媒体解决方案？
        ftp
        smb
        nfs
        WebDAV
        DLNA
        Miracast
        单独建一个网站或app
            直出视频文件
            使用hls
    除了视频之外还可以继续有 音频 图片 文档 等等
    更多？
        连接其它设备？物联网？智能家电？all in one？
            忽略 猫 和 路由 ？
        始终至少需要一个外网的服务器
        更多的存储设备
            用于冷备的硬盘
            网盘上再放一份数据？
        放在哪里？体积？噪声？辐射？
        费用？
            硬件费用，电费，网费
和声音相关的笔记
    声音
        物体是如何发出声音的
            声音是由物体振动产生的机械波，它可以在空气、水或者其他介质中传播。
        人是如何发出声音的
        人是如何感受声音的
            声波是通过空气传达到人的耳朵的（忽略骨传导的情况）
        振动 的本质是什么？
        波长 和 频率 的本质是什么？
    音乐
        乐谱
            五线谱：是世界上通用的一种记谱法，数字1~7来表示音的高低，用短横线、附点、升降号等符号来表示音的时值和变化
            简谱：是指一种简易的记谱法
            六线谱：是专为吉他设计的谱。六线谱有六条线，每一条线代表一根琴弦，与吉他的弦一一对应。从上到下分别是1到6弦，上面细下面粗。线上的数字表示在吉他的第几品。六线谱主要有独奏（旋律）记谱、分解和弦伴奏记谱和扫弦节奏记谱三种方式。
            四线谱：和吉他谱很像，主要是用于尤克里里，也是上面细，下面粗，但是四条线，而且每条线跟吉他谱的不太一样。右边标识的是空弦音。四线谱也有数字表示品格位置，x表示按住和弦拨弦，↑↓表示扫弦方向。
        歌
            包含人声的
            纯音乐
            作曲 编曲 填词 演唱 演奏
        乐器
            按地域分，可分为西洋乐器、中国民族乐器、日本雅乐乐器等。
            按演奏方式分，可分为管乐器、弦乐器、打击乐器、键盘乐器等。
            按发声原理分，可分为气鸣乐器、弦鸣乐器、膜鸣乐器、体鸣乐器、电鸣乐器等。
        分类方式
        曲 和 词
        风格 和 流派
        交响乐 就是 管弦乐
从符号到文学
收集各种镜像站点
    大学的
    https://mirrors.tuna.tsinghua.edu.cn/
    https://mirrors.bfsu.edu.cn/
    https://mirrors.ustc.edu.cn/
    企业的
    https://developer.aliyun.com/mirror/
    https://mirrors.cloud.tencent.com/
    https://mirrors.sohu.com/
    https://mirrors.163.com/
公共的cdn
    百度静态资源公共库 https://cdn.code.baidu.com/
    BootCDN开源项目加速服务 http://www.bootcdn.cn/
    七牛云免费开放公共库 https://www.staticfile.org/
    又拍云免费JS库 https://jscdn.upai.com/
    新浪云计算CDN公共库 https://lib.sinaapp.com
    jsdelivr https://www.jsdelivr.com
    cdnjs https://cdnjs.com/
淘宝的镜像
    https://registry.npmmirror.com/binary.html
    可以用来下载各种开发的软件 git for windows, selenium, node, python, ...
如何不登录微软帐号安装uwp应用
    找到应用网页链接，在 微软商店里选择，分享，复制链接
    在这个网站里搜索 https://store.rg-adguard.net/
    下载一个带有 .appxbundle 或者 .appx 后缀的文件即可 (版本区别)
    安装 uwp 应用时可能需要管理员权限
中文文案排版指北 https://github.com/sparanoid/chinese-copywriting-guidelines
中文技术文档的写作规范 https://github.com/ruanyf/document-style-guide
让长文章更容易阅读的十项原则 https://www.uisdc.com/10-typeset-make-article-readable
命令行的艺术 https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md
微软的写作风格指南
    https://docs.microsoft.com/zh-cn/contribute/style-quick-start
    https://docs.microsoft.com/zh-cn/style-guide/welcome/
程序员延寿指南 https://github.com/geekan/HowToLiveLonger
程序员做饭指南 https://github.com/Anduin2017/HowToCook
开源软件指南
    https://github.com/github/opensource.guide
    https://opensource.guide/zh-hans/
版本控制软件比较
    git
        github
        gitlab
        gitee
        coding
    mercurial hg
        Bitbucket
    Subversion SVN
    Perforce
https://download.libsodium.org/libsodium/releases/
SSL双向认证

python + openssl
c + openssl

windows 更新 python
cmd 下
1、先通过 pip freeze > requirements.txt   将你的旧版本中的第三方库的名字，输出到requirements.txt 文件中。
2、卸载python，重启电脑
3、安装新的python ，安装时一定要添加选择path
4、重启电脑
5、pip install -r requirements.txt

git add articleList.json sitemap.xml rss.xml README.md; git commit -m "update auxiliary"

git reset --soft 884444e1fe8f918ffe1ab5ee53799a9a89d98869

php updateMetadata.php

不要同时提交两篇文章

新增一篇文章
    add [文章标题]
大幅更新某一篇文章的内容
    add section [文章标题] 更新的内容
    update section [文章标题] 更新的内容
    update article [文章标题]
只更新了一点内容
    update fraction 日期
    update fraction 20211223
    pwd; sleep 8000; git commit -m "update fraction "$(date +%Y%m%d); git push;
修改 错别字 标点 格式
    update format
更新 sitemap 之类的文件
    update auxiliary 具体内容
    update auxiliary 日期
    update auxiliary 20211223
    update auxiliary article

````
