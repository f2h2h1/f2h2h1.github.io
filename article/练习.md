# 练习
## leetcode
### 简单
#### 1021.删除最外层的括号
```
有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。
```

示例 1：
```
输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```

示例 2：
```
输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
```

示例 3：
```
输入："()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
```

提示：
```
S.length <= 10000
S[i] 为 "(" 或 ")"
S 是一个有效括号字符串
```

C
```C
char * removeOuterParentheses(char * S){
    int i,sum=0, j=0;
    int len = strlen(S);
    for(i=0; i<len; i++) {
        if(S[i] == '(') {
            sum +=1;
        } else {
            sum -= 1;
        }
        if(S[i] == '(' && sum > 1) {
            S[j] = '(';
            j++;
        } else if(S[i] == ')' && sum > 0) {
            S[j] = ')';
            j++;
        }
    }
    S[j] = '\0';
    return S;
}
```
PHP
```PHP
/**
 * @param String $S
 * @return String
 */
function removeOuterParentheses($S) {
    $stack = [];
    $ret = '';
    $S = str_split($S);
    $len = count($S);
    for ($i = 0; $i < $len; $i++) {
        if ($S[$i] == '(') {
            array_push($stack, $S[$i]);
            if (count($stack) > 1) {
                $ret .= $S[$i];
            }
        } else {
            if (count($stack) > 1) {
                $ret .= $S[$i];
            }
            array_pop($stack);
        }
    }
    return $ret;
}
```

## 其它
#### 李白打酒
```
话说大诗人李白，一生好饮。幸好他从不开车。
一天，他提着酒壶，从家里出来，酒壶中有酒2斗。他边走边唱：
无事街上走，提壶去打酒。
逢店加一倍，遇花喝一斗。
这一路上，他一共遇到店5次，遇到花10次，已知最后一次遇到的是花，他正好把酒喝光了。
请你计算李白遇到店和花的次序，可以把遇店记为a，遇花记为b。
则：babaabbabbabbbb 就是合理的次序。像这样的答案一共有多少呢？
请你计算出所有可能方案的个数（包含题目给出的）。
```

C
```C
#include <stdio.h>
int sum = 0;
int f(int a,int b,int c) {
    if (a > 0) {
         f(a-1,b,c*2);
    }
    if (b > 0) {
        f(a,b-1,c-1);
    }
    if (a == 0 && b == 0 && c == 1) {
        sum=sum+1;
    }
    return sum;
}
int main() {
    f(5, 9, 2);
    printf("%d\n", sum);
}
```

#### 字母矩阵
```
给定两个整数M，N，生成一个M*N的矩阵，矩阵中元素取值为A至Z的26个字母中的一个，A在右下角，其余各数按逆时针方向旋转前进，依次递增放置，当超过26时又从A开始填充。例如，当M=5，N=8时，矩阵中的内容如下：

L K J I H G F E
M D C B A Z Y D
N E N M L K X C
O F G H I J W B
P Q R S T U V A

输入描述
M为行数，N为列数，其中M，N都为大于0的整数。
输出描述
分行输出相应的结果
输入例子
4 3
输出例子
F E D
G L C
H K B
I J A
```

C
```c
#include  <stdio.h>
#include  <stdlib.h>
int main() {
    short M, N;
    char **matrix, row, col, i, direction, len;
    // M = 5;
    // N = 8;
    scanf("%hd %hd", &M, &N);
    // printf("%d %d\n", M, N);

    matrix = (char**)malloc(M*sizeof(char*));
    for (row = 0; row < M; row++) {
        matrix[row] = (char*)malloc(N*sizeof(char));
        for (col = 0; col < N; col++) {
            matrix[row][col] = 0;
        }
    }

    i = 65;
    len = M * N;
    direction = 0;
    for (col = N - 1, row = M - 1; len > 0; len--) {
        matrix[row][col] = i;
        i++;
        if (i > 90) {
            i = 65;
        }
        switch (direction) {
            case 0:
                row--;
                if (row == -1 || matrix[row][col] != 0) {
                    row++;
                    direction = 1;
                    col--;
                }
                break;
            case 1:
                col--;
                if (col == -1 || matrix[row][col] != 0) {
                    col++;
                    direction = 2;
                    row++;
                }
                break;
            case 2:
                row++;
                if (row == M || matrix[row][col] != 0) {
                    row--;
                    direction = 3;
                    col++;
                }
                break;
            case 3:
                col++;
                if (col == N || matrix[row][col] != 0) {
                    col--;
                    direction = 0;
                    row--;
                }
                break;
            default:break;
        }
    }

    for (row = 0; row < M; row++) {
        for (col = 0; col < N; col++) {
            printf("%c ", matrix[row][col]);
        }
        printf("\n");
    }

    return 0;
}
```
PHP
```php
<?php

list($M, $N) = fscanf(STDIN, "%d %d");

$matrix = array_map(function ($item) use ($N) {
    return array_pad([], $N , 0);
}, array_pad([], $M , []));

$count = $M * $N;
$current = 65;
$direction = 0; // 0上 1左 2下 3右

for ($col = $N - 1, $row = $M - 1; $count > 0; $count--) {
    $matrix[$row][$col] = $current;
    $current++;
    if ($current > 90) {
        $current = 65;
    }
    switch ($direction) {
        case 0:
            $row--;
            if ($row == -1 || $matrix[$row][$col] != 0) {
                $row++;
                $direction = 1;
                $col--;
            }
            break;
        case 1:
            $col--;
            if ($col == -1 || $matrix[$row][$col] != 0) {
                $col++;
                $direction = 2;
                $row++;
            }
            break;
        case 2:
            $row++;
            if ($row == $M || $matrix[$row][$col] != 0) {
                $row--;
                $direction = 3;
                $col++;
            }
            break;
        case 3:
            $col++;
            if ($col == $N || $matrix[$row][$col] != 0) {
                $col--;
                $direction = 0;
                $row--;
            }
            break;
        default:break;
    }
}

printf("%s", array_reduce($matrix,
    function($carry, $row) {
        return $carry.array_reduce($row, function($carry, $col) {
            return $carry.sprintf("%c ", $col);
        }, '')."\n";
    }, ''));
```


> 力扣（LeetCode）来源的题目著作权归领扣网络所有。链接：https://leetcode-cn.com

> 上述题目的解答均为作者所有
