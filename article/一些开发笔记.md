一些开发笔记
================================

## 在 VSCode 里调试 JAVA
1. 安装 JDK
2. 把 JDK 添加进环境变量
3. 安装 VSCode 的 JAVA extension pack 拓展
4. 使用 VSCode 打开文件夹
5. 新增一个 debug 的类型 JAVA ，点击右下角的添加配置，选择 JAVA Lanuch Program
6. 写一份测试的代码，并在 mian 函数加个断点
10. 然后在终端里运行编译命令和运行命令，如果编译命令不复杂，可以配合 code runner 拓展，直接点击右上角的运行图标，或设置一个任务

## 在 VSCode 里调试 Python
1. 安装 Python
2. 把 Python 的安装目录和安装目录下的 script 添加进环境变量里
3. 在 VSCode 安装 Python 拓展（ microsoft 出品的）
4. 新增一个 debug 的类型 Python ，点击右下角的添加配置，选择 Python: Terminal (integrated)
5. 写一份测试的代码，并加个断点
6. 然后在终端里运行，可以配合 code runner 插件，直接点击右上角的运行图标，或设置一个任务

## 在 Windows10 里修改 administrator 帐号的帐号名的三种方式
1. 通过管理里的系统工具修改
```
选中桌面中的计算机图标，右键，点击管理
系统工具
    本地用户和组
        用户
            选中Administrator，然后重命名
重启电脑
```

2. 通过策略租修改
```
win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
    windows设置
        安全设置
            本地策略
                安全选项
                    拉到最下面
                    双击这个选选项 重命名系统管理员帐户
重启电脑
```

3. 通过 netplwiz (Network Places Wizard) 网上邻居向导 修改
```
win+r 打开运行
输入 netplwiz
选中Administrator，然后双击，然后修改
重启电脑
```

## Windows10 无密码远程连接
1. 允许任何远程着桌面的连接
2. 修改 Windows 的安全策略，允许远程桌面连接使用空密码
```
win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
    windows 设置
        安全设置
            本地策略
                安全选项
                    拉到最下面
                    禁用 使用空密码的本地账户只允许控制台登录
```


- 电脑提示“账户名与安全标识间无任何映射完成”
一般是修改玩用户名后没有重启导致的。

- 因为公司的电脑不能设密码，同时我又想远程桌面公司的电脑，考虑到安全问题，不能用默认用户名裸奔，所以修改用户名和设置无密码的远程桌面


## ss 的使用

需要一个在 wall 以外的服务器

ss 的各个版本
https://github.com/shadowsocks/shadowsocks/wiki/Feature-Comparison-across-Different-Versions

### python

1. 下载 python
1. 安装 python
1. 把 python 添加到环境变量
1. 刷新环境变量
1. 下载 ss
    ```shell
    python -m pip install shadowsocks
    # 如果上面那句下载失败，可以尝试用这句安装
    python -m pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
    # 如果上面那句还是下载失败，可以尝试先把 master.zip 文件下载到本地，再安装
    ```
1. 在服务器的策略组放行相应的端口
1. 在防火墙放行相应的端口
1. 运行以下命令
    ```shell
    ssserver -p 61813 -k windows@163.qq -m aes-256-cfb
        -p 是端口号
        -k 是密码
        -m 是加密方式
    上面那条命令需要在 服务器的策略组 和 防火墙 放行 61813 端口
    ```
1. 下载客户端
1. 正确填写 ip 端口 密码
1. 一些加密的算法会依赖这个库 libsodium ，最好把这个库也装上
    ```
    https://download.libsodium.org/libsodium/releases/
    ```
1. 更新 ss
    ```
    python -m pip install --upgrade shadowsocks
    # 如果上面那句更新失败，可以尝试这样更新，先卸载再重新安装，卸载前记得先备份当前的版本
    python -m pip show shadowsocks
    python -m pip uninstall shadowsocks
    python -m pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
    ```
1. 失效时，可以尝试，更改端口，更改密码，更改加密方式，换一个ip
1. 参考
    ```plaintext
    https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E
    ```

### libev

安装依赖
yum install epel-release -y
yum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y

下载源码
curl -L -O https://github.com/shadowsocks/shadowsocks-rust/archive/refs/tags/v1.23.5.tar.gz

编译

安装


- 安装
    - debian
        ```
        apt update
        apt install shadowsocks-libev
        ```
- 作为服务端运行
    ```
    ss-server -s 0.0.0.0 -p 61813 -k windows@163.qq -m aes-256-cfb
    或者
    ss-server -c config.json
    {
        "server": "0.0.0.0",
        "server_port": 61813,
        "password": "windows@163.qq",
        "method": "aes-256-gcm"
    }
    ```
    对应的文档 https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-server.asciidoc
- 作为客户端运行
    ```
    ss-local -s host -p 61813 -k windows@163.qq -m aes-256-cfb -l 1080
    或者
    ss-local -c config.json
    {
        "server": "host",
        "server_port": 61813,
        "local_address": "0.0.0.0",
        "local_port": 1080,
        "password": "windows@163.qq",
        "timeout": 600,
        "method": "aes-256-gcm"
    }
    ```
    对应的文档 https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-local.asciidoc

    在命令行里加入这个环境变量
    ```
    export ALL_PROXY=socks5h://127.0.0.1:1080
    ```

    检测代理是否有效
    ```
    curl -v -L www.baidu.com
    curl -v -L www.cip.cc
    curl -v -L ip-api.com
    ```

<!--

nohup ss-local -s host -p 61813 -k windows@163.qq -m chacha20-ietf-poly1305 -l 1080 >> out.log 2>&1 &

用于定时启动的脚本
```
# ssserver-startup.ps1
$host.UI.RawUI.WindowTitle="ssserver"
ssserver -p 61304 -k windows@163.qq -m chacha20-ietf-poly1305
```

用于定时重启的脚本
```
# ssserver-restart.ps1
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver"} ;
Start-Sleep -Seconds 1;
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver" -and $_.Name -eq "powershell"} | Stop-Process ;
Start-Sleep -Seconds 1;
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver" -and $_.Name -eq "python"} | Stop-Process ;
Start-Sleep -Seconds 1;
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver"} | Stop-Process ;
Start-Sleep -Seconds 1;
powershell -File "C:\Users\Administrator\Desktop\ssserver-startup.ps1" ;
```

用于新建计划任务的命令
```
Register-ScheduledTask -TaskName "ssserver-restart" -Trigger (New-ScheduledTaskTrigger -Daily -At 2am) -Action (New-ScheduledTaskAction -Execute "powershell" -Argument " -File `"C:\Users\Administrator\Desktop\ssserver-restart.ps1`" ");
```

-->

## 使用 privoxy 将 socks5 转换为 http 代理

安装
```
sudo apt install privoxy
```

配置
在这个文件 /etc/privoxy/config 的最后追加内容
```
# 转发设置为本地socks代理
forward-socks5  /  127.0.0.1:1080 .
# 本地http代理监听端口
listen-address  127.0.0.1:1081
```

重启
```
systemctl restart privoxy
systemctl enable privoxy
```

在命令行里加入环境变量
```
export http_proxy=http://127.0.0.1:1081; \
export HTTPS_PROXY=http://127.0.0.1:1081; \
export ALL_PROXY=socks5h://127.0.0.1:1080
```

## VS 和 VC 库 的对应关系

|||
|-|-|
|Visual Studio 6.0|VC6|
|Visual Studio .NET 2002|VC7.0|
|Visual Studio .NET 2003|VC7.1|
|Visual Studio 2005|VC8|
|Visual Studio 2008|VC9|
|Visual Studio 2010|VC10|
|Visual Studio 2012|VC11|
|Visual Studio 2013|VC12|
|Visual Studio 2015|VC14|
|Visual Studio 2017|VC15|
|Visual Studio 2019|VS16|
|Visual Studio 2022|VS17|

- Visual C++ 6.0 是 Visual Studio 6.0 的一部分，但可以独立安装，类似于 word 和  office 之间的关系
- 从 VC10 开始才有 64位
- vc 库的下载地址 https://docs.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist

## php 版本和 VC 库的对应关系

|||
|-|-|
|5.2|vc6|
|5.3|vc9|
|5.4|vc9|
|5.5|vc11|
|5.6|vc11|
|7.0|vc14|
|7.1|vc14|
|7.2|vc15|
|7.3|vc15|
|7.4|vc15|
|8.0|vs16|
|8.1|vs16|

- 其实下载下来的压缩包名有写着对应的 vc 库，系统位数， ts 和 nts

## Windows 安全地删除U盘

U盘 弹出失败的原因是进程占用了 U盘 ，只要占用 U盘 的进程都不在占用 U盘 或 都结束了， U盘 就可以安全地弹出了。

所以，让 U盘 安全地弹出的关键是找到占用 U盘 的进程。

当占用 U盘 的进程结束后，有时立即弹出 U盘 还是会失败的，这时再等待五六秒，再试一次弹出 U盘 就可以了。

可以安全退出 U盘 时也不要马上拔 U盘 ，最好等个五六秒再拔 U盘 。

这是各种方法的总结
1. 最简单的，在系统托盘右键，弹出，或在此电脑的界面，选中 U盘，右键，弹出
1. 关掉所有文件夹再试一次弹出 U盘
1. explorer.exe 重启，再试一次弹出 U盘
1. 注销当前的登录，再次登录，再试一次弹出 U盘
1. 通过任务管理器找到占用 U盘 的进程
    1. 打开任务管理器
    1. 切换到性能页面
    1. 打开资源监视器
    1. 切换到 cpu 页面
    1. 在 关联的句柄 栏目的搜索框内输入你的 U盘 盘符（如G:\）
    1. 即可看到当前占用 U盘 的进程
1. 关闭 U盘 的写入缓存
    1. 控制面板
    1. 管理工具
    1. 计算机管理
    1. 设备管理
    1. 磁盘驱动
    1. 选择当前的 U盘
    1. 右键 属性 策略
    1. 关闭写缓存
    1. 关闭写缓存可能会造成 U盘 数据的丢失，关闭了写缓存后，要确保 U盘 里的文件已经保存好再弹出 U盘
1. 在磁盘管理里使 U盘 脱机
    1. 控制面板
    1. 管理工具
    1. 磁盘管理
    1. 选择当前的 U盘
    1. 右键 脱机
    1. U盘 脱机后下次插入要重新挂载，脱机之后可以马上联机，再安全弹出，这样 U盘 下次插入时就不用联机了
    1. 脱机会直接关掉所有的文件句柄，要确保 U盘 里的文件已经保存好再脱机
    1. 脱机选项不可选，可能是有虚拟内存分配到 U盘 ，这时取消在 U盘 上的虚拟内存即可
        - 进入电脑属性->高级系统设置->高级->性能设置->高级->更改，关闭自动管理分页文件大小，取消在该磁盘上设置的虚拟内存
    1. 有时脱机还会失败，这时就继续参考下面的步骤
1. 通过 日志 查找占用 U盘 的进程
    1. 打开事件查看器
    1. windows日志
    1. 系统
    1. 找到最近的一条 来源 Kernel-PnP 的记录
    1. 记录的常规里有占用 U盘 的 进程id 的
    1. 再通过任务管理器的 pid 找到对应的进程
    1. 有时，即使找到占用 U盘 的进程，但却无法结束进程，或 进程是系统的核心进程
        - 这时可以尝试以这样的关键词（进程名 或 进程id + Kernel-PnP ）在网上搜索解决的方法
1. 如果是 Windows Defender 占用 U盘 可以试试这样操作
    1. 打开 Windows Defender 安全中心
    1. 病毒和威胁防护
    1. 病毒和威胁防护 设置
    1. 将在使用的 U盘 盘符添加为排除项
1. 最后的方法，关机，关机后就肯定可以安全地拔 U盘

笔者通常在直接弹出 U盘 失败后，会多试几次，然后通过 日志 找到对应的进程，然后通过 任务管理器 结束对应的进程，如果结束进程失败，还是会再次在网上搜索解决方法。
脱机 和 关闭写缓存都有一点副作用；
关闭文件夹，重启 explorer.exe ，注销，关机，这类都有点麻烦。

## windows 下的 linux 环境
- Git for Windows
- mingw
- mingw-w64
- TDM-GCC
- Cygwin
- MSYS
- MSYS2
- gnuwin
- windows10 子系统
    - wsl1
    - wsl2
- 虚拟机
    - VMware
    - VirtualBox
    - Hyper-V
    - qemu

其实就三种套路
- 子系统
- 虚拟机
- 运行在 win32 上的兼容层

wsl1 和 wsl1 之前的 sfu/sua 是子系统， wsl2 其实算是虚拟机，其它的都是运行在 win32 上的兼容层。
nt 内核其实是有三个子系统 win32 ，os/2 和 posix ，只是除了 win32 其它两个都没有什么存在感。

所谓的 linux 环境，除了需要 bash 之外，还需要各种 linux 的工具，还需要处理管道，还需要处理文件名和路径的问题。
还有各种 linux api 的问题（但不写需要编译的代码，只使用环境中的工具，其实这个问题可以忽略的）。

## 下载 AcFun 视频

### 0. 需求
1. 一部安卓手机
2. AcFun 安卓版客户端
3. ffmpeg

### 1. 使用手机客户端缓存视频

### 2. 在手机的文件管理器里找到缓存文件
1. 用文件管理器打开手机的根目录
2. 找到 acfun 文件夹
3. 点进这个目录里 acfun→core→local
4. 然后点进一个以数字名命的文件夹
5. 这个文件夹里就是缓存的视频，文件名都没有后缀，可以通过创建时间大致判断出哪个是最新缓存的视频

### 3. 在电脑里下载 ffmpeg
1. 打开 ffmepg 的下载网址，并选择系统对应的版本下载
```plaintext
http://www.ffmpeg.org/download.html
```
2. 把下载后的文件解压
3. 解压后的文件里会有个一个名为 ffmpeg 的文件，这个就是 ffmpeg 的主程序，可以用来转换视频格式

### 4. 把缓存的视频文件复制进电脑，并使用 ffmpeg 转换为 MP4 格式
1. 把缓存文件从手机复制进 ffempeg 的解压目录
2. cd 进 ffempeg 的解压目录
3. 运行以下命令，转换格式后的文件名必须带有 MP4 的后缀
```bat
ffmpeg -i "缓存视频文件的文件名" "转换格式后的文件名"
```

## 在Windows下配置Tomcat服务器

### 0. 目标
- 在 Windows 下配置 Tomcat 服务器
- Windows 10 (x64)
- Tomcat 9
- JAVA 8

### 1. 下载 JAVA
```plaintext
https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
```
选择，Windows 64 位
### 2. 安装 JAVA
打开下载的 exe 文件，一路点 next 直到安装完毕

### 3. 配置 JAVA 环境变量
1. 新建一个环境变量 JAVA_HOME ，值为 JDK 的安装目录，例子
```plaintext
C:\Program Files\Java\jdk1.8.0_161
```

2. 把以下值加入到环境变量 Path
```plaintext
%JAVA_HOME%\bin
%JAVA_HOME%\jre\bin
%JAVA_HOME%\lib
```

### 3. 下载 Tomcat
```plaintext
https://tomcat.apache.org/download-90.cgi
```
选择，core，Windows 64 位
### 4. 配置 Tomcat
1. 解压下载的文件
2. 把解压后的文件夹复制到 C 盘的根目录下（这里可以是任意目录）
3. 把 Tomcat 目录下的 bin 文件夹的路劲加入的环境变量
4. 把网站程序复制进 Tomcat 的 webapps 文件夹
5. 启动 Tomcat ，启动 Tomcat 的脚本在 bin\startup.bat

## DOS 的启动过程

- 从启动盘中读取这两个系统文件
    - IO.SYS
    - MSDOS.SYS
- 启动盘的根目录下寻找并执行这三个文件
    - CONFIG.SYS
    - COMMAND.COM
    - AUTOEXEC.BAT
- IO.SYS、MSDOS.SYS 和 COMMAND.COM 是系统的核心
- CONFIG.SYS 用来配置系统运行环境
- AUTOEXEC.BAT 用来自动执行一些批处理命令
- IO.SYS、MSDOS.SYS 和 COMMAND.COM 其中一个缺失了，系统会无法启动
- CONFIG.SYS 或 AUTOEXEC.BAT 缺失了，系统依然能启动，但一些软件或驱动可能无法正常运行

## 安装 PHP7 的 GUI 扩展
### 1 下载拓展
- https://pecl.php.net/package/ui
- 按照本地的 PHP 版本下载对应的拓展文件

### 2 安装拓展
1. 把下载下来的压缩包解压
2. 把 php_ui.dll 复制到 PHP 的 ext 目录下
3. 把 libui.dll 和 pthreadVC2.dll 放到 PHP 的根目录下

### 3 运行 demo
- 解压的压缩包里有四个 demo
- gallery.php histogram.php snake.php starfield.php
- 可以使用命令行运行
- 例如 php snake.php
- 如果是 windows 系统，可以使用 php-win 运行，这样就没有黑框了

### 注意
如果出现这种错误

> 无法启动此程序，因为计算机中丢失 libui.dll，尝试重新安装该程序以解决此问题。

这个提示出现说明你没有放入 libui 和 pthreadVC2 文件到 php 的根目录下

## linux 实现后台不间断运行
- supervisor
    - supervisor 是守护进程
    - supervisor 会根据配置运行对应的 start/stop/restart/reload 命令
    - supervisor 是子进程的父进程，子进程退出时，父进程能收到相关的信号 SIGCHLD ， supervisor 收到信号后就能执行相应的操作，例如重启进程
    - supervisor 不能监控守护进程是因为守护进程的父进程 id 不是 supervisor 的进程id，所以当守护进程退出时 supervisor 无法收到 SIGCHLD 信号
- screen/tmux 这类终端复用的软件
    - tmux 分成两部分 server 和 client ，其中 server 是守护进程
    - 通过 ssh 连接到服务器后 ssh server 会 fork 一个 shell ，远程终端就是显示这个 shell 的输入和输出
    - ssh 的 shell 能通过 tmux 的 clinet 让 tmux 的 server 再新建一个 shell
    - 这个新建的 shell 的父进程是 tmux 的 server ，所以当前终端关闭不会关闭这个 shell ，从而达到了类似于后台运行的效果
    - 大致的示意图
        ```
        remote terminal <----> ssh server <----> shell <----> tmux client <----> tmux server <----> shell
        ```
- 把代码改写成支持以 守护进程 的形式运行
    1. 步骤
        1. fork子进程，父进程退出（必须）
        1. 子进程创建新会话（必须，setsid()）
        1. 改变当前工作目录 chdir（非必须，建议做 chdir("/var");）
        1. 重设子进程掩码（非必须 umask(0)）
        1. 关闭文件描述符（非必须）
            ```
            close(STDIN_FILENO);
            close(STDOUT_FILENO);
            close(STDERR_FILENO);
            // 另一种关闭文件描述符的方法，但 getdtablesize() 来自 unistd.h
            // for(i = 0; i < getdtablesize(); i++) 
            // {
            //     close(i);
            // }
            ```
        1. 执行核心工作（必须）
    1. C 的例子
        - 新建源码文件 `vi deamon.c`
        - 代码
        ```c
        #include <stdio.h>
        #include <unistd.h>
        #include <stdlib.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <string.h>
        #include <time.h>
        int main(int argc, char *argv[])
        {
            pid_t pid = fork();
            if (pid > 0) {
                exit(0); // 1.父进程退出
            } else if (pid == 0) {
                // 2.变为会话组长，脱离了控制终端 setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离
                setsid();
                // 3.改变进程的工作目录
                chdir("/var");
                // 4. 重置文件掩码
                umask(0);
                // 5. 关闭文件描述符
                close(STDIN_FILENO);
                close(STDOUT_FILENO);
                close(STDERR_FILENO);
                // 6. 执行核心操作
                // 每三秒一条记录到日志文件里，执行100次
                int fd = open("/var/temp-deamon-log.txt", O_CREAT | O_WRONLY | O_APPEND, 0664);
                int i;
                for (i = 0; i < 100; i++) {
                    sleep(3);
                    time_t curtime;
                    time(&curtime);
                    char* pt = ctime(&curtime);
                    write(fd, pt, strlen(pt) + 1);
                }
                close(fd);
            }
            return EXIT_SUCCESS;
        }
        ```
        - 编译运行命令
        ```shell
        gcc deamon.c && \
        ./a.out && \
        sleep 30 && \
        cat -n /var/temp-deamon-log.txt && \
        kill `ps -elf | grep a.out | awk '{print $4}'` && \
        rm /var/temp-deamon-log.txt
        ```
    1. 这种是 sysvinit 体系下的 守护进程 ，虽然 systemd 也兼容，但 systemd 似乎会有不一样的更高效的实现。
- nohup 配合 &
    - nohup 的作用，nohup 英文全称 no hang up（不挂起）
        - 将 stdin 重定向到 /dev/null
        - 将 stdout 和 stderr 重定向到 nohup.out 或者用户通过参数指定的文件
        - 屏蔽掉 SIGHUP 信号，因为 SIGHUP 被屏蔽了，所以会话关闭后程序能继续运行
        - 调用 exec 启动指定的命令
    - `>> out.log` 把输出追加到 `out.log` 文件里
    - `2>&1` 把 stderr 重定向到 stdout
    - & 的作用是把程序放到后台运行，但不会改变 stdin stdout stderr
    - 例子 `nohup php queue.php >> out.log 2>&1 &`
- systemctl
    1. 创建一个 service
        - 类型为 service 的 unit
        - 在 `/etc/systemd/system` 目录新建一个文件 myDaemon.service
            ```
            [Unit]
            Description=myDaemon service
            [Service]
            # service 的类型
            Type=simple
            # 退出后马上重启
            Restart=always
            # 这里的 bash 路径和脚本路径都必须是绝对路径
            ExecStart=/bin/bash /root/myDaemon.sh
            [Install]
            # 开机启动时的依赖项，大多数情况下都是填这个
            WantedBy=multi-user.target
            ```
    1. 启动 service 并加入到开机启动中
        ```
        # 重新加载 systemctl 配置
        systemctl daemon-reload
        # 启动 myDaemon.service
        systemctl start myDaemon.service
        # myDaemon.service 加入到开机启动中
        systemctl enable myDaemon.service
        ```
- cron *****
    - 例子 `* * * * * php queue.php >> out.log 2>&1`
- docker run 同时加上这两个参数 --restart always 和 -d ，也能达到类似的效果（docker 要设置好开机启动和服务）

## gcc 编译流程

编译的四个步骤
1. 预处理 由 .c 文件到 .i 文件。
    - 对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等
1. 编译 由 .i 文件到 .s 文件。
    - 将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件
1. 汇编 由 .s 文件到 .o 文件。
    - 将汇编代码翻译成了机器码，但是还不可以运行
1. 链接 由 .o 文件到可执行文件。
    - 处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址

编译的四个步骤对应的 gcc 命令
```
gcc -E test.c -o test.i
gcc -S test.i -o test.s
gcc -c test.s -o test.o
gcc test.o -o test
```

实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预处理器cpp、预编译程序cc1、汇编器as、链接器ld
```
cpp test.c -o test.i
cc1 test.i -o test.s
as test.s -o test.o
ld test.o -o test
```

- 头文件应该是在预处理阶段加上去的
- 各种库应该是在链接阶段加上去的

## GNU 的命令

GNU 工具链
- glibc
- gcc
- gdb
- gnu make
- gnu bison
- autotools GNU构建系统（GNU Build System）又名Autotools
    - autoscan
    - aclocal
    - autoconf
    - autoheader
    - automake
- binutils 二进制工具组
    - as  汇编
    - ld 连接
    - nm 显示目标文件内的符号
    - ar 静态库归档
    - objdump 反汇编
    - readelf elf 结构分析工具
- coreutils GNU核心工具组
    - fileutils 文件工具
        - chgrp chown chmod cp ls mkdir rm touch
    - textutils 文本工具
        - cat head tail wc
    - shellutils shell 工具
        - echo printf nohup pwd sleep
- findutils GNU查找工具组
    - find
    - xargs
- inetutils 网络工具组
    - inetd
    - telnet
    - ftp
    - ping
    - traceroute
    - ifconfig
- bash
- gzip
- gnu grep
- gnu awk
- gnu sed
- grub
- ...

其它
- flex（快速词法分析产生器，英语：fast lexical analyzer generator）是一种词法分析程序。
    - 它是lex的开放源代码版本，以BSD许可证发布。
    - 通常与 GNU bison 一同运作，但是它本身不是 GNU 计划的一部分。
- pkg-config 是一个在源代码编译时查询已安装的库的使用接口的计算机工具软件。 pkg-config 托管在 freedesktop.org 。 php 编译需要这个
    - 使用的效果大概像这样
    ```
    # 没使用 pkg-config
    gcc test.c -o test -I/usr/local/Cellar/opencv3/3.1.0_4/include/opencv -I/usr/local/Cellar/opencv3/3.1.0_4/include
    # 使用了 pkg-config
    gcc test.c -o test $(pkg-config opencv --cflags)
    ```
- BusyBox 是 GNU Core Utilities 的另一个开源替代，通常用在嵌入式系统里
- util-linux, GNU 核心工具组中未包含的一组大约100个基本 Linux 系统实用程序，例如mount，fdisk，more和kill
- IEEE Std 1003.1-2008 utilities
    - 这个列表中的UNIX实用程序由IEEE Std 1003.1-2008定义，是单一UNIX规范（SUS）的一部分。列表中的实用程序可以在UNIX操作系统和绝大多数类UNIX操作系统中找到。

<!--
bsdmainutils
net-tools 和 iputils-ping 和 iproute2
dnsutils
    host dig nslookup
-->

参考
- https://zh.wikipedia.org/wiki/GNU%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8
- https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84
- https://www.gnu.org/software/software.html

感觉 GNU 真的除了内核之外，什么都有了。

## 让网站支持 ipv6
1. 拥有一个 ipv6 地址
1. 域名解释 aaaa 记录指向 ipv6 的地址
1. 让网站程序支持 ipv6 地址
    - 通过网关翻译
        - 代码里用 ipv4 地址，域名解释 aaaa 记录到 网关，网关把 ipv6 的流量翻译成 ipv4 的流量再传递给网站
        - 代码里用 ipv6 地址，域名解释 a 记录到 网关，网关把 ipv4 的流量翻译成 ipv6 的流量再传递给网站
    - 让 web 服务器同时监听两个地址，代码里和 ip 相关的部分，都改成能兼容 ipv4 和 ipv6

用来测试网站对 ipv6 的支持，也可以用来查看 DNSSEC 的支持
https://ipv6.ustc.edu.cn/onlinechecklog.php

## 在命令行里格式化 json

1. python 的 json.tool ，好像 python2 和 3 都可以这样用
    ```
    echo '{ "name": "xiaohong", "age": 18 }' | python -m json.tool
    ```
    - 会转义中文，如果想不转义中文
    - 需要修改标准库里的文件，这样不是很好，在 python 的标准库 json 文件夹下有个 tool.py 文件，更改其中调用的 json.dump 函数，传一个ensure_ascii = False 参数即可

1. json_pp ， windwos 的 git bash 和 大多数 linux 发行版都有这个工具
    ```
    echo '{ "name": "xiaohong", "age": 18 }' | json_pp
    ```

1. jq ， 虽然大多数 linux 发行版都没有这个工具，但中文互联网环境下有好多文章都推荐这个
    - 下载 https://stedolan.github.io/jq/download/
    - 文档 https://stedolan.github.io/jq/manual/

1. php 的命令行，标准输入中一定要有数据，不然会一直等待；同样地 python 或 node 也可以实现类似的
    ```
    echo '{ "name": "xiaohong", "age": 18, "chinese character":"汉字" }' | \
    php -r 'print(json_encode(json_decode(file_get_contents("php://stdin")),JSON_PRETTY_PRINT|JSON_UNESCAPED_UNICODE));';
    ```

1. PowerShell 的 ConvertFrom-Json 和 ConvertTo-Json ，这两个要组合来使用
    ```
    echo '{"type":"image","offset":0,"count":20}' | ConvertFrom-Json | ConvertTo-Json
    ```

配合 curl 使用
```
curl -s -k https://localhost/dev.json | json_pp
curl -s -k https://localhost/dev.json | python -m json.tool
```
- -s 只输出 body
- -k 忽略 https


配合 PowerShell 的 Invoke-WebRequest 使用
```
Invoke-WebRequest https://localhost/dev.json -UseBasicParsing -SkipCertificateCheck | Select -ExpandProperty Content | ConvertFrom-Json | ConvertTo-Json
Invoke-WebRequest https://localhost/dev.json -UseBasicParsing -SkipCertificateCheck | Select -ExpandProperty Content | python -m json.tool
```
- -UseBasicParsing 把结果输出到命令行
- -SkipCertificateCheck 忽略 https ，这个参数要在 PowerShell6 之后才有效
- Select -ExpandProperty Content 选取 body 的输出

如果 Invoke-WebRequest 出现了这种错误。
```
因为 Internet Explorer 引擎不可用，或者 Internet Explorer 的首次启动配置不完整
```
可以尝试以下步骤来解决
1. 打开 IE 的 internet 选项
2. 点击安全选项卡，选中本地 intranet ，并点击站点按钮
3. 新的窗口中点击高级
4. 添加 about:security_powershell.exe 到输入框，点击添加
5. 把所有 IE 窗口一个个关闭就好了，再次在 powershell 下运行 Invoke-WebRequest

## Windows 里的 Java 环境配置

1. 下载并安装 JDK
    - 这些是免费的 JDK
        - https://openjdk.java.net/
        - https://www.microsoft.com/openjdk
        - https://adoptopenjdk.net/
        - https://www.azul.com/downloads/?package=jdk
        - https://developers.redhat.com/products/openjdk/download
    - 这是 oracle 的 JDK
        -  https://www.oracle.com/java/
    - 如果是 JDK 1.8 以上的版本，笔者比较倾向于用 microsoft 的 openjdk
    - 通常只有 oracleJDK 需要安装，其他的 JDK 都是压缩包，直接解压就好了
1. 把 JDK 加入环境变量
    1. 新建一个新的环境变量 JAVA_HOME ，值是 JDK 的根目录
    1. 在 PATH 里加入 %JAVA_HOME%\bin 和 %JAVA_HOME%\lib 和 %JAVA_HOME%\jre\bin （如果没有这个目录就忽略）
    1. 如果是 JDK 1.5 及之前的版本还需要一个 CLASSPATH 的环境变量
        - CLASSPATH 的值是 .;%Java_Home%\bin;%JAVA_HOME%\lib;%Java_Home%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
1. 下载并安装 maven
    - https://maven.apache.org/
1. 把 maven 加入环境变量
    1. 新建一个新的环境变量 MAVEN_HOME ，值是 maven 的根目录
    1. 在 PATH 里加入 %MAVEN_HOME%\bin
1. 下载并安装 ant
    - http://ant.apache.org/bindownload.cgi
1. 把 ant 加入环境变量
    1. 新建一个新的环境变量 ANT_HOME ，值是 ant 的根目录
    1. 在 PATH 里加入 %ANT_HOME%\bin

windows10 之前的系统在修改 path 时要注意分号 ;

在 JDK1.5 以后，classpath 并不是必须配置了，在 JDK1.5 之前，是没有办法在当前目录下加载类的（找不到 JDK 目录下 lib 文件夹中的 .jar 文件），所以我们需要通过配置 classpath ，但 JDK1.5 之后， JRE 能自动搜索目录下类文件，并且加载 dt.jar 和 tool.jar 的类。
dt.jar 是关于运行环境的类库，主要是用于 swing 的包，如果不使用可以不配置。
tools.jar 是工具类库。

编译和运行时可以通过参数 -classpath 指定 classpath 的路径，例如这样
```
javac -encoding UTF-8 -classpath .;./junit4.jar;./org.hamcrest.core_1.3.0.jar AaaTest.java JunitRunner.java
java -Dfile.encoding=UTF-8 -classpath .;./junit4.jar;./org.hamcrest.core_1.3.0.jar JunitRunner
```



## python 的 http 服务和 cgi

> python 的 cgi 模块在 3.13 被移除了
https://docs.python.org/zh-cn/3.12/library/cgi.html
https://peps.python.org/pep-0594/#cgi

python 一行命令启动 http 服务
```sh
# 最简单的 http 服务
python -m http.server
# 指定端口号的 http 服务
python -m http.server 8081
# 有 cgi 的 http 服务
python -m http.server --cgi
# 有 cgi 的和指定端口号的 http 服务
python -m http.server --cgi 8081
# 有 cgi 的，指定端口号的和指定ip地址的 http 服务
python -m http.server --cgi 8081 --bind 127.0.0.1
# 有 cgi 的，指定端口号的，指定ip地址的和指定站点根目录的 http 服务
python -m http.server --cgi 8081 --bind 127.0.0.1 --directory _book
```

- 所有 cgi脚本或程序 都必须有执行权限；在 linux 环境下是 755 ，整个路径都必须是可读可执行的。
- 默认情况下 cgi脚本或程序 要在这个目录下 /cgi-bin 。
- windows 环境下 py 脚本开头那句 #! 是没有效果的，其实在 windows 环境下没有开头那句也没问题的。
- windows 环境下只要不是 py 后缀的都会被当成 可执行文件， linux 可以执行其他脚本。
- 端口号要在 --cgi 参数后面。
- 无法设置 响应行 和 响应码，响应码都是 200 。 (~~起码 3.10 还是这样~~)

请求 cgi 脚本的例子
```
curl 127.0.0.1:8000/cgi-bin/test.py
```

cgi 脚本的例子
```python
#!/usr/bin/python3

print ("Content-type:text/html")
print ()                             # 空行，告诉服务器结束头部
print ('<html>')
print ('<head>')
print ('<meta charset="utf-8">')
print ('<title>Hello Word</title>')
print ('</head>')
print ('<body>')
print ('<h2>Hello Word!</h2>')
print ('</body>')
print ('</html>')

```

```python
#!/usr/bin/python3

print ("Content-type: application/json")
print ()                             # 空行，告诉服务器结束头部
print ('{"result": "this is a test"}')

```

这个例子大致相当于这个命令 `python -m http.server 8888`
```python
from http.server import HTTPServer, SimpleHTTPRequestHandler

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, SimpleHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

这个例子大致相当于这个命令 `python -m http.server --cgi 8888`
```python
from http.server import HTTPServer, CGIHTTPRequestHandler

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, CGIHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

不使用命令行的 http 服务例子，这是单线程的
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import json

class myHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({'result': 'this is a test'}).encode())

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, myHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

不使用命令行的 http 服务例子，这是多线程的
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import json

class ThreadingHttpServer(ThreadingMixIn, HTTPServer):
    pass

class myHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({'result': 'this is a test'}).encode())

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = ThreadingHttpServer(host, myHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

不使用命令行的 http 服务例子，这是多线程的，再加上 cgi 的支持
```python
from http.server import HTTPServer, CGIHTTPRequestHandler
from socketserver import ThreadingMixIn

class ThreadingHttpServer(ThreadingMixIn, HTTPServer):
    pass

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = ThreadingHttpServer(host, CGIHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

HTTPServer 和 BaseHTTPRequestHandler 是两个关键的类，一个用于接收 http 请求，一个用于处理请求，其它类基本是派生自这两个类
```
BaseHTTPRequestHandler -> SimpleHTTPRequestHandler -> CGIHTTPRequestHandler
HTTPServer -> ThreadingHttpServer
```

参考文档
- https://www.runoob.com/python3/python3-cgi-programming.html
- https://docs.python.org/zh-cn/3/library/cgi.html
- https://docs.python.org/zh-cn/3/library/http.server.html

<!--

java 中类似的命令，来自 jdk18 jep408
java -m jdk.httpserver [-b bind address] [-p port] [-d directory] [-h to show help message] [-o none|default|verbose]
```
java -m jdk.httpserver -b 127.0.0.1 -p 80
java -m jdk.httpserver -b 127.0.0.1 -p 80 -d ~/wwwroot
java -m jdk.httpserver -b 127.0.0.1 -p 80 -d ~/wwwroot -o verbose
```

php 中类似的命令
php [options] -S <addr>:<port> [-t docroot] [router]
```
php -S 127.0.0.1:80
php -S 127.0.0.1:80 -t ~/wwwroot
php -S 127.0.0.1:80 -t ~/wwwroot router.php
php -d xdebug.start_with_request=yes -S 127.0.0.1:80 -t ~/wwwroot router.php
```

ruby -run -e httpd . -p8000
busybox httpd -f -p 8000

go prel nodejs .net 都有类似的一句话服务，但需要安装相应的包

nc 理论上也可以实现，但一行代码会写得非常长

-->

## embed 版的 python 如何安装 pip

1. cd 到 python 的根目录
1. 然后运行这句 curl https://bootstrap.pypa.io/get-pip.py | ./python
1. 然后修改这个文件 python312._pth ， 312 是版本号，在这个文件里加上
    ```
    ./Lib/site-packages
    ```

参考这个文档 https://pip.pypa.io/en/stable/installation/

python 的环境变量，除了安装目录之外，还有一个 Script 目录
但其实一般影响都不大，根目录重要一点

如果没法把 python 加入环境变量，那么每次调用最好都用绝对路径

列出 pip 的所有模块
```
python -m pip list
```
列出 python 所有可用的模块
```
python -c 'import pydoc;pydoc.help("modules")'
```

这句也有类似的效果，但好像只有 sys 下的模块
```
python -c 'import sys;print(sys.modules.keys())'
```

## 如何退出 python 的交互式解释器
- 用 exit 函数退出
    - 先输入 import sys ，如果之前已引入了 sys 模块，就忽略这一句
    - 再输入 sys.exit()
- 快捷键退出： 在交互式解释器中，你可以使用快捷键退出：
    - 在 Windows 和 Linux 上，按 Ctrl + Z 然后按 Enter。
    - 在 macOS 上，按 Ctrl + D。

## python 常用的库和工具

### python 常用的库
- 核心数据分析库
    - Pandas ：提供高效的数据结构（如 Series 和 DataFrame），支持数据清洗、转换、聚合和时间序列分析，是数据分析的基础工具 
    - NumPy ：专注于多维数组和矩阵运算，为其他库（如 Pandas 和 SciPy）提供底层支持，适合数值计算 
    - Matplotlib ：基础的可视化库，支持绘制折线图、柱状图、散点图等，灵活性高但语法较复杂
- 可视化工具
    - Seaborn ：基于 Matplotlib 的高级库，简化了统计图表的生成，如热力图、分类图等，适合快速生成美观的可视化结果 
    - Plotly ：交互式可视化库，支持动态图表和仪表盘开发，常用于 Web 应用
    - pyecharts ：是一个基于 ECharts 的 Python 数据可视化库
- 科学计算与统计分析  
    - SciPy ：提供科学计算函数（如积分、优化、信号处理），结合 NumPy 使用，适合工程和数学领域 
    - Statsmodels ：专注于统计模型（如回归分析、时间序列），适合学术研究和复杂统计分析
- 大数据处理
    - PySpark ：PySpark是Apache Spark的Python接口，用于大规模数据处理和分析。
- 数据获取与处理
    - Requests：用于网络数据抓取
    - BeautifulSoup：从网页中提取结构化数据
- 机器学习
    - Torch
    - TensorFlow
    - Keras
    - sklearn
- web框架
    - Django
    - Flask
    - FastAPI
- 其它
    - pillow 图像处理
    - openpyxl 操作 excel
    - Playwright 操作浏览器
    - Pyinstaller 打包成 exe
    - auto-py-to-exe 基于 pyinstaller 的，有图形界面的打包工具
    - pywin32 操作windows窗口，类似于 autoit
    - pywinauto 类似于 pywin32

### python 常用的工具
- 包的管理
    - easy_install
    - pip
- 环境管理
    - venv
        自 3.3 版本之后添加的官方库，自 3.6 版本之后，成为官方推荐的多环境管理工具，3.3版本之后自带的模块，只支持3.3版本之后的
        但只能有一个 python 解释器，只能有一个 python 版本
    - virtualenv
        可以有多个 python 解释器，多个 python 版本可以共存，特别是 python2 和 python3
    - virtualenvwrapper
        用于管理 virtualenv
    - pyenv
        侧重于多个 python 解释器
    - pipenv
        pipenv 是一款比较新的包管理工具，其借鉴了 javascript 的 npm 和 PHP 的 composer 等理念，通过一个依赖描述文件 Pipfile 来安装和管理依赖
        pipenv 其实整合了 pip 和 virtualenv 等库
    - Anaconda
        Anaconda通过管理工具包、开发环境、Python版本，大大简化了你的工作流程。
        不仅可以方便地安装、更新、卸载工具包，而且安装时能自动安装相应的依赖包，
        同时还能使用不同的虚拟环境隔离不同要求的项目。
        安装Acaconda默认的Python是2.7；安装Acaconda3默认的Python是3.6
    - Miniconda
        Miniconda 是一个 Anaconda 的轻量级替代，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。
        Miniconda 相比 Anaconda ，去掉了科学计算的相关包，更加轻量级，没有那么臃肿。可以认为是Anaconda的最小化版本，用法与Anaconda完全一致。
- ide
    - PyCharm
    - Jupyter
    - Spyder
        - （前身为Pydee）是一个使用Python语言的开放源代码跨平台科学运算集成开发环境(IDE)。Spyder集成了NumPy，SciPy，Matplotlib与IPython，以及其他开源软件。
    - idle
- Anaconda 系列
    - Anaconda Distribution
    - Miniconda
    - Anaconda.org
    - conda-forge
    - miniforge
    - mamba
    - Micromamba

<!--

python 的类型
    数字 numeric
        整数 int
        浮点数 float
        复数 complex
    布尔 bool
    序列 sequence
        不可变序列 immutable-sequences
            tuple(元组)
            str(字符串)
            bytes(字节串)
        可变序列 mutable-sequences
            list(列表)
            bytearray(字节数组)
    集合 set
        可变集合 mutable set
            set(集合)
        不可变集合 immutable set
            frozenset(冻结集合)
    映射 mapping
        dict(字典)
和类型相关的内置函数
    bool()
    bytearray()
    bytes()
    complex()
    dict()
    float()
    frozenset()
    int()
    list()
    map()
    object()
    range()
    set()
    tuple()
    type()
内置常量
    True False None

range 是 list 的子类
bool 是 int 的子类
float 是 int 的子类
但 complex 不是 int 的子类

有内置函数的就当是内置类型吧
所有类型都是 类
object 是所有类型的父类

数据模型
https://docs.python.org/zh-cn/3.12/reference/datamodel.html
内置类型
https://docs.python.org/zh-cn/3.14/library/stdtypes.html

type(object)
    传入一个参数时，返回 object 的类型。
issubclass(class, classinfo)
    如果 class 是 classinfo 的子类（直接、间接或 虚的 ），则返回 True。
isinstance(object, classinfo)
    如果 object 参数是 classinfo 参数的实例，或者是其 (直接、间接或 虚拟) 子类的实例则返回 True。 
    则该函数总是返回 False。 
    推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。


python的列表（List）大概等于 C语言中的动态数组 []
python的元组（Tuple）大概等于 C语言中的普通数组 ()
python的字典（Dictionary）就是键值对，从形式上看，最接近php的数组 {}
python的集合（Set）是元素无序的不重复的线性表


python 转换成 exe

gui小程序
    powershell
        windows 环境下最容易分享，通常只需要脚本文件即可
        如果需要十分傻瓜式启动依然需要转换成 exe ，默认情况下容易有权限的限制
    python tk
        可以跨平台
        如果需要傻瓜式启动依然需要转换成 exe
    web+后台服务
        可以跨平台，甚至 安卓 也能运行
        通常有一个命令行窗口，这个对用户其实并不友好
        可以用各种语言实现
        界面可以做得很好看
        做成pwa形式，界面看起来也可以很像原生程序
    java gui
        可以跨平台
        java 也不是不可以，但总是要带着 jvm
    autoit
        也可以，但不能跨平台
    其它的
        要么太冷门（Lazarus）
        要么过时了（hta）
        要么实现起来很困难（mfc winforms wpf）
-->

## debian 一句命令安装 docker

因为要经常部署和重装系统，所以就整理了这样一句命令，可能会因为 docker 的更新而失效，要注意修命令里的版本号

如果一直安装失败，可以先设置好代理，再安装 docker

具体环境
- debian 11
- Docker version 20.10.12, build e91ed57
- docker-compose version 1.29.2, build 5becea4c

这是文档
https://docs.docker.com/engine/install/debian/

```bash
sudo apt-get remove -y docker docker-engine docker.io containerd runc ; \
sudo apt-get update && \
sudo apt-get install -y \
    ca-certificates \
    curl \
    gnupg \
    lsb-release && \
if [ -e /usr/share/keyrings/docker-archive-keyring.gpg ] ; \
  then rm /usr/share/keyrings/docker-archive-keyring.gpg; \
  else curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ;fi && \
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null && \
sudo apt-get update && \
sudo apt-get install -y docker-ce docker-ce-cli containerd.io && \
sudo docker run --rm hello-world && \
sudo curl -L --retry 100 --retry-delay 2 "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose && \
sudo chmod +x /usr/local/bin/docker-compose && \
docker-compose --version
```

如果 docker-compose 总是下载失败，可以尝试使用这样的脚本下载
```bash
COMMAND="curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose"
for ((i=0;i<100;i++))
do
    $COMMAND
    if [ $? -eq 0 ]; then
        exit 0;
    fi
done
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
```

## docker设置代理

### 拉取镜像时的代理

必须要改环境变量，而且是启动时的环境变量
https://docs.docker.com/engine/daemon/proxy/#environment-variables

在这个文件里 /etc/systemd/system/docker.service.d/http-proxy.conf 追加以下内容
```
[Service]
Environment="HTTP_PROXY=http://127.0.0.1:1081"
Environment="HTTPS_PROXY=http://127.0.0.1:1081"
Environment="NO_PROXY=localhost,127.0.0.1,.corp"
```

如果没有 http-proxy.conf 就自己新建一个
```
sudo mkdir -p /etc/systemd/system/docker.service.d
vim /etc/systemd/system/docker.service.d/http-proxy.conf
```

修改完后的重启
```
sudo systemctl daemon-reload
sudo systemctl restart docker
```

查看环境变量有没有设置成功
```
sudo systemctl show --property=Environment docker
docker info | grep -i proxy
```

### 构建镜像时的代理
### 运行容器时的代理

## 生成用于测试的容器的命令

具体环境
- debian 11
- Docker version 20.10.12, build e91ed57

```
docker pull debian:11

docker run \
    -it \
    --rm \
    -p 443:443 \
    debian:11 /bin/bash

cp /etc/apt/sources.list /etc/apt/sources.list_bak && \
sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list && \
apt update && \
apt install -y vim && \
apt install -y curl && \
apt install -y net-tools && \
apt install -y netcat && \
apt install -y procps

apt install -y bsdmainutils
apt install -y python3
apt install -y python3-pip

```

## curl 断点续传

例子
```
curl -C - -o php-7.3.11.tar.gz https://www.php.net/distributions/php-7.3.11.tar.gz
```
解释
```
-L 允许重定向
-C 开启断点续传
 - 这个表示开始和结束位置，一般就这样就可以了
--retry 100 超时重试 100 次，也可以是断点续传时的重试
--retry-delay 5 每次超时后等待 5 秒再重试
--connect-timeout 5 连接超过 5 秒算超时
    一次连接超时时间。如果出错， 提示形如：curl: (28) connect() timed out!
--max-time 10 单次请求的最大时间
    一次连接过程最大的允许时间。出错提示如：curl: (28) Operation timed out after 2000 milliseconds with 0 bytes received
--max-time 要大于 --connect-timeouts
--retry-max-time 30 整体请求的最大时间
-o 参数将服务器的回应保存成文件
-O 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。
如果服务器主动返回 失败 例如 reset 这类的，就会直接退出的了，不论有没有设置 --retry
```

curl 提供了一个脚本用于方便下载文件 https://github.com/curl/wcurl

github 好像不支持断点下载

## 在 debian 新建命令的别名

- 只对当前终端有效
    - 直接运行这个命令 `alias ll="ls -l "`
- 终端退出后仍然有效
    - 在 ./bashrc 里加上一行 `alias ll="ls -l "`
    - 然后运行这个命令 source ~/.bashrc
- 列出当前环境所有的别名
    ```
    alias
    alias -p
    ```
- 删除别名
    ```
    删除一个别名
    unalias ll
    删除两个别名
    unalias ll ll2
    删除全部别名
    unalias -a
    ```

## 在 bash 里判断一个变量是不是环境变量

判断 PS1 是不是环境变量
```
printenv|awk -F '=' ' {print $1}'|grep "^PS1$"
printenv|awk -F '=' ' {print $1}'|grep "^PS1$";if [ "$?" -eq 1 ]; then echo "1"; else echo "0"; fi;
printenv|awk -F '=' ' {print $1}'|grep "^PS1$";if [ "$?" -eq 1 ]; then echo "This variable is not an environment variable"; else echo "This variable is an environment variable"; fi;
printenv|awk -F '=' ' {print $1}'|grep "^PS1$" 1>/dev/null ;if [ "$?" -eq 1 ]; then echo "This variable is not an environment variable"; else echo "This variable is an environment variable"; fi;
```

<!--
## 在 bash 里判断一个文件的类型

判断 ./index.html 是不是文本文件
file -b -i ./index.html | grep "^text" 1>/dev/null ;if [ "$?" -eq 1 ]; then echo "This file is not a text file"; else echo "This file is a text file"; fi;



应该可以通过 file 命令来区分 文本文件 和 二进制文件
file -b -i 文件路径
-b 不输出文件名
-i 输出文件对应的 MIME type 和 MIME encoding
-L 根据软连接重定向
--mime-type 只输出 MIME type
只有输出的是 text 开头的是文本文件，其它都当作是二进制文件（并不是很严谨）

一次列出当前目录下全部的 .html 文件
file -i ./*.html


file -b -L --mime-type /bin/mail
-->
<!--

/bin
/sbin
/usr/bin
/usr/sbin
/usr/local/bin
/usr/local/sbin

alias 和 $PATH

echo $PATH|awk 'BEGIN{RS=":"}{print $0}'
printenv PATH|awk 'BEGIN{RS=":"}{print $0}'
printenv PATH|awk 'BEGIN{RS=":"}{print $0}'

realpath

file -L -i /bin/mail

file -L --mime-type /bin/mail

file -b -L --mime-type /bin/mail


alias -p

-->

## 用于 git pull 和 git push 的脚本

因为 github 的 pull 和 push 总是超时，所以写了两段脚本用于失败后的自动重试

```bash
#!/bin/bash

# ./git_help.sh pull
# ./git_help.sh push

GIT_COMMAND="git "
case $1 in
    "push"|"pull")
        GIT_COMMAND=$GIT_COMMAND$1
    ;;
    *)
        echo "only input push or pull";
        exit 1;
    ;;
esac

for ((i=0;i<100;i++))
do
    $GIT_COMMAND
    if [ $? -eq 0 ]; then
        exit 0;
    fi
done
```

```powershell
# ./git_help.ps1 pull
# ./git_help.ps1 push

param($a)
$GIT_COMMAND = "git "
if ($a -eq "push") {
  $GIT_COMMAND = $GIT_COMMAND + $a
} elseif ($a -eq "pull") {
  $GIT_COMMAND = $GIT_COMMAND + $a
} else {
  echo "only input push or pull"
  exit 1
}

for ($i = 1; $i -lt 100; $i++) {
  echo $i" "$GIT_COMMAND
  PowerShell -command $GIT_COMMAND
  # Invoke-Expression $GIT_COMMAND
  # Invoke-Command -ScriptBlock {Write-Host $GIT_COMMAND}
  # Invoke-Command -ScriptBlock {$GIT_COMMAND}
  if ($? -eq $true) {
    break
  }
}
```

## href 和 src

href 是 Hypertext Reference (超文本引用) 的缩写。
href 目的是为了建立联系，让当前标签能够链接到目标地址。

src 是 source (来源) 的缩写。
指向的内容将会应用到文档中当前标签所在位置。
例如 img 和 script 的 src 属性。

href 和 src 的值通常是 url 但也可以不是 url 。
其中一个例子就是 img 标签的 src 可以直接放 base64 的值。

可以简单但不严谨地理解为 href 不会加载， src 会加载。
这样解释好象很有道理。
但 link 标签是用 href 的。
link 标签能加载 css 和 页面图标 还有 manifest 还有 预加载的 js 。

## URI URL URN

它们的全称
- URI: Uniform Resource Identifier (统一资源标识符)
- URN: Uniform Resource Name (统一资源名称)
- URL: Uniform Resource Locator (统一资源定位符)
- URC: Uniform Resource Characteristic (统一资源特征)

URL，URN，URC 都属于 URI 。
语法都是
```
URI = scheme ":" scheme-specific-part
URI = scheme ":" ["//" authority] path ["?" query] ["#" fragment]
authority = [userinfo "@"] host [":" port]
```

一些例子
```
          userinfo       host      port
          ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
  https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top
  └─┬─┘   └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘
  scheme          authority                  path                 query           fragment

  ldap://[2001:db8::7]/c=GB?objectClass?one
  └┬─┘   └─────┬─────┘└─┬─┘ └──────┬──────┘
  scheme   authority   path      query

  mailto:John.Doe@example.com
  └─┬──┘ └────┬─────────────┘
  scheme     path

  news:comp.infosystems.www.servers.unix
  └┬─┘ └─────────────┬─────────────────┘
  scheme            path

  tel:+1-816-555-1212
  └┬┘ └──────┬──────┘
  scheme    path

  telnet://192.0.2.16:80/
  └─┬──┘   └─────┬─────┘│
  scheme     authority  path

  urn:oasis:names:specification:docbook:dtd:xml:4.1.2
  └┬┘ └──────────────────────┬──────────────────────┘
  scheme                    path
```
### URN

URN 的作用是描述资源的身份，例如 一个人的名字。 URN 的其中一个应用例子是 图书的 ISBN 号码 。

URN 的语法
```
urn:NID:NSS
```

NID 是 namespace identifier （命名空间标识符） 的缩写。

NSS 是 namespace specific string （命名空间特定字符串） 的缩写。

URN 的 NID 和 NSS 部分相当于 URI 里的 path 部分。

### URL

URL 的作用是描述资源的访问路径，例如 一个人的住址。

URL 的语法
```
                    hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment
```

### 其它

URC (统一资源特征)，在九十年代的时候， URL URI URC 被期望能组成一个互联网信息架构。
但 URC 一直停留在理论阶段，随之更晚出现的其他技术（例如 资源描述框架）取代了它们。

URI 的 scheme 和 URN 的 NID 都需要在 IANA 注册。

完整的 url 或 urn 会被称为绝对 uri ，
只有一部分的 url 或 urn 会被称为相对 uri 。

还有一个 Data URI 或者叫做 Data URL 。
这是具体的语法，也属于 URI 。
```
dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
mediatype  := [ type "/" subtype ] *( ";" parameter )
data       := *urlchar
parameter  := attribute "=" value
```

比较好区分的一个特征是，以 urn 开头的 uri 就一定是 urn ，
以 data 开头的 uri 就一定是 data url 。
除此之外的都是 url 。

url 两个斜杆 // 其实是没什么作用的
- 联网创始人蒂姆·伯纳斯-李承认，互联网地址中http:后面的两条斜线并无必要。伯纳斯-李解释说，虽然当时的编程惯例是双斜线，但结果并非真正必要。
    - https://www.zhihu.com/question/20035144
    - http://news.bbc.co.uk/2/hi/technology/8306631.stm
    - https://www.cnbeta.com/articles/95565.htm
- 虽然是这样，但 // 开头的 url 可以兼容 http 和 https 的链接

为什么文件 URL 以3斜杠开头？
- file:/// 之所以是三个斜杆，是因为忽略了主机名，更完整的 url 应该是这样的 file://host/
- 这两句 curl 的命令效果是一样的
    ```
    curl -i -v file:///C:/Users/example.txt
    curl -i -v file://localhost/C:/Users/example.txt
    ```

<!-- RFC1738 RFC8089 -->

<!--

host name = 主机名
domain name = 域名

FQDN
Fully Qualified Domain Name
完全 合规 域 名

PQDN
Partially Qualified Domain Name
部分 合规 域 名

FQDN = 主机名 + 域名

主机名可以命名为“部分合格的域名”。
因为主机名不提供域名。
我们只有知道或自动将域名添加到主机名时才能使用主机名。
例如，如果我们在同一个域中，则可以使用PQDN进行通信和规范。

域名的一种，能指定其在域名系统 (DNS) 树状图下的一个确实位置

主机名
一些语境下是指 FQDN
一些语境下是指 FQDN 中 最左边 或 查询过程中最后的一部分

域名
一些语境下是指 FQDN
一些语境下是指 FQDN 中除去 主机名 的部分

FQDN 中 最左边 或 查询过程中最后的一部分 有时也会被称为 服务名


主机名就机器本身的名字，域名是用来解析到IP的


-->

### 参考

- url
    - https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#data-url-no-spaces-def
    - https://datatracker.ietf.org/doc/html/rfc3987
- uri https://datatracker.ietf.org/doc/html/rfc3986
- uri url run 之间的关系 https://datatracker.ietf.org/doc/html/rfc3305
- data url https://datatracker.ietf.org/doc/html/rfc2397
- https://en.wikipedia.org/wiki/List_of_URI_schemes

## linux 系统的启动流程
<!--
1. 通电
1. 运行主板 ROM 里面的 BIOS
1. BIOS 加电自检 (POST, Power-On Self-Test) ，就是检查硬件
1. BIOS 根据指定的顺序，读取 MBR 中的引导程序（bootloader）
1. 启动 MBR 中的 GRUB （ linux 通常用 GRUB 作为引导程序）
1. GRUB 把 linux 内核加载到内存并把控制交给内核
1. 内核内存中自解压之后就将控制权交给 init 进程
    - init 进程 通常是 systemd 或 init（SysV init）
    - 大多数 linux 发行版选择了 systemd

大致是
    bios 内核引导 init getty login shell
-->

1. 通电
1. 加电自检 (POST, Power-On Self-Test)
1. 硬件初始化
    - legacy BIOS
        - MBR
    - UEFI
        - GPT
1. 执行引导程序 (bootloader)
    - LILO (LInux LOader)
    - SYSLINUX
    - GRUB (GNU Grand Unified Bootloader)
1. 加载和启动 linux 内核镜像
    - initrd
    - initramfs
1. 执行 init
    - init (SystemV init)
    - UpStart
    - systemd (system deamon)
1. 执行守护进程

现在主流的启动过程是
```
MBR -> GRUB -> initramfs -> systemd
```

简单但又不严谨地理解， init 是第一个运行在用户态的进程。
这里描述的 init 可能是 SystemV init 也可能是 UpStart 也可能是 systemd 。

笔者认为作为一个写上层应用的程序员，了解到 加载和启动 linux 内核镜像 这一层就已经足够深入的了。

## 获取本机公网 IP 的几个方法

```bash
# 获取本机公网 IP 
curl ifconfig.me
curl icanhazip.com
curl ipinfo.io/ip
curl ipecho.net/plain
curl www.trackip.net/i
curl ip.sb
curl whatismyip.akamai.com
curl ifconfig.co
curl ident.me
curl inet-ip.info
curl 'https://api.ipify.org?format=json' #ipv4
curl 'https://api64.ipify.org?format=json' #ipv6
# 获取本机公网 IP ，这几个有返回位置信息
curl myip.ipip.net
curl ip.cn
curl cip.cc
curl ip-api.com
curl ip-api.com/json
# 查询某个ip的信息
curl http://ip-api.com/json/58.62.220.66
```

## 在命令行中直接运行代码

大概就两种套路，从标准输入读取代码，从命令行参数读取代码，从命令行参数读取代码时要留意转义字符

### php

代码开头都不需要 <? 或 <?php
```
phpcode=$(cat <<- 'EOF'
echo '123';
echo "asd";
$a="qwe";
echo $a;
echo "\"\$a\"\\";
var_dump($argv);
EOF
);

echo $phpcode | php -a -- a=1;

php -r "$phpcode" -- a=1;

php -a <<- 'EOF' -- a=1;
echo '123';
echo "asd";
$a="qwe";
echo $a;
echo "\"\$a\"\\";
var_dump($argv);
EOF
```

### node

```
nodecode=$(cat <<- 'EOF'
console.log('hello');
EOF
);

echo $nodecode | node

node -e "$nodecode"

node <<- 'EOF'
console.log('hello');
EOF
```

### python

```
执行标准输入里的代码，和普通文件里的代码一样，必须要有换行符

pythoncode=$(cat <<- 'EOF'
print('hi1')
print('hi2')
EOF
);

echo $pythoncode | python

python << 'EOF'
print('hi1')
print('hi2')
EOF

在一行里，换行用分号;替代
python -c "import os;print(os.environ['PATH'])"
```

## 分页公式

### 相关变量

- 总行数 totalRecord
- 当前页 pageNo
- 每页大小 pageSize
- 总页数 totalPage
- 当前页大小 currentPageSize

### 计算总页数

伪代码
```
totalPage = ceil((totalRecord  +  pageSize  - 1) / pageSize);
```

php
```php
$totalPage = ceil(($totalRecord  +  $pageSize  - 1) / $pageSize);
```

sql
```sql
SELECT @totalRecord := 123, @pageSize := 6;
SELECT ceil((@totalRecord + @pageSize + 1) / @pageSize);
```

ceil 是 向上取整 的函数

### sql

关于分页的语法
```
SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
三种写法
SELECT * FROM table LIMIT rows
SELECT * FROM table LIMIT offset, rows
SELECT * FROM table LIMIT rows OFFSET offset
```

具体的例子
```sql
-- 每页 10 行，第 1 页
SELECT * FROM table LIMIT 10
SELECT * FROM table LIMIT 0, 10
SELECT * FROM table LIMIT 10 OFFSET 0
-- 每页 10 行，第 2 页
SELECT * FROM table LIMIT 10, 10
SELECT * FROM table LIMIT 10 OFFSET 10
-- 每页 10 行，第 3 页
SELECT * FROM table LIMIT 20, 10
SELECT * FROM table LIMIT 10 OFFSET 20
-- 每页 10 行，第 4 页
SELECT * FROM table LIMIT 30, 10
SELECT * FROM table LIMIT 10 OFFSET 30
```

这是获取总行数的 sql
```sql
SELECT count(*) FROM table LIMIT 1;
```
- 虽然还有其它方式，但使用 count 是最保险的，多数框架都是用 count 实现的

这是获取总页数的 sql
```sql
SELECT @pageSize := 6;
SELECT ceil((count(*) + @pageSize + 1) / @pageSize) FROM table LIMIT 1;
SELECT ceil((count(*) + 7) / 6) from table LIMIT 1;
```
- 多数情况下都不会用 sql 来计算

这是获取某一页的 sql
```sql
-- 每页 6 行，第 2 页
SELECT @pageSize := 6;
SELECT @pageNo := 2;

SELECT @rows := @pageSize;
SELECT @offset := (@pageNo-1)*@pageSize;

SELECT * FROM table LIMIT @offset, @rows;
SELECT * FROM table LIMIT @rows offset @offset;
```

### 计算当前页的大小

```
计算当前页的行数，这是伪代码
function getCurrentPageSize(pageSize, pageNo, totalRecord, totalPage)
{
    if (pageNo < totalPage) {
        return pageSize;
    } else if (pageNo == totalPage) {
        return pageSize + (totalRecord - totalPage*pageSize);
    } else {
        // Throw an exception
    }
}
```

## 安装 busybox

- 通过包管理
```
apt install -y busybox
```

- 通过 docker
```
docker run -it --rm --name my-busybox busybox:1.36-glibc sh
```

- 通过 type 命令判断当前系统有没有安装 busybox
```
type busybox
```

- 查看 busybox 的帮助和版本
```
busybox --help
```

- 可以在浏览器体验 busybox ，但版本好像有一点旧
```
https://busybox.net/live_bbox/live_bbox.html
```

- windows 版的 busybox
```
https://frippery.org/busybox/
https://github.com/rmyorston/busybox-w32
```
建议下载 busybox64u.exe 这个版本，64位且支持 unicode ，虽然这个版本只支持 win10和win11

### 编译安装

直接用 apt 安装的 busybox 版本太旧了,
busybox 常常要用到宿主机的文件，容器里的 busybox 用起来不怎么方便。

安装前置的依赖
```
apt install -y bzip2 && \
apt install -y make && \
apt install -y gcc
```

下载源码
```
curl -O "https://busybox.net/downloads/busybox-1.37.0.tar.bz2"
```

解压源码
```
tar -xjf ./busybox-1.37.0.tar.bz2
```

切换进源码目录并开始安装
```
cd busybox-1.37.0
make defconfig
make install
```

编译后的 可执行二进制文件 可能在当前编译的目录，可能在源码的目录，反正要找一下
```
find / -name busybox
```

找到后就复制或剪切到 /bin 目录
```
cp /root/busybox-1.37.0/busybox /bin/busybox
```

一句命令完成下载和安装，但需要是 root 用户，其它用户需要修改对应的目录
```
apt install -y bzip2 && \
apt install -y make && \
apt install -y gcc && \
cd && \
curl -L -O "https://busybox.net/downloads/busybox-1.37.0.tar.bz2" && \
tar -xjf ./busybox-1.37.0.tar.bz2 && \
cd busybox-1.37.0 && \
make defconfig && \
make install && \
cp /root/busybox-1.37.0/busybox /bin/busybox && \
cd
```

## 寻找php的配置文件

1. 使用内置函数
    ```
    php -r 'phpinfo();' | grep 'Loaded Configuration File'
    php -r 'echo php_ini_loaded_file();'
    ```
2. 命令行
    ```
    php --ini
    php -i | grep 'Loaded Configuration File'
    ```
3. 使用 strace 命令，这个命令会输出很多数据，要认真找一下才找到配置文件
    ```
    strace -f -e open,execve,openat php -v 2>&1 | grep "O_RDONLY) = 3"
    ```

cli fpm apache 的 php 配置文件可能会不一样。
fpm 还有一个单独的配置文件。
在 windows 环境下 strace 可能会有权限的问题，看不到输出。
cli 可以通过命令行比较准确地获得配置文件位置。
web 最保险的方式还是输出 php_ini_loaded_file() 函数。

## 如何自建一个 DNS 服务

使用这个仓库的代码来搭建 DNS ，
使用这个仓库是因为笔者平时主要使用php做开发，
https://github.com/yswery/PHP-DNS-SERVER

使用的是 v1.4.1 版本
```
git checkout v1.4.1
```

1. 下载源码
```
https://github.com/yswery/PHP-DNS-SERVER
```

1. 安装依赖，加上 --ignore-platform-reqs 参数，是因为这个仓库声明依赖的php版本比较旧，没这个参数可能无法下载composer里的依赖
```
composer install --no-suggest --no-dev --ignore-platform-reqs
```

1. 参考 example/example.php 文件自己新建一个启动用的php文件 startup.php
```php
require_once __DIR__.'/vendor/autoload.php';

$json = <<< EOF
{
    "test.localhost.com": {
      "A": "127.0.0.1"
    }
}
EOF;

class JsonTextResolver extends \yswery\DNS\Resolver\JsonResolver
{
    public function addZoneText(string $zone)
    {
        $zone = json_decode($zone, true);
        $this->addZoneArr($zone);
    }

    public function addZoneArr(array $zone)
    {
        $resourceRecords = $this->isLegacyFormat($zone) ? $this->processLegacyZone($zone) : $this->processZone($zone);
        $this->addZone($resourceRecords);
    }
}

// JsonResolver created and provided with json dns records
$jsonResolver = new JsonTextResolver([]);
$jsonResolver->addZoneText($json);

// ipconfig /flushdns
// php localhost2.php

// System resolver acting as a fallback to the JsonResolver
$systemResolver = new yswery\DNS\Resolver\SystemResolver();

// StackableResolver will try each resolver in order and return the first match
$stackableResolver = new yswery\DNS\Resolver\StackableResolver([$jsonResolver, $systemResolver]);

// Create the eventDispatcher and add the event subscribers
$eventDispatcher = new \Symfony\Component\EventDispatcher\EventDispatcher();
$eventDispatcher->addSubscriber(new \yswery\DNS\Event\Subscriber\EchoLogger());
$eventDispatcher->addSubscriber(new \yswery\DNS\Event\Subscriber\ServerTerminator());

// Create a new instance of Server class
$config = null;
$storageDirectory = null;
$useFilesystem = false;
$ip = '127.0.0.1';
$port = 53;
$server = new yswery\DNS\Server($stackableResolver, $eventDispatcher, $config, $storageDirectory, $useFilesystem, $ip, $port);

// Start DNS server
$server->start();
```

<!--
$temp_file = tempnam(sys_get_temp_dir(), 'aaa');
\define('TEMP_RECORD_FILE', $temp_file);

register_shutdown_function(function(){
    if (is_file(TEMP_RECORD_FILE)) {
        unlink(TEMP_RECORD_FILE);
    }
});

$json = <<< EOF
{
    "shop-dev.theclub.com.hk": {
      "A": "127.0.0.1"
    }
}
EOF;
file_put_contents(TEMP_RECORD_FILE, $json);
// ipconfig /flushdns
// php localhost.php

// JsonResolver created and provided with path to file with json dns records
$jsonResolver = new yswery\DNS\Resolver\JsonResolver([TEMP_RECORD_FILE]);
-->

1. 这是启动的命令，可以把这个命令保存在一个用于启动的脚本文件
<!-- startup.bat startup.sh -->
```
php startup.php
```

1. 修改网卡的 dns 配置
<!-- 一般情况下 主DNS 访问失败时才会访问 备用DNS ，查询没有结果不算访问失败 -->

1. 可以用这样的命令来测试是否生效，如果没有生效可以尝试刷洗 dns 缓存
```
nslookup -debug -querytype=A -port=53 test.localhost.com 127.0.0.1
```

1. 如何写配置文件可以参考仓库里的文档或参考 example 里的文件

1. 如果不把设为服务，则每次开机后都要手工启动一次

## 在本地使用 unbound 搭建一个 DNS 服务

笔者原本是想用php的库来建一个本地的dns服务，但找了很久都没找到合适的，最后还是选择用 unbound ，
和 bind 相比， unbound 提供了免编译免安装的版本。

使用的是 v1.19.0 版本

1. unbound 的仓库
```
https://github.com/NLnetLabs/unbound
```

1. unbound 的文档
```
https://unbound.docs.nlnetlabs.nl/en/latest/index.html
```

1. 下载 unbound
```
https://nlnetlabs.nl/projects/unbound/download/
```

1. 下载完后，解压，然后复制一份配置文件
```
cp example.conf unbound.conf
```

1. 修改配置文件，整个配置文件非常大，在特定位置改好这几项就好了
```
# 设置日志文件的路径，默认情况下会使用 syslog
logfile: unbound.log

use-syslog: no

interface: 127.0.0.1

local-data: "test.localhost.com A 127.0.0.1"

forward-zone:
	name: "."
	forward-addr: 系统原本的主dns地址
	forward-addr: 系统原本的备用dns地址

```

1. 检测配置文件
```
unbound-checkconf unbound.conf
./unbound-checkconf.exe unbound.conf
```

1. 运行
```
# 在前台运行
unbound -vv -c unbound.conf
./unbound.exe -vv -c unbound.conf

# 在后台运行
unbound -d -vv -c unbound.conf
./unbound.exe -d -vv -c unbound.conf
```

<!-- unbound 如何设置 DNS-over-HTTPS？ -->

## powershell 的使用经验

### 无法执行 powershell 脚本

通常是执行策略的原因导致的。

设置脚本执行策略，通常把 策略 设为 RemoteSigned 就可以了
```
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine
```

查看 powershell 脚本执行策略
```
Get-ExecutionPolicy
Get-ExecutionPolicy -List
```

https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2

### 判断变量的类型
    ```
    $variable.GetType()
    ```
### 获取变量的属性和方法
    ```
    $variable | Get-Member
    ```
### 加载程序集
### 使用 win32api 或 c++的库

<!--

Add-Type -TypeDefinition
    https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/add-type
DllImport 和 LibraryImport
    如果可能，在面向 .NET 7+ 时，请使用 [LibraryImport]
    在某些情况下，使用 [DllImport] 是合适的
    https://learn.microsoft.com/zh-cn/dotnet/standard/native-interop/pinvoke
    https://learn.microsoft.com/zh-cn/dotnet/standard/native-interop/best-practices
    https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.dllimportattribute
    https://learn.microsoft.com/zh-cn/dotnet/standard/native-interop/abi-support

脚本(script) 函数(Functions) 模块(Module) cmdlet 程序集(Assembly) 这几个的区别？
    脚本 函数 模块 都是 ps 代码
    cmdlet 和 Assembly 则是编译后的 dll文件 （虽然理论上可以用其它语言（C++ VB F#），但绝大部分情况下都是 C#）
        cmdlet 只能用在 powershell 里
        Assembly 可以用在其它 .net 程序里
如何区分一个类是 powershell 原本的类 还是 .NET 的类？
    原本的类 就是 cmdlet
        https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_core_commands
    .NET 的类就是 GetType().FullName 返回值里没有 __ComObject 的
        com 对象 (New-Object -ComObject WScript.Shell).GetType().FullName
        .NET 的类 (Get-Date).GetType().FullName
    但 cmdlet 或 Assembly 都是可以自行增加的，也可以通过包管理工具怎加第三方的
如何通过字符串执行 powershell 命令？
    PowerShell -command $GIT_COMMAND
    Invoke-Expression $GIT_COMMAND

列出当前可用的 cmdlet
Get-Command -CommandType Cmdlet

列出已加载的 Assembly
[System.AppDomain]::CurrentDomain.GetAssemblies()

列出当前可以用的类，这里会输出超级多的类
[System.AppDomain]::CurrentDomain.GetAssemblies() | ForEach-Object { $_.GetTypes() } 

msdn 的文档虽然很丰富，但感觉很多概念依然很模糊

powershell 转换为 exe
    ps12exe https://github.com/steve02081504/ps12exe
    PS2EXE https://github.com/MScholtes/PS2EXE
    PowerShell脚本编译成EXE https://www.pstips.net/convert-ps1toexe.html
    可以用 IExpress ，把脚本打包成一个自解压的文件
    据说 PowerShell ISE 也可以直接把脚本转换成 exe ，但我的电脑的 ISE 却没有这个选项
        PowerShell ISE 也不再积极开发了
        https://learn.microsoft.com/zh-cn/powershell/scripting/windows-powershell/ise/introducing-the-windows-powershell-ise
        新版的 powershell 通过这个 vsc 扩展提供支持 https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
-->

### powershell 转换成 exe
### powershell 的优缺点
优点
- 从语法的角度看， powershell 比 bash 和 bat 都要好不少
- 在 windows 环境下可以间接调用 windows api

缺点
- 十分依赖 .NET
- 管道传递的是对象，不像 bash 那样传递字节
- 版本十分混乱
- 虽然默认情况下 windows 都有安装 powershell ，但默认情况下是不能执行 powershell 脚本的

## adminer 设置 sqlite 的密码访问

1. 下载 adminer
    ```
    php -r "copy('https://github.com/vrana/adminer/releases/download/v5.4.1/adminer-5.4.1.php', 'adminer.php');"
    ```
1. 新建一个 sqlite 库（如果已经有db文件，忽略这一步）
    ```
    php -r "print((new SQLite3('test.db'))->querySingle('SELECT SQLITE_VERSION()'));"
    ```
1. 在 adminer.php 的同级目录下新建一个目录 adminer-plugins
    ```
    mkdir adminer-plugins
    ```
1. 在 adminer-plugins 目录下新建一个文件 login-password-less.php ，并写入以下内容
    ```
    touch login-password-less.php
    vi login-password-less.php
    ```
    ```php
    <?php

    /** Enable login without password
    * @link https://www.adminer.org/plugins/#use
    * @author Jakub Vrana, https://www.vrana.cz/
    * @license https://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0
    * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License, version 2 (one or other)
    */
    class AdminerLoginPasswordLess extends Adminer\Plugin {
        protected $password_hash;

        /** Set allowed password
        * @param string $password_hash result of password_hash()
        */
        function __construct($password_hash) {
            $this->password_hash = $password_hash;
        }

        function credentials() {
            $password = Adminer\get_password();
            return array(Adminer\SERVER, $_GET["username"], (password_verify($password, $this->password_hash) ? "" : $password));
        }

        function login($login, $password) {
            // if ($login == 'admin' && $password == '') {
            // 	return true;
            // } else {
            // 	return false;
            // }
            if ($password != "") {
                return true;
            }
        }

        protected $translations = array(
            'cs' => array('' => 'Povolí přihlášení bez hesla'),
            'de' => array('' => 'Ermöglicht die Anmeldung ohne Passwort'),
            'pl' => array('' => 'Włącz logowanie bez hasła'),
            'ro' => array('' => 'Activați autentificarea fără parolă'),
            'ja' => array('' => 'パスワードなしのログインを許可'),
        );
    }
    ```
1. 在 adminer.php 的同级目录下新建一个一个文件 adminer-plugins.php ，并写入以下内容
    ```
    touch adminer-plugins.php
    vi adminer-plugins.php
    ```
    ```php
    <?php // adminer-plugins.php
    return array(
        // new AdminerLoginPasswordLess('$2y$07$Czp9G/aLi3AnaUqpvkF05OHO1LMizrAgMLvnaOdvQovHaRv28XDhG'),
        new AdminerLoginPasswordLess(password_hash("PASSWORD", PASSWORD_DEFAULT)),
        // You can specify all plugins here or just the ones needing configuration.
    );
    ```
1. 
1. 参考
    - https://www.adminer.org/en/password/
    - https://github.com/vrana/adminer/blob/master/plugins/login-password-less.php
    - https://github.com/vrana/adminer/blob/master/adminer/sqlite.php

## linux 的使用经验

## git 的使用经验
<!--
四个工作空间
    工作区(Workspace)
    暂存区(Index/Stage)
    本地仓库(Repository)
    远程仓库(Remote)
分支
标签
查看状态
日志
贮藏(stash)
对比文件
配置
打包
githook
    客户端hook
    服务端hook
git服务
-->

## symfony/rate-limiter 的使用经验

```php
<?php

require 'vendor/autoload.php';

use Symfony\Component\RateLimiter\Storage\InMemoryStorage;
use Symfony\Component\RateLimiter\RateLimiterFactory;

use Symfony\Component\RateLimiter\Storage\StorageInterface;
// use Psr\Cache\CacheItemPoolInterface;
use Symfony\Component\RateLimiter\LimiterStateInterface;


class FileStorage implements StorageInterface
{
    public function save(LimiterStateInterface $limiterState): void
    {
        file_put_contents($limiterState->getId(), serialize($limiterState));
    }

    public function fetch(string $limiterStateId): ?LimiterStateInterface
    {
        if (!file_exists($limiterStateId)) {
            return null;
        }

        $limiterState = unserialize(file_get_contents($limiterStateId));
        $expireAt = $this->getExpireAt($limiterState);
        if (null !== $expireAt && $expireAt <= microtime(true)) {
            $this->delete($limiterStateId);
            return null;
        } else if (null === $expireAt) {
            $this->delete($limiterStateId);
            return null;
        }

        return $limiterState;
    }

    public function delete(string $limiterStateId): void
    {
        if (!file_exists($limiterStateId)) {
            return;
        }

        unlink($limiterStateId);
    }

    private function getExpireAt(LimiterStateInterface $limiterState): ?float
    {
        if (null !== ($expireSeconds = $limiterState->getExpirationTime())) {
            return microtime(true) + $expireSeconds;
        }

        return null;
    }
}

$factory = new RateLimiterFactory([
    'id' => 'login',
    'policy' => 'fixed_window',
    'limit' => 20,
    // 'rate' => ['interval' => '15 minutes'],
    'interval' => '60 seconds',
], new FileStorage());

$limiter = $factory->create('id');

$rateLimit = $limiter->consume();
if (!$rateLimit->isAccepted()) {
    // header('');
    http_response_code(429);
    echo 'Too Many Requests';
} else {
    echo 'OK';
}
echo PHP_EOL;
try {

    // var_dump(file_exists('login-id'));
    // $limiterState = unserialize(file_get_contents('login-id'));
    // var_dump(get_class($limiterState));
    $limiterState = (new FileStorage())->fetch('login-id');
    echo $limiterState->getId();
    echo PHP_EOL;
    echo $limiterState->getExpirationTime();
    echo PHP_EOL;
} catch(\Throwable $e) {
    echo $e->getMessage();
    echo PHP_EOL;
}

exit(0);

/*

composer require symfony/rate-limiter:6.4

PHP_CLI_SERVER_WORKERS="10" php -S 0.0.0.0:8080

curl http://127.0.0.1:8080/ratelimiter.php

echo $(for i in $(seq 1 10); do echo curl -o /dev/null -s -w %{http_code}, http://127.0.0.1:8080/ratelimiter.php; echo ";";done ) | \
xargs -d ";" -n 1 -P 2 bash -c '$0' | \
sed 's/,/\n/g'

如何改用 redis 或其它存储？
这个组件在 Symfony 里是如何使用的？

*/
```

## 那些能作为工具的网站

- 能查看到编译的汇编代码
    https://gcc.godbolt.org/
- 能在线运行 php 代码，能一次运行多个版本
    - https://3v4l.org/
    - https://onlinephp.io/
    - https://phphub.net/sandbox/
- 一个能生成 curl 命令的网站，在开发的时候十分有用，特别是测试第三方接口的时候
    https://reqbin.com/
- 在线的 svg 编辑器
    https://c.runoob.com/more/svgeditor/
- 把svg转换成 url的编码
    https://yoksel.github.io/url-encoder/
- SVG 工具
    https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Tools_for_SVG
- 可视化的正则表达式
    - https://jex.im/regulex/
    - https://www.debuggex.com/
    - https://regexper.com/
    - https://regex101.com/
    - https://regexr.com/
    - https://pythonium.net/regex
- ASCII 画图
    https://asciiflow.com/
- 百度翻译能直接复制图片，并识别出文字
- 临时上传图片用的
    - http://ipaiban.com/bianji
- 文本压缩，去除空行和多余的空格
    http://www.wuqianling.top/software/notepad/compress.html
- url 编码
    - 因此当你需要编码整个 URL，就用 encodeURI。
    - 如果只需要编码 URL 中的参数时，就使用 encodeURIComponent。
    - https://www.iamwawa.cn/urldecode.html
- graphql 格式化
    https://verytoolz.com/graphql-formatter.html
- 在线的剪切板
    - https://pastebin.com/
    - https://paste.centos.org/
    - https://paste.debian.net/
    - https://pastebin.mozilla.org/
    - https://github.com/PrivateBin/PrivateBin
    - https://github.com/DarrenOfficial/dpaste
    - https://github.com/lovasoa/whitebophir
- 工具网站的集合
    - https://c.runoob.com/
    - https://tool.oschina.net/
- 各种 jdk 的下载渠道
    https://www.injdk.cn/
- 英文缩略词查询
    https://www.abbreviationfinder.org/cn/
- 在线 ps
    - https://www.photopea.com/
    - https://pixlr.com/
- 拯救词穷的字典。由清华大学 NLP 实验室开源，可以根据你的意思返回相关词汇，有效解决词穷、话到嘴边说不出来的窘境。
    - https://wantwords.net/
    - https://github.com/thunlp/WantWords
- 用于查看 winapi 里的各种结构体，以及各个 Windows 版本的差异
    http://terminus.rewolf.pl/terminus/
- 微软的数学求解器
    https://mathsolver.microsoft.com/
- 由 google 提供的在线调试工具
    https://toolbox.googleapps.com/apps/main/
- 网页快照
    - https://web.archive.org/save
    - http://archive.is/


<!--

查看硬盘容量
df -h

du -hs $(ls -A)

修改 root 密码
sudo passwd

查看当前网桥网络
docker network ls
创建用户定义的网桥网络
docker network create my-net
删除用户定义的网桥网络
docker network rm my-net
连接容器与用户定义的网桥的连接
docker network connect my-net my-nginx
断开容器与用户定义的网桥的连接
docker network disconnect my-net my-nginx
查看网络的信息
docker network inspect setting_default


docker pull mysql:8.0
docker pull phpmyadmin:5.2-apache
docker pull wordpress:6.7-php8.1-apache
docker pull php:7.4-apache

docker run --name mysqld --restart always -d \
    -e TZ="Asia/Shanghai" \
    -e MYSQL_ROOT_PASSWORD="123456" \
    -e MYSQL_DATABASE="wp" \
    -v `pwd`/mysql-data:/var/lib/mysql \
    mysql:8.0

docker run --name phpmyadmin -d \
    -e PMA_HOST=mysqld \
    -p 8081:80 \
    phpmyadmin:5.2-apache

docker run --name wordpress -d \
    -e WORDPRESS_DB_HOST=mysqld \
    -e WORDPRESS_DB_USER=root \
    -e WORDPRESS_DB_PASSWORD=123456 \
    -e WORDPRESS_DB_NAME=wp \
    -p 8080:80 \
    -v `pwd`/wordpress:/var/www/html \
    wordpress:6.7-php8.1-apache

docker exec -it wordpress /bin/bash

docker-php-ext-install pdo pdo_mysql mysqli

docker logs wordpress

docker network connect my-net phpmyadmin
docker network connect my-net mysqld
docker network connect my-net wordpress


-v /some/local/directory/config.user.inc.php:/etc/phpmyadmin/config.user.inc.php

echo "SetEnv HTTPS on" >> .htaccess
在 wp-config.php 的开头加上这两句
define( 'WP_HOME', 'https://8080-cs-285386365050-default.cs-asia-east1-vger.cloudshell.dev' ); 
define( 'WP_SITEURL', 'https://8080-cs-285386365050-default.cs-asia-east1-vger.cloudshell.dev' );
$_SERVER['HTTP_HOST'] = '8080-cs-285386365050-default.cs-asia-east1-vger.cloudshell.dev';
$_SERVER['HTTP_PORT'] = '80';


如果遇到不断重定向或重定向不正确的问题，可以尝试在这个位置打断点
wp-includes/pluggable.php
wp_redirect
print_r(debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS));
exit;

下载 wordpress 源码，可以修改最后的版本号或直接用 latest
https://wordpress.org/wordpress-6.8.2.tar.gz
https://wordpress.org/latest.zip

完全通过命令行的方式安装 wordpress
https://make.wordpress.org/cli/handbook/how-to/how-to-install/
https://developer.wordpress.org/cli/commands/config/create/
下载 wp-cli
创建 config.php 文件
创建数据库
运行安装命令

在 cloud shell 里修改文件要注意文件的权限
如果没有权限，可以先用 sudo chown 用户名 文件路径 改好权限，再修改文件，改完文件后要记得改回原本的权限

在 cloud shell 重启后，镜像和容器都会消失

vscode里安装这两个插件
Extension Pack for Java
Spring Boot Extension Pack

maven 镜像里已经包含jdk了
docker pull maven:3.9-eclipse-temurin-17-alpine
这是对应的 jdk 镜像 eclipse-temurin:17-jdk-alpine

docker run -it --rm --name my-maven-project -p 8080:8080 -v "$(pwd)":/usr/src/mymaven -w /usr/src/mymaven maven:3.9-eclipse-temurin-17-alpine mvn clean install


alias mvn='docker run -it --rm --name my-maven-project -p 8080:8080 -v "$(pwd)":/usr/src/mymaven -w /usr/src/mymaven maven:3.9-eclipse-temurin-17-alpine mvn'
使用这种别名的 mvn 就无法连贯地执行 mvn 命令

https://start.spring.io/
在这里选好 需要的组件，可以直接下载，也可以只复制 pom.xml 的内容
    最好还是用下载的 zip文件
    除了 pom.xml 还需要一些文件才能启动 springboot

如果springboot项目里没有代码，那么 pom.xml 里要加上这句
                <configuration>
                    <skip>true</skip>
                </configuration>
相对完整的例子
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>

安装依赖
mvn clean install
mvn clean install -X
    clean 清理项目构建目录
    install 完成代码编译、测试、打包后，将生成的构建产物（如 JAR/WAR 文件）安装到本地 Maven 仓库
    -X 是输出调试信息
    运行这句之后会在 target 文件夹下生成一个 jar 文件
        通过 jar 启动
        java -jar target/exportSystem-0.0.1-SNAPSHOT.jar
        使用指定端口号启动
        java -jar target/exportSystem-0.0.1-SNAPSHOT.jar --server.port=8083
        java -jar -Dserver.port=8083 target/exportSystem-0.0.1-SNAPSHOT.jar

启动
mvn spring-boot:run


最简单的
curl  -o demo.zip https://start.spring.io/starter.zip \
    -d type=maven-project \
    -d language=java \
    -d groupId=com.example \
    -d artifactId=demo \
    -d name=demo \
    -d packageName=com.example.demo \
    -d dependencies=web \
    -d javaVersion=17

加上 jpa 依赖的
curl  -o demo.zip https://start.spring.io/starter.zip \
    -d type=maven-project \
    -d language=java \
    -d groupId=com.example \
    -d artifactId=demo \
    -d name=demo \
    -d packageName=com.example.demo \
    -d dependencies=web,data-jpa \
    -d javaVersion=17

这种命令的依赖名可以通过 https://start.spring.io 的 share 获取，share 在 ... 那个按钮里

unzip demo.zip -d demo && cd demo

如果依赖里有 数据库 redis es 这类，要正确地填写好对应的配置，才能顺利启动 springboot

demo/src/main/java/com/example/demo/HelloController.java
    package com.example.demo;

    import org.springframework.web.bind.annotation.*;

    @RestController
    public class HelloController {
        @GetMapping("/hello")
        public String hello(@RequestParam(defaultValue = "World") String name) {
            return "Hello, " + name + "!";
        }
    }

还差很多东西
模板 认证和授权 会话管理 验证 orm 缓存 队列 命令行 全文搜索 邮件 日志 。。。。


下载源码
下载完后运行这句 git config core.filemode false
新建auth.json
    echo '{"github-oauth": {"github.com": "ghp_uvgdfgfwergwe"}}' | json_pp > auth.json
新建文件夹docker
    新建文件 touch dockerfile-php
    新建文件 touch docker-compose.yml
    新建文件 touch magento-site.conf
    新建文件 touch init.sh
    mkdir docker; \
    cd docker; \
    touch dockerfile-php; \
    touch docker-compose.yml; \
    touch magento-site.conf; \
    touch init.sh; \
    cd ..
构建镜像
安装 composer 依赖
    composer install
    composer require swissup/module-search-mysql-legacy --prefer-source --ignore-platform-reqs
运行安装命令

    php bin/magento deploy:mode:set developer
修改配置
    php bin/magento module:enable Swissup_SearchMysqlLegacy Swissup_Core
    php bin/magento config:set catalog/search/engine 'lmysql'

    不是apache环境就不用运行这句
    echo "SetEnv HTTPS on" >> pub/.htaccess

    php bin/magento config:set web/secure/base_url https://cloudshell.dev/
    php bin/magento config:set web/unsecure/base_url https://cloudshell.dev/
    php bin/magento config:set admin/url/use_custom_path 0
    php bin/magento config:set web/seo/use_rewrites 0
    php bin/magento config:set web/cookie/cookie_domain cloudshell.dev

    php bin/magento config:show web/secure/base_url;
    php bin/magento config:show web/unsecure/base_url;
    php bin/magento config:show admin/url/use_custom_path;
    php bin/magento config:show web/seo/use_rewrites;
    php bin/magento config:show web/cookie/cookie_domain;

运行构建命令
    rm -rf var/di/* var/generation/* var/cache/* var/page_cache/* var/view_preprocessed/* var/composer_home/cache/*  var/tmp/* && \
    rm -rf generated/code/* generated/metadata/* pub/static/* ; \
    php bin/magento setup:upgrade; \
    php bin/magento setup:di:compile; \
    php bin/magento setup:static-content:deploy -f; \
    php bin/magento indexer:reindex; \
    php bin/magento cache:flush; \
    chown root:root -R /var/www/html/var && chmod 777 -R /var/www/html/var; \
    chown root:root -R /var/www/html/pub && chmod 777 -R /var/www/html/pub;
修改文件
    app/code/Magento/Backend/App/Area/FrontNameResolver.php isHostBackend 后台不要404
    app/code/Magento/Store/Model/BaseUrlChecker.php execute 前台不要302
    lib/internal/Magento/Framework/App/Router/Base.php _checkShouldBeSecure 前台不要302，
        这是只有cli server才需要改的，这是因为 cli server 无法通过环境变量来修改 $_SERVER ，其实只要 $_SERVER['HTTPS']=on 就不用改这句了
        原来可以直接修改 $_SERVER['HTTPS']=on;
        可以在 phpserver/router.php 里直接加上 $_SERVER['HTTPS']=on;


php bin/magento varnish:vcl:generate --access-list phpapache --backend-host phpapache --backend-port 80 --export-version 6 --grace-period 300 --output-file default.vcl

虽然没有redis，但速度并不慢


docker run \
    --name test1 \
    -it \
    --rm \
    -w /root \
    -v `pwd`:/root \
    debian:12 /bin/bash

docker exec -it test1 /bin/bash

curl -L -o yourls-1.9.2.tar.gz https://github.com/YOURLS/YOURLS/archive/refs/tags/1.9.2.tar.gz
curl -L -o yourls-1.7.2.tar.gz https://github.com/YOURLS/YOURLS/archive/refs/tags/1.7.2.tar.gz
curl -L -o yourls-1.7.2.zip https://github.com/YOURLS/YOURLS/archive/refs/tags/1.7.2.zip

tar -xzf yourls-1.9.2.tar.gz
tar -xzf yourls-1.7.2.tar.gz
tar  --lzip -xf yourls-1.7.2.zip

<?php
// 获取请求路径并解析可能的查询参数
$requestUri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$filePath = $_SERVER['DOCUMENT_ROOT'] . $requestUri;

// 检查是否为真实文件或目录
if (!file_exists($filePath) || is_dir($filePath)) {
    // 非真实文件/目录，交由 yourls-loader.php 处理
    require __DIR__ . '/yourls-loader.php';
} else {
    return false;
    $extension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));
    if ($extension == 'php') {
        require $filePath;
        exit;
    } else {
        return false;
    }
}


    // 直接输出静态文件内容
    $mimeType = mime_content_type($filePath);
    $extension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));
    if ($extension == 'php') {
        require $filePath;
        exit;
    } else if ($extension == 'js') {
        $mimeType = 'application/javascript';
    } else if ($extension == 'css') {
        $mimeType = 'text/css';
    }
    // if ($mimeType == 'text/x-php') {
    //     require $filePath;
    //     exit;
    // }
    header("Content-Type: {$mimeType}");
    readfile($filePath);
    exit;

PHP_CLI_SERVER_WORKERS="10" php -S 127.0.0.1:80 router.php


docker pull yourls:1.9.2-apache

docker run --name some-yourls \
    -e YOURLS_SITE="https://example.com" \
    -e YOURLS_USER="example_username" \
    -e YOURLS_PASS="example_password" \
    -e YOURLS_DB_HOST=10.1.2.3:3306 \
    -e YOURLS_DB_USER= \
    -e YOURLS_DB_PASS= \
    -d yourls:1.9.2-apache

在 centos7.6 安装 apache2.4.6 和 php8.1

docker run \
    --name test1 \
    -it \
    --rm \
    centos:7.6.1810 /bin/sh

更换yum源
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
yum -y update

安装一些必要的依赖
yum install -y gcc gcc-c++ make autoconf automake pkg-config

export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig/
pkg-config --variable pc_path pkg-config


curl -L -O http://download.libsodium.org/libsodium/releases/libsodium-1.0.18-stable.tar.gz
tar -xzf libsodium-1.0.18-stable.tar.gz
cd libsodium-stable
./configure --prefix=/usr/local/libsodium
make && make check
make install

cp /usr/local/libsodium/lib/pkgconfig/libsodium.pc /usr/share/pkgconfig/libsodium.pc

/usr/share/pkgconfig 这个路径是通过这个命令找到的
pkg-config --variable pc_path pkg-config

用这个命令来检查 libsodium 有没有顺利地安装
pkg-config --modversion libsodium



安装 apache2.4.6
yum install -y httpd-2.4.6 httpd-devel

安装 php8.1 需要的依赖
yum install -y libxml2-dev
yum install -y openssl-devel
yum install -y sqlite-devel
yum install -y bzip2-devel
yum install -y gmp-devel
yum install -y libicu-devel
yum install -y http://down.24kplus.com/linux/oniguruma/oniguruma-devel-6.7.0-1.el7.x86_64.rpm
yum install -y http://down.24kplus.com/linux/oniguruma/oniguruma-6.7.0-1.el7.x86_64.rpm
yum install -y readline-devel
yum install -y libxslt-devel
yum install -y curl curl-devel

php的mbstring的正则表达式功能需要oniguruma

安装php8.1
curl -L -O https://www.php.net/distributions/php-8.1.32.tar.gz
tar -xzf php-8.1.32.tar.gz
cd php-8.1.32
./configure \
    --prefix=/usr/local/php \
    --with-config-file-path=/usr/local/php \
    --enable-bcmath \
    --with-curl \
    --enable-mbstring \
    --with-mysqli \
    --with-pdo-mysql \
    --with-openssl \
    --enable-sockets \
    --enable-soap \
    --enable-intl \
    --with-zlib \
    --enable-opcache \
    --with-bz2 \
    --enable-pcntl \
    --enable-sysvsem \
    --enable-sysvshm \
    --enable-sysvmsg \
    --with-iconv \
    --with-readline \
    --with-pdo-sqlite \
    --with-sqlite3 \
    --with-xsl \
    --enable-shmop \
    --with-gettext \
    --with-gmp \
    --with-sodium \
    --with-apxs2=/usr/bin/apxs
make && make test
make install
cp php.ini-development /usr/local/php/php.ini

sed -i "s/;zend_extension=opcache/zend_extension=opcache/" /usr/local/php/php.ini


这四个命令通常用于编译和安装软件，尤其是在使用 `Makefile` 的项目中。它们的区别和连携如下：

1. **configure**：
   - 这个命令通常用于准备软件的构建环境。它会检查系统的环境和依赖项，生成适合当前系统的 `Makefile`。在执行 `configure` 时，用户可以指定一些选项来定制构建过程，比如安装路径、启用或禁用某些功能等。

2. **make**：
   - 这个命令会根据 `Makefile` 中的指令编译源代码。它会调用编译器（如 `gcc`）来生成可执行文件或库。`make` 会自动处理文件之间的依赖关系，只重新编译那些自上次编译以来发生变化的文件。

3. **make test**：
   - 这个命令通常用于运行项目的测试套件。它会执行在 `Makefile` 中定义的测试目标，确保软件在安装之前能够正常工作。并不是所有的项目都有这个目标，具体取决于开发者是否在 `Makefile` 中定义了测试相关的规则。

4. **make install**：
   - 这个命令会将编译好的程序和相关文件复制到系统的指定位置（通常是 `/usr/local/bin`、`/usr/local/lib` 等）。这个步骤通常需要管理员权限，因为它涉及到对系统目录的写入。

### 关系：
- 通常的工作流程是先运行 `configure`，然后运行 `make` 来编译代码，接着可以选择运行 `make test` 来验证编译结果，最后使用 `make install` 将软件安装到系统中。
- 这些命令的执行顺序是有意义的，确保在安装之前软件是经过编译和测试的，从而减少安装后出现问题的可能性。


chown root:root -R /root/YOURLS-1.9.2 && chmod 777 -R /root/YOURLS-1.9.2; 
chown root:root -R /root && chmod 777 -R /root; 
sudo chown www-data:www-data -R /root/m2 && sudo chmod 777 -R /root/m2;

--enable-cli 和 --enable-cgi 同时默认有效
--disable-cgi 没有这个编译参数，就能生成 php-cgi

编译php需要加上--enable-fpm这个参数才会有php-fpm


编译php需要加上 --with-apxs2=/usr/bin/apxs 才会有 apache 的模块
寻找 apxs 的路径
find / -name apxs
apxs 是通过 httpd-devel 安装的


docker run     --name test1     -it  --add-host="host.docker.internal:host-gateway"   --rm     -w /root     -v `pwd`:/root     debian:12 /bin/bash

--add-host="host.docker.internal:host-gateway" 加上这一句确实可以 通过 host.docker.internal 访问宿主机，但宿主机的服务必须是绑定 0.0.0.0 这个地址

文件管理 https://github.com/prasathmani/tinyfilemanager
    git clone -b 2.6 --single-branch --no-tags https://github.com/prasathmani/tinyfilemanager.git --depth=1 tinyfilemanager
终端 https://github.com/tsl0922/ttyd
vscode
一个统一的页面

docker run \
    --name test1 \
    -it \
    --rm \
    -w /root \
    -v `pwd`:/root \
    -p 8080:8080 \
    --add-host="host.docker.internal:host-gateway" \
    debian:12 /bin/bash

sudo apt-get update
sudo apt-get install -y build-essential cmake git libjson-c-dev libwebsockets-dev
git clone https://github.com/tsl0922/ttyd.git
cd ttyd && mkdir build && cd build
cmake ..
make && sudo make install

ttyd --writable -c admin:passwd -p 8080 bash

mypanel
    git clone https://github.com/mypanel/mypanel.git --depth=1 mypanel
    ./init.sh
        dockerfile-php-apache
服务器管理面板的功能
    应用商店
    查看系统状态
    定时任务
    systemd
    脚本管理
    文件管理
    docker
    警报
    webhook
    进程
        当前进程
        守护进程
    防火墙
    waf
    ftp
    邮局
    网站
    数据库
    日志
        面板日志
        ssh登录日志
        网站日志
        系统日志
    设置
就是要把命令行变成可视化的界面
安装要方便，
依赖要少，
最好能兼容多种系统


先修改 root 密码 sudo passwd
再切换到 root 用户 su root
再切换到 root 根目录 cd
docker run -d -e OLLAMA_ORIGINS="*" -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama
docker exec -it ollama ollama run llama3.2

OLLAMA_ORIGINS="*" 设置这个环境变量是为了避免跨域限制，这是不安全的

在 Mac 上，可以通过运行以下命令找到日志：
cat ~/.ollama/logs/server.log

在 Linux 系统中使用 systemd 时，可以使用以下命令查找日志：
journalctl -u ollama --no-pager

当你在 容器 中运行 Ollama 时，日志会输出到容器的 stdout/stderr：
docker logs <container-name>


拉取模型
curl http://localhost:11434/api/pull -d '{
  "model": "deepseek-r1:1.5b"
}'
curl http://localhost:11434/api/pull -d '{
  "model": "phi4-mini:3.8b"
}'

phi4-mini:3.8b

deepseek-r1:7b
deepseek-r1:8b

删除模型
curl -X DELETE http://localhost:11434/api/delete -d '{
  "model": "deepseek-r1:7b"
}'


模型列表
curl http://localhost:11434/api/tags

模型详细信息
curl http://localhost:11434/api/show -d '{
  "model": "deepseek-r1:1.5b"
}'

当前运行的模型
curl http://localhost:11434/api/ps

curl http://localhost:11434/api/generate -d '{
    "model": "deepseek-r1:1.5b",
    "prompt":"Why is the sky blue?",
    "stream": false
}'

curl http://localhost:11434/api/chat -d '{
  "model": "deepseek-r1:1.5b",
  "messages": [
    {
      "role": "user",
      "content": "why is the sky blue?"
    }
  ],
  "stream": false
}'

ollama 的 api 大致分为两种
completion 和 chat completion
两个接口的参数大致相同
completion 用的是 prompt
chat completion 用的是 messages
    "messages": [
        {"role":"system", "content":""},
        {"role":"user", "content":""},
        {"role":"assistant", "content":""},
    ]
    role 区别
        system 设定 AI 的行为，角色，背景
        user 用户的输入
        assistant ai 的输出
completion 也可以称为 text completion
completion 是一次性的，生成长文本这类可以用 completion
多轮对话要用 chat completion
如果只有一轮对话 completion 和 chat completion 区别应该不大

completion 补全



docker run -d -p 8081:8080 -e OLLAMA_BASE_URL=http://localhost:11434 -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main

docker run --rm -d -p 8081:4173 --name hollama ghcr.io/fmaclen/hollama:latest

git clone https://github.com/ollama-ui/ollama-ui
cd ollama-ui
make download_resources
python3 -m http.server --bind 127.0.0.1 8082

vi api.js
, {credentials: 'include'}

-->
