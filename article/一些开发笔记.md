一些开发笔记
================================

## 在 VSCode 里调试 JAVA
1. 安装 JDK
2. 把 JDK 添加进环境变量
3. 安装 VSCode 的 JAVA extension pack 拓展
4. 使用 VSCode 打开文件夹
5. 新增一个 debug 的类型 JAVA ，点击右下角的添加配置，选择 JAVA Lanuch Program
6. 写一份测试的代码，并在 mian 函数加个断点
10. 然后在终端里运行编译命令和运行命令，如果编译命令不复杂，可以配合 code runner 拓展，直接点击右上角的运行图标，或设置一个任务

## 在 VSCode 里调试 Python
1. 安装 Python
2. 把 Python 的安装目录和安装目录下的 script 添加进环境变量里
3. 在 VSCode 安装 Python 拓展（ microsoft 出品的）
4. 新增一个 debug 的类型 Python ，点击右下角的添加配置，选择 Python: Terminal (integrated)
5. 写一份测试的代码，并加个断点
6. 然后在终端里运行，可以配合 code runner 插件，直接点击右上角的运行图标，或设置一个任务

## 在 Windows10 里修改 administrator 帐号的帐号名的三种方式
1. 通过管理里的系统工具修改
```
选中桌面中的计算机图标，右键，点击管理
系统工具
    本地用户和组
        用户
            选中Administrator，然后重命名
重启电脑
```

2. 通过策略租修改
```
win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
    windows设置
        安全设置
            本地策略
                安全选项
                    拉到最下面
                    双击这个选选项 重命名系统管理员帐户
重启电脑
```

3. 通过 netplwiz (Network Places Wizard) 网上邻居向导 修改
```
win+r 打开运行
输入 netplwiz
选中Administrator，然后双击，然后修改
重启电脑
```

## Windows10 无密码远程连接
1. 允许任何远程着桌面的连接
2. 修改 Windows 的安全策略，允许远程桌面连接使用空密码
```
win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
    windows 设置
        安全设置
            本地策略
                安全选项
                    拉到最下面
                    禁用 使用空密码的本地账户只允许控制台登录
```


- 电脑提示“账户名与安全标识间无任何映射完成”
一般是修改玩用户名后没有重启导致的。

- 因为公司的电脑不能设密码，同时我又想远程桌面公司的电脑，考虑到安全问题，不能用默认用户名裸奔，所以修改用户名和设置无密码的远程桌面


## ss 的使用
1. 购买一个在 wall 以外的服务器
1. 下载 python
1. 安装 python
1. 把 python 添加到环境变量
1. 刷新环境变量
1. 下载 ss
    ```shell
    python -m pip install shadowsocks
    # 如果上面那句下载失败，可以尝试用这句安装
    python -m pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
    # 如果上面那句还是下载失败，可以尝试先把 master.zip 文件下载到本地，再安装
    ```
1. 在服务器的策略组放行相应的端口
1. 在防火墙放行相应的端口
1. 运行以下命令
    ```shell
    ssserver -p 61813 -k windows@163.qq -m aes-256-cfb
        -p 是端口号
        -k 是密码
        -m 是加密方式
    上面那条命令需要在 服务器的策略组 和 防火墙 放行 61813 端口
    ```
1. 下载客户端
1. 正确填写 ip 端口 密码
1. 一些加密的算法会依赖这个库 libsodium ，最好把这个库也装上
    ```
    https://download.libsodium.org/libsodium/releases/
    ```
1. 更新 ss
    ```
    python -m pip install --upgrade shadowsocks
    # 如果上面那句更新失败，可以尝试这样更新，先卸载再重新安装，卸载前记得先备份当前的版本
    python -m pip show shadowsocks
    python -m pip uninstall shadowsocks
    python -m pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
    ```
1. 失效时，可以尝试，更改端口，更改密码，更改加密方式，换一个ip
1. 参考
    ```plaintext
    https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E
    ```

## VS 和 VC 库 的对应关系

|||
|-|-|
|Visual Studio 6.0|VC6|
|Visual Studio .NET 2002|VC7.0|
|Visual Studio .NET 2003|VC7.1|
|Visual Studio 2005|VC8|
|Visual Studio 2008|VC9|
|Visual Studio 2010|VC10|
|Visual Studio 2012|VC11|
|Visual Studio 2013|VC12|
|Visual Studio 2015|VC14|
|Visual Studio 2017|VC15|
|Visual Studio 2019|VS16|
|Visual Studio 2022|VS17|

- Visual C++ 6.0 是 Visual Studio 6.0 的一部分，但可以独立安装
- 从 VC10 开始才有 64位

## php 版本和 VC 库的对应关系

|||
|-|-|
|5.2|vc6|
|5.3|vc9|
|5.4|vc9|
|5.5|vc11|
|5.6|vc11|
|7.0|vc14|
|7.1|vc14|
|7.2|vc15|
|7.3|vc15|
|7.4|vc15|
|8.0|vs16|

- 其实下载下来的压缩包名有写着对应的 vc 库，系统位数， ts 和 nts

## Windows 里的脚本语言

- bat
- VBScript
- JScript
- PowerShell

## 如何不使用浏览器在 windows 里下载文件

使用 Windows 自带的程序

- ftp
- tftp
- sftp
- telnet
- webdav
- smb (就是网上邻居共享那种)
- nfs
- 用远程桌面
- 用 windows 商店
- 用 winget
- 用 系统自带的邮件 接收邮件的附件
- certutil
- bitsadmin
- 直接在 cmd 里 `start 下载地址`
    - 这其实会调用 ie 的，但实际上即使系统里没有浏览器大概率也能用， ie 作为系统组件很难删干净的
    - 其实直接在文件管理的地址栏输入 下载地址 也是可以的，也是调用 ie
- powershell
    - `(new-object System.Net.WebClient).DownloadFile('https://www.php.net/distributions/php-7.4.9.tar.gz', 'E:/php-7.4.9.tar.gz')`
    - `Invoke-WebRequest -Uri 'https://www.php.net/distributions/php-7.4.10.tar.gz' -OutFile 'E:/php-7.4.10.tar.gz'`
    - Start-BitsTransfer
        ```
        Start-BitsTransfer -Source "<File URL>" -Destination "<File Name>"
        Start-BitsTransfer -Source "https://www.unicode.org/Public/UNIDATA/Unihan.zip" -Destination "Unihan.zip"
        ```
    - 用 powershell 远程登录，然后再拷贝文件， new-PSSession 和 Copy-Item 两个命令配合
    - 这几个都可以勉强算是下载文件
        - Install-Module
        - Install-Script
        - Install-Package
- .net
    - 一些版本的 Windows 会自带 .net ，这样也可以调用 .net 的库来下载文件
- VBScript JScript mshta 等调用 Microsoft.XMLHTTP
- 通过 光驱 u盘 移动硬盘 等。。。
- 用心探索一下 windows 里很多自带的服务都能下载文件
    - wmic Rundll32 Regsvr32 Cmstp msiexec MSBulid odbcconf
    - 传说一些版本的 Windows Defender 也可以下载文件

## Windows 安全地删除U盘

U盘 弹出失败的原因是进程占用了 U盘 ，只要占用 U盘 的进程都不在占用 U盘 或 都结束了， U盘 就可以安全地弹出了。

所以，让 U盘 安全地弹出的关键是找到占用 U盘 的进程。

当占用 U盘 的进程结束后，有时立即弹出 U盘 还是会失败的，这时再等待五六秒，再试一次弹出 U盘 就可以了。

可以安全退出 U盘 时也不要马上拔 U盘 ，最好等个五六秒再拔 U盘 。

这是各种方法的总结
1. 最简单的，在系统托盘右键，弹出，或在此电脑的界面，选中 U盘，右键，弹出
1. 关掉所有文件夹再试一次弹出 U盘
1. explorer.exe 重启，再试一次弹出 U盘
1. 注销当前的登录，再次登录，再试一次弹出 U盘
1. 通过任务管理器找到占用 U盘 的进程
    1. 打开任务管理器
    1. 切换到性能页面
    1. 打开资源监视器
    1. 切换到 cpu 页面
    1. 在 关联的句柄 栏目的搜索框内输入你的 U盘 盘符（如G:\）
    1. 即可看到当前占用 U盘 的进程
1. 关闭 U盘 的写入缓存
    1. 控制面板
    1. 管理工具
    1. 计算机管理
    1. 设备管理
    1. 磁盘驱动
    1. 选择当前的 U盘
    1. 右键 属性 策略
    1. 关闭写缓存
    1. 关闭写缓存可能会造成 U盘 数据的丢失，关闭了写缓存后，要确保 U盘 里的文件已经保存好再弹出 U盘
1. 在磁盘管理里使 U盘 脱机
    1. 控制面板
    1. 管理工具
    1. 磁盘管理
    1. 选择当前的 U盘
    1. 右键 脱机
    1. U盘 脱机后下次插入要重新挂载，脱机之后可以马上联机，再安全弹出，这样 U盘 下次插入时就不用联机了
    1. 脱机会直接关掉所有的文件句柄，要确保 U盘 里的文件已经保存好再脱机
    1. 脱机选项不可选，可能是有虚拟内存分配到 U盘 ，这时取消在 U盘 上的虚拟内存即可
        - 进入电脑属性->高级系统设置->高级->性能设置->高级->更改，关闭自动管理分页文件大小，取消在该磁盘上设置的虚拟内存
    1. 有时脱机还会失败，这时就继续参考下面的步骤
1. 通过 日志 查找占用 U盘 的进程
    1. 打开事件查看器
    1. windows日志
    1. 系统
    1. 找到最近的一条 来源 Kernel-PnP 的记录
    1. 记录的常规里有占用 U盘 的 进程id 的
    1. 再通过任务管理器的 pid 找到对应的进程
    1. 有时，即使找到占用 U盘 的进程，但却无法结束进程，或 进程是系统的核心进程
        - 这时可以尝试以这样的关键词（进程名 或 进程id + Kernel-PnP ）在网上搜索解决的方法
1. 如果是 Windows Defender 占用 U盘 可以试试这样操作
    1. 打开 Windows Defender 安全中心
    1. 病毒和威胁防护
    1. 病毒和威胁防护 设置
    1. 将在使用的 U盘 盘符添加为排除项
1. 最后的方法，关机，关机后就肯定可以安全地拔 U盘

笔者通常在直接弹出 U盘 失败后，会多试几次，然后通过 日志 找到对应的进程，然后通过 任务管理器 结束对应的进程，如果结束进程失败，还是会再次在网上搜索解决方法。
脱机 和 关闭写缓存都有一点副作用；
关闭文件夹，重启 explorer.exe ，注销，关机，这类都有点麻烦。

## windows 下的 linux 环境
- Git for Windows
- mingw
- mingw-w64
- TDM-GCC
- Cygwin
- MSYS
- MSYS2
- gnuwin
- windows10 子系统
    - wsl1
    - wsl2
- 虚拟机
    - VMware
    - VirtualBox
    - Hyper-V
    - qemu

## treminal tty console 和 shell

treminal ， tty ， console 是一开始都是硬件的概念。

一台电脑只有一个 console ，一般有电源开关等硬件操作的，
一台电脑可以有很多个 terminal 。
terminal 是负责 shell 的输入和输出。
console 也可以当作一个特殊的 terminal ，就是一个多了电源开关等硬件操作的 terminal 。
tty 是电传打印机。电传打印机是一种把键盘作为输入，纸带作为输出的硬件，是一种 terminal 。
一开始 terminal 就是指 tty 。
后来出现了使用显示器输出的 terminal 。使用显示器输出的 terminal 被称为 video terminal 简称 vt 。

旧时代的大型电脑为了能让多个用户可以同时使用，会提供多个物理终端。

软件意义上的终端出现，是为了让个人电脑的用户可以直接使用他的个人电脑来与大型计算机联系，而不必使用专门的物理终端。
现在的终端会被称为 emulator treminal 或 virtual terminal 。
因为现在已经没有物理意义上的终端了，都是由软件实现。
现在的 treminal ， tty ， console 都是指一种可以用来显示 shell 的软件， shell 可以是本地的也可以是远程的。

shell 是软件的概念。
shell 负责接收外部输入，调用各种程序或系统命令，然后输出结果。简单但不严谨的解释，负责人机交互的可以称为 shell ，负责显示 shell 的可以称为 terminal 。
shell 是通常是指命令行解释器，但图形界面一样可以有 GUI shll ，例如 Windows 的 explorer.exe 。
shell 通常会被翻译成 外壳 或 壳层。
shell 的概念其实是相对于操作系统内核 (kernel) 而言的。

shell 还可以分为
interactive 和 non-interactive
直接输入的命令运行在 interactive shell 上，
shell 脚本代码就运行在 non-interactive shell 中。

词汇表
- terminal n. 终端
- emulator n. 模拟器
- console n. 控制台
- virtual adj. 虚拟的
- shell n. 外壳
- teletypewriter n. 电传打字机
- teletype n. 电传打字机
- interactive adj. 交互的
- non-interactive adj. 非交互的
- tty  缩写 teletypewriter 或 teletype
- vty 缩写 virtual teletype
- vt 缩写 virtual terminal
- vt 缩写 video terminal
- pty 缩写 pseudo tty 伪电传打字机，通常翻译成伪终端 (pseudo terminal)
- ptms 缩写 pty master
- pts 缩写 pty slave
- vnc 缩写 Virtual Network Console 虚拟网络控制台

参考

https://www.zhihu.com/question/65280843

https://www.cnblogs.com/sparkdev/p/11605804.html

https://www.cnblogs.com/sparkdev/p/11460821.html

http://docs.linuxtone.org/ebooks/C&CPP/c/ch34s01.html

https://blog.csdn.net/dog250/article/details/78818612

https://taoshu.in/tty.html

## 各种 unix like shell

|全称|简称|备注|
|-|-|-|
|thompson shell|sh|第一个 unix like shell 。1971年至1975年随 Unix 第一版至第六版发布|
|borune shell|sh|1978年随Version 7 Unix首次发布|
|borune again shell|bash|在1987年由布莱恩·福克斯（Brian Fox）为了GNU计划而编写，是当前最常用的 shell|
|almquist shell|ash|派生于 borune shell ，最初作为 bsd 的 shell ，目前已不再被广泛使用|
|debian almquist shell|dash|派生于 almquist shell ，是 debian 的 shell|
|c shell|csh|语法类似于C语言， c shell 目前已不再被广泛使用|
|tenex c shell|tcsh| csh 的增强版， FreeBSD 中的默认 shell|
|korn shell|ksh|AIX 中的默认 shell ，兼容 borune shell ，同时加入了一些 c shell 的特性|
|zsh|zsh|zsh 对 borune shell 做出了大量改进，同时加入了 bash ， ksh 及 tcsh 的某些功能。 zsh 现在是 mac 的默认 shell|
|friendly interactive shell|fish|fish 的语法既不派生于 borune shell 也不派生于 c shell ，故被分类为一种“外来” shell 。|

各种 shell 的发展脉络
```
+------------------------------------------------------------------------------------------------------------------+
|                                                                                                                  |
|                                                                                                                  |
|                                                                                                                  |
|                          Thompson shell                                                                          |
|                 +----------+     +--------------------------+                                                    |
|                 |                                           |                                                    |
|                 |                                           |                                                    |
|                 v                                           v                                                    |
|                c shell                                  Bourne shell                                             |
|                  +                                           +                                                   |
|                  |                                           |                                                   |
|            +-----+-----------------+                         | +------------------>                              |
|            |                       |                         |                    |                              |
|            v                       v                         v                    v                              |
|     tenex c shell             korn shell           Bourne-Again shell       almquist shell                       |
|         +                          +                        +                     +                              |
|         |                          |                        |                     |                              |
|         +--------------------------v--------+---------------+                     |                              |
|                                             |                                     v                              |
|                                             |                              debian almquist shell                 |
|                                             v                                                                    |
|                                            zsh                                                       fish        |
|                                                                                                                  |
+------------------------------------------------------------------------------------------------------------------+
```

sh 通常是指遵循 POSIX 标准的 shell 。
bash 有 3 种方式使其遵循 POSIX 标准 https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
- 启动时增加 --posix 参数，像这样 bash --posix
- 启动后，使用 set -o posix 指令
- 以 sh 的程序名来启动，只要程序的名字叫 sh ，就会遵循 POSIX 标准，与路径无关

通常情况下 shell 脚本以这句开头 #!/bin/sh ，就是表示这份脚本遵循 POSIX 标准。
如果想脚本足够的通用，最好不要用 bash 的语法。

现在绝大部分 unix like 系统中， /bin/sh 和 /usr/bin/sh 一般都是链接文件，指向真正的默认 shell 。
现在绝大部分 shell 都兼容 POSIX 标准，但同时又会有一些自己的拓展。

新版本的 powershell 也能运行在 linux 上。

## linux 实现后台不间断运行
- supervisor
    - supervisor 是守护进程
    - supervisor 会根据配置运行对应的 start/stop/restart/reload 命令
    - supervisor 是子进程的父进程，子进程退出时，父进程能收到相关的信号 SIGCHLD ， supervisor 收到信号后就能执行相应的操作，例如重启进程
    - supervisor 不能监控守护进程是因为守护进程的父进程 id 不是 supervisor 的进程id，所以当守护进程退出时 supervisor 无法收到 SIGCHLD 信号
- screen/tmux 这类终端复用的软件
    - tmux 分成两部分 server 和 client ，其中 server 是守护进程
    - 通过 ssh 连接到服务器后 ssh server 会 fork 一个 shell ，远程终端就是显示这个 shell 的输入和输出
    - ssh 的 shell 能通过 tmux 的 clinet 让 tmux 的 server 再新建一个 shell
    - 这个新建的 shell 的父进程是 tmux 的 server ，所以当前终端关闭不会关闭这个 shell ，从而达到了类似于后台运行的效果
    - 大致的示意图
        ```
        remote terminal <----> ssh server <----> shell <----> tmux client <----> tmux server <----> shell
        ```
- 把代码改写成支持以 守护进程 的形式运行
- nohup 配合 &
    - & 的作用是把程序放到后台运行，但不会改变 stdin stdout stderr
    - nohup 的作用，nohup 英文全称 no hang up（不挂起）
        - 将 stdin 重定向到 /dev/null
        - 将 stdout 和 stderr 重定向到 nohup.out 或者用户通过参数指定的文件
        - 屏蔽掉 SIGHUP 信号，因为 SIGHUP 被屏蔽了，所以会话关闭后程序能继续运行
        - 调用 exec 启动指定的命令
    - 例子 `nohup php queue.php >> out.log 2>&1 &`
- systemctl
- cron *****
    - 例子 `* * * * * php queue.php >> out.log 2>&1`

## gcc 编译流程

编译的四个步骤
1. 预处理 由 .c 文件到 .i 文件。
    - 对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等
1. 编译 由 .i 文件到 .s 文件。
    - 将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件
1. 汇编 由 .s 文件到 .o 文件。
    - 将汇编代码翻译成了机器码，但是还不可以运行
1. 链接 由 .o 文件到可执行文件。
    - 处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址

编译的四个步骤对应的 gcc 命令
```
gcc -E test.c -o test.i
gcc -S test.i -o test.s
gcc -c test.s -o test.o
gcc test.o -o test
```

实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预处理器cpp、预编译程序cc1、汇编器as、链接器ld
```
cpp test.c -o test.i
cc1 test.i -o test.s
as test.s -o test.o
ld test.o -o test
```

- 头文件应该是在预处理阶段加上去的
- 各种库应该是在链接阶段加上去的

## GNU 的命令

- GNU 工具链
    - glib
    - gcc
    - gdb
    - make
    - bison
    - binutils 二进制实用程序
        - as  汇编
        - ld 连接
        - nm 显示目标文件内的符号
        - ar 静态库归档
        - objdump 反汇编
        - readelf elf 结构分析工具
    - autotools
        - autoscan
        - aclocal
        - autoconf
        - autoheader
        - automake
- coreutils
    - 文件处理
        - chgrp chown chmod cp ls mkdir rm touch
    - 文本处理
        - cat head tail wc
    - shell 工具
        - echo printf nohup pwd sleep
- findutils
    - find
- bash
- gzip
- gnu grep
- gnu awk
- gnu sed
- ...

其它
- flex（快速词法分析产生器，英语：fast lexical analyzer generator）是一种词法分析程序。
它是lex的开放源代码版本，以BSD许可证发布。
通常与 GNU bison 一同运作，但是它本身不是 GNU 计划的一部分。
- pkg-config 是一个在源代码编译时查询已安装的库的使用接口的计算机工具软件。 pkg-config 托管在 freedesktop.org 。 php 编译需要这个
    - 使用的效果大概像这样
    ```
    # 没使用 pkg-config
    gcc test.c -o test -I/usr/local/Cellar/opencv3/3.1.0_4/include/opencv -I/usr/local/Cellar/opencv3/3.1.0_4/include
    # 使用了 pkg-config
    gcc test.c -o test $(pkg-config opencv --cflags)
    ```
- BusyBox 是 GNU Core Utilities 的另一个开源替代，通常用在嵌入式系统里

参考
- https://zh.wikipedia.org/wiki/GNU%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8
- https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84

感觉 GNU 真的除了内核之外，什么都有了。

## 让网站支持 ipv6
1. 拥有一个 ipv6 地址
1. 域名解释 aaaa 记录指向 ipv6 的地址
1. 让网站程序支持 ipv6 地址
    - 通过网关翻译
        - 代码里用 ipv4 地址，域名解释 aaaa 记录到 网关，网关把 ipv6 的流量翻译成 ipv4 的流量再传递给网站
        - 代码里用 ipv6 地址，域名解释 a 记录到 网关，网关把 ipv4 的流量翻译成 ipv6 的流量再传递给网站
    - 让 web 服务器同时监听两个地址，代码里和 ip 相关的部分，都改成能兼容 ipv4 和 ipv6

用来测试网站对 ipv6 的支持，也可以用来查看 DNSSEC 的支持
https://ipv6.ustc.edu.cn/onlinechecklog.php

## 在命令行里格式化 json

1. python 的 json.tool ，好像 python2 和 3 都可以这样用
    ```
    echo '{ "name": "xiaohong", "age": 18 }' | python -m json.tool
    ```
    - 会转义中文，如果想不转义中文
    - 需要修改标准库里的文件，这样不是很好，在 python 的标准库 json 文件夹下有个 tool.py 文件，更改其中调用的 json.dump 函数，传一个ensure_ascii = False 参数即可

1. json_pp ， windwos 的 git bash 和 大多数 linux 发行版都有这个工具
    ```
    echo '{ "name": "xiaohong", "age": 18 }' | json_pp
    ```

1. jq ， 虽然大多数 linux 发行版都没有这个工具，但中文互联网环境下有好多文章都推荐这个
    - 下载 https://stedolan.github.io/jq/download/
    - 文档 https://stedolan.github.io/jq/manual/

1. PowerShell 的 ConvertFrom-Json 和 ConvertTo-Json ，这两个要组合来使用
    ```
    echo '{"type":"image","offset":0,"count":20}' | ConvertFrom-Json | ConvertTo-Json
    ```

配合 curl 使用
```
curl -s -k https://localhost/dev.json | json_pp
curl -s -k https://localhost/dev.json | python -m json.tool
```
- -s 只输出 body
- -k 忽略 https


配合 PowerShell 的 Invoke-WebRequest 使用
```
Invoke-WebRequest https://localhost/dev.json -UseBasicParsing -SkipCertificateCheck | Select -ExpandProperty Content | ConvertFrom-Json | ConvertTo-Json
Invoke-WebRequest https://localhost/dev.json -UseBasicParsing -SkipCertificateCheck | Select -ExpandProperty Content | python -m json.tool
```
- -UseBasicParsing 把结果输出到命令行
- -SkipCertificateCheck 忽略 https ，这个参数要在 PowerShell6 之后才有效
- Select -ExpandProperty Content 选取 body 的输出

如果 Invoke-WebRequest 出现了这种错误。
```
因为 Internet Explorer 引擎不可用，或者 Internet Explorer 的首次启动配置不完整
```
可以尝试以下步骤来解决
1. 打开 IE 的 internet 选项
2. 点击安全选项卡，选中本地 intranet ，并点击站点按钮
3. 新的窗口中点击高级
4. 添加 about:security_powershell.exe 到输入框，点击添加
5. 把所有 IE 窗口一个个关闭就好了，再次在 powershell 下运行 Invoke-WebRequest

## Windows 里的 Java 环境配置

1. 下载并安装 JDK
    - 这些是免费的 JDK
        - https://openjdk.java.net/
        - https://www.microsoft.com/openjdk
        - https://adoptopenjdk.net/
        - https://www.azul.com/downloads/?package=jdk
        - https://developers.redhat.com/products/openjdk/download
    - 这是 oracle 的 JDK
        -  https://www.oracle.com/java/
    - 如果是 JDK 1.8 以上的版本，笔者比较倾向于用 microsoft 的 openjdk
    - 通常只有 oracleJDK 需要安装，其他的 JDK 都是压缩包，直接解压就好了
1. 把 JDK 加入环境变量
    1. 新建一个新的环境变量 JAVA_HOME ，值是 JDK 的根目录
    1. 在 PATH 里加入 %JAVA_HOME%\bin 和 %JAVA_HOME%\lib 和 %JAVA_HOME%\jre\bin （如果没有这个目录就忽略）
    1. 如果是 JDK 1.5 及之前的版本还需要一个 CLASSPATH 的环境变量
        - CLASSPATH 的值是 .;%Java_Home%\bin;%JAVA_HOME%\lib;%Java_Home%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
1. 下载并安装 maven
    - https://maven.apache.org/
1. 把 maven 加入环境变量
    1. 新建一个新的环境变量 MAVEN_HOME ，值是 maven 的根目录
    1. 在 PATH 里加入 %MAVEN_HOME%\bin

windows10 之的系统在修改 path 时要注意分号 ;

在 JDK1.5 以后，classpath 并不是必须配置了，在 JDK1.5 之前，是没有办法在当前目录下加载类的（找不到 JDK 目录下 lib 文件夹中的 .jar 文件），所以我们需要通过配置 classpath ，但 JDK1.5 之后， JRE 能自动搜索目录下类文件，并且加载 dt.jar 和 tool.jar 的类。
dt.jar 是关于运行环境的类库，主要是用于 swing 的包，如果不使用可以不配置。
tools.jar 是工具类库。

编译和运行时可以通过参数 -classpath 指定 classpath 的路径，例如这样
```
javac -encoding UTF-8 -classpath .;./junit4.jar;./org.hamcrest.core_1.3.0.jar AaaTest.java JunitRunner.java
java -Dfile.encoding=UTF-8 -classpath .;./junit4.jar;./org.hamcrest.core_1.3.0.jar JunitRunner
```

## 无法执行 powershell 脚本

通常是执行策略的原因导致的。

设置脚本执行策略，通常把 策略 设为 RemoteSigned 就可以了
```
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine
```

查看 powershell 脚本执行策略
```
Get-ExecutionPolicy
Get-ExecutionPolicy -List
```

https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2

## python 的 http 服务和 cgi

python 一行命令启动 http 服务
```sh
# 最简单的 http 服务
python -m http.server
# 有 cgi 的 http 服务
python -m http.server --cgi
# 有 cgi 的和指定端口号的 http 服务
python -m http.server --cgi 8081
# 有 cgi 的，指定端口号的和指定ip地址的 http 服务
python -m http.server --cgi 8081 --bind 127.0.0.1
# 有 cgi 的，指定端口号的，指定ip地址的和指定站点根目录的 http 服务
python -m http.server --cgi 8081 --bind 127.0.0.1 --directory _book
```

所有 cgi脚本或程序 都必须有执行权限；在 linux 环境下是 755 ，整个路径都必须是可读可执行的。
默认情况下 cgi脚本或程序 要在这个目录下 /cgi-bin 。
windows 环境下 py 脚本开头那句 #! 是没有效果的，其实在 windows 环境下没有开头那句也没问题的。
windows 环境下只要不是 py 后缀的都会被当成 可执行文件， linux 可以执行其他脚本。
端口号要在 --cgi 参数后面。
无法设置 响应行 和 响应码，都是 200 。 (~~起码 3.10 还是这样~~)

请求 cgi 脚本的例子
```
curl 127.0.0.1:8000/cgi-bin/test.py
```

cgi 脚本的例子
```python
#!/usr/bin/python3

print ("Content-type:text/html")
print ()                             # 空行，告诉服务器结束头部
print ('<html>')
print ('<head>')
print ('<meta charset="utf-8">')
print ('<title>Hello Word</title>')
print ('</head>')
print ('<body>')
print ('<h2>Hello Word!</h2>')
print ('</body>')
print ('</html>')

```

```python
#!/usr/bin/python3

print ("Content-type: application/json")
print ()                             # 空行，告诉服务器结束头部
print ('{"result": "this is a test"}')

```

这个例子大致相当于这个命令 `python -m http.server 8888`
```python
from http.server import HTTPServer, SimpleHTTPRequestHandler

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, SimpleHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

这个例子大致相当于这个命令 `python -m http.server --cgi 8888`
```python
from http.server import HTTPServer, CGIHTTPRequestHandler

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, CGIHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

不使用命令行的 http 服务例子，这是单线程的
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import json

class myHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({'result': 'this is a test'}).encode())

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, myHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

不使用命令行的 http 服务例子，这是多线程的
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import json

class ThreadingHttpServer(ThreadingMixIn, HTTPServer):
    pass

class myHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({'result': 'this is a test'}).encode())

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = ThreadingHttpServer(host, myHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

不使用命令行的 http 服务例子，这是多线程的，再加上 cgi 的支持
```python
from http.server import HTTPServer, CGIHTTPRequestHandler
from socketserver import ThreadingMixIn

class ThreadingHttpServer(ThreadingMixIn, HTTPServer):
    pass

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = ThreadingHttpServer(host, CGIHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
```

HTTPServer 和 BaseHTTPRequestHandler 是两个关键的类，一个御用接收 http 请求，一个用于处理请求，其它类基本是派生自这两个类
```
BaseHTTPRequestHandler -> SimpleHTTPRequestHandler -> CGIHTTPRequestHandler
HTTPServer -> ThreadingHttpServer
```

参考文档
- https://www.runoob.com/python3/python3-cgi-programming.html
- https://docs.python.org/zh-cn/3/library/cgi.html
- https://docs.python.org/zh-cn/3/library/http.server.html


## debian 一句命令安装 docker

因为要经常部署和重装系统，所以就整理了这样一句命令，可能会因为 docker 的更新而失效

具体环境
- debian 11
- Docker version 20.10.12, build e91ed57
- docker-compose version 1.29.2, build 5becea4c

这是文档
https://docs.docker.com/engine/install/debian/

```bash
sudo apt-get remove -y docker docker-engine docker.io containerd runc && \
sudo apt-get update && \
sudo apt-get install -y \
    ca-certificates \
    curl \
    gnupg \
    lsb-release && \
if [ -e /usr/share/keyrings/docker-archive-keyring.gpg ] ; \
  then rm /usr/share/keyrings/docker-archive-keyring.gpg; \
  else curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ;fi && \
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null && \
sudo apt-get update && \
sudo apt-get install -y docker-ce docker-ce-cli containerd.io && \
sudo docker run hello-world && \
sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose && \
sudo chmod +x /usr/local/bin/docker-compose && \
docker-compose --version
```
