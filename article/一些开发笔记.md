一些开发笔记
================================

## 在 VSCode 里调试 JAVA
1. 安装 JDK
2. 把 JDK 添加进环境变量
3. 安装 VSCode 的 JAVA extension pack 拓展
4. 使用 VSCode 打开文件夹
5. 新增一个 debug 的类型 JAVA ，点击右下角的添加配置，选择 JAVA Lanuch Program
6. 写一份测试的代码，并在 mian 函数加个断点
10. 然后在终端里运行编译命令和运行命令，如果编译命令不复杂，可以配合 code runner 拓展，直接点击右上角的运行图标，或设置一个任务

## 在 VSCode 里调试 Python
1. 安装 Python
2. 把 Python 的安装目录和安装目录下的 script 添加进环境变量里
3. 在 VSCode 安装 Python 拓展（ microsoft 出品的）
4. 新增一个 debug 的类型 Python ，点击右下角的添加配置，选择 Python: Terminal (integrated)
5. 写一份测试的代码，并加个断点
6. 然后在终端里运行，可以配合 code runner 插件，直接点击右上角的运行图标，或设置一个任务

## 在 Windows10 里修改 administrator 帐号的帐号名的三种方式
1. 通过管理里的系统工具修改
```
选中桌面中的计算机图标，右键，点击管理
系统工具
    本地用户和组
        用户
            选中Administrator，然后重命名
重启电脑
```

2. 通过策略租修改
```
win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
    windows设置
        安全设置
            本地策略
                安全选项
                    拉到最下面
                    双击这个选选项 重命名系统管理员帐户
重启电脑
```

3. 通过 netplwiz (Network Places Wizard) 网上邻居向导 修改
```
win+r 打开运行
输入 netplwiz
选中Administrator，然后双击，然后修改
重启电脑
```

## Windows10 无密码远程连接
1. 允许任何远程着桌面的连接
2. 修改 Windows 的安全策略，允许远程桌面连接使用空密码
```
win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
    windows 设置
        安全设置
            本地策略
                安全选项
                    拉到最下面
                    禁用 使用空密码的本地账户只允许控制台登录
```


- 电脑提示“账户名与安全标识间无任何映射完成”
一般是修改玩用户名后没有重启导致的。

- 因为公司的电脑不能设密码，同时我又想远程桌面公司的电脑，考虑到安全问题，不能用默认用户名裸奔，所以修改用户名和设置无密码的远程桌面


## ss 的使用
1. 购买一个在 wall 以外的服务器
2. 下载 python
3. 安装 python
4. 把 python 添加到环境变量
5. 重置环境变量
6. 下载 ss
````shell
pip install shadowsocks
````
7. 在服务器的策略组放行相应的端口
8. 在防火墙放行相应的端口
9. 运行以下命令
```shell
ssserver -p 61813 -k windows@163.qq -m aes-256-cfb
    -p 是端口号
    -k 是密码
    -m 是加密方式
上面那条命令需要在 服务器的策略组 和 防火墙 放行 61813 端口
```
10. 下载客户端
11. 正确填写 ip 端口 密码
12. 参考
````plaintext
https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E
````

## VS 和 VC 库 的对应关系

|||
|-|-|
|Visual Studio 6.0|VC6|
|Visual Studio .NET 2002|VC7.0|
|Visual Studio .NET 2003|VC7.1|
|Visual Studio 2005|VC8|
|Visual Studio 2008|VC9|
|Visual Studio 2010|VC10|
|Visual Studio 2012|VC11|
|Visual Studio 2013|VC12|
|Visual Studio 2015|VC14|
|Visual Studio 2017|VC15|
|Visual Studio 2019|VS16|
|Visual Studio 2022|VS17|

- Visual C++ 6.0 是 Visual Studio 6.0 的一部分，但可以独立安装
- 从 VC10 开始才有 64位

## php 版本和 VC 库的对应关系

|||
|-|-|
|5.2|vc6|
|5.3|vc9|
|5.4|vc9|
|5.5|vc11|
|5.6|vc11|
|7.0|vc14|
|7.1|vc14|
|7.2|vc15|
|7.3|vc15|
|7.4|vc15|
|8.0|vs16|

- 其实下载下来的压缩包名有写着对应的 vc 库，系统位数， ts 和 nts

## Windows 里的脚本语言

- bat
- VBScript
- JScript
- PowerShell

## 如何不使用浏览器在 windows 里下载文件

使用 Windows 自带的程序

- ftp
- tftp
- sftp
- telnet
- webdav
- smb (就是网上邻居共享那种)
- nfs
- 用远程桌面
- 用 windows 商店
- 用 winget
- 用 系统自带的邮件 接收邮件的附件
- certutil
- bitsadmin
- 直接在 cmd 里 `start 下载地址`
    - 这其实会调用 ie 的，但实际上即使系统里没有浏览器大概率也能用， ie 作为系统组件很难删干净的
    - 其实直接在文件管理的地址栏输入 下载地址 也是可以的，也是调用 ie
- powershell
    - `(new-object System.Net.WebClient).DownloadFile('https://www.php.net/distributions/php-7.4.9.tar.gz', 'E:/php-7.4.9.tar.gz')`
    - `Invoke-WebRequest -Uri 'https://www.php.net/distributions/php-7.4.10.tar.gz' -OutFile 'E:/php-7.4.10.tar.gz'`
- .net
    - 一些版本的 Windows 会自带 .net ，这样也可以调用 .net 的库来下载文件
- VBScript JScript mshta 等调用 Microsoft.XMLHTTP
- 通过 光驱 u盘 移动硬盘 等。。。
- 用心探索以下 windows 里很多自带的服务都能下载文件
    - wmic Rundll32 Regsvr32 Cmstp msiexec MSBulid odbcconf
    - 传说一些版本的 Windows Defender 也可以下载文件

## Windows 安全地删除U盘

U盘 弹出失败的原因是进程占用了 U盘 ，只要占用 U盘 的进程都不在占用 U盘 或 都结束了， U盘 就可以安全地弹出了。

所以，让 U盘 安全地弹出的关键是找到占用 U盘 的进程。

当占用 U盘 的进程结束后，有时立即弹出 U盘 还是会失败的，这时再等待五六秒，再试一次弹出 U盘 就可以了。

可以安全退出 U盘 时也不要马上拔 U盘 ，最好等个五六秒再拔 U盘 。

这是各种方法的总结
1. 最简单的，在系统托盘右键，弹出，或在此电脑的界面，选中 U盘，右键，弹出
1. 关掉所有文件夹再试一次弹出 U盘
1. explorer.exe 重启，再试一次弹出 U盘
1. 注销当前的登录，再次登录，再试一次弹出 U盘
1. 通过任务管理器找到占用 U盘 的进程
    1. 打开任务管理器
    1. 切换到性能页面
    1. 打开资源监视器
    1. 切换到 cpu 页面
    1. 在 关联的句柄 栏目的搜索框内输入你的 U盘 盘符（如G:\）
    1. 即可看到当前占用 U盘 的进程
1. 关闭 U盘 的写入缓存
    1. 控制面板
    1. 管理工具
    1. 计算机管理
    1. 设备管理
    1. 磁盘驱动
    1. 选择当前的 U盘
    1. 右键 属性 策略
    1. 关闭写缓存
    1. 关闭写缓存可能会造成 U盘 数据的丢失，关闭了写缓存后，要确保 U盘 里的文件已经保存好再弹出 U盘
1. 在磁盘管理里使 U盘 脱机
    1. 控制面板
    1. 管理工具
    1. 磁盘管理
    1. 选择当前的 U盘
    1. 右键 脱机
    1. U盘 脱机后下次插入要重新挂载，脱机之后可以马上联机，再安全弹出，这样 U盘 下次插入时就不用联机了
    1. 脱机会直接关掉所有的文件句柄，要确保 U盘 里的文件已经保存好再脱机
    1. 脱机选项不可选，可能是有虚拟内存分配到 U盘 ，这时取消在 U盘 上的虚拟内存即可
        - 进入电脑属性->高级系统设置->高级->性能设置->高级->更改，关闭自动管理分页文件大小，取消在该磁盘上设置的虚拟内存
    1. 有时脱机还会失败，这时就继续参考下面的步骤
1. 通过 日志 查找占用 U盘 的进程
    1. 打开事件查看器
    1. windows日志
    1. 系统
    1. 找到最近的一条 来源 Kernel-PnP 的记录
    1. 记录的常规里有占用 U盘 的 进程id 的
    1. 再通过任务管理器的 pid 找到对应的进程
    1. 有时，即使找到占用 U盘 的进程，但却无法结束进程，或 进程是系统的核心进程
        - 这时可以尝试以这样的关键词（进程名 或 进程id + Kernel-PnP ）在网上搜索解决的方法
1. 如果是 Windows Defender 占用 U盘 可以试试这样操作
    1. 打开 Windows Defender 安全中心
    1. 病毒和威胁防护
    1. 病毒和威胁防护 设置
    1. 将在使用的 U盘 盘符添加为排除项
1. 最后的方法，关机，关机后就肯定可以安全地拔 U盘

笔者通常在直接弹出 U盘 失败后，会多试几次，然后通过 日志 找到对应的进程，然后通过 任务管理器 结束对应的进程，如果结束进程失败，还是会再次在网上搜索解决方法。
脱机 和 关闭写缓存都有一点副作用；
关闭文件夹，重启 explorer.exe ，注销，关机，这类都有点麻烦。

## windows 下的 linux 环境
- Git for Windows
- mingw
- mingw-w64
- TDM-GCC
- Cygwin
- MSYS
- MSYS2
- gnuwin
- windows10 子系统
    - wsl1
    - wsl2
- 虚拟机
    - VMware
    - VirtualBox
    - Hyper-V
    - qemu

## treminal tty console 和 shell

treminal ， tty ， console 是一开始都是硬件的概念。

一台电脑只有一个 console ，一般有电源开关等硬件操作的，
一台电脑可以有很多个 terminal 。
terminal 是负责 shell 的输入和输出。
console 也可以当作一个特殊的 terminal ，就是一个多了电源开关等硬件操作的 terminal 。
tty 是电传打印机。电传打印机是一种把键盘作为输入，纸带作为输出的硬件，是一种 terminal 。
一开始 terminal 就是指 tty 。
后来出现了使用显示器输出的 terminal 。使用显示器输出的 terminal 被称为 video terminal 简称 vt 。

旧时代的大型电脑为了能让多个用户可以同时使用，会提供多个物理终端。

软件意义上的终端出现，是为了让个人电脑的用户可以直接使用他的个人电脑来与大型计算机联系，而不必使用专门的物理终端。
现在的终端会被称为 emulator treminal 或 virtual terminal 。
因为现在已经没有物理意义上的终端了，都是由软件实现。
现在的 treminal ， tty ， console 都是指一种可以用来显示 shell 的软件， shell 可以是本地的也可以是远程的。

shell 是软件的概念。
shell 负责接收外部输入，调用各种程序或系统命令，然后输出结果。简单但不严谨的解释，负责人机交互的可以称为 shell ，负责显示 shell 的可以称为 terminal 。
shell 是通常是指命令行解释器，但图形界面一样可以有 GUI shll ，例如 Windows 的 explorer.exe 。
shell 通常会被翻译成 外壳 或 壳层。
shell 的概念其实是相对于内核 (kernel) 而言的。

shell 还可以分为
interactive 和 non-interactive
直接输入的命令运行在 interactive shell 上，
shell 脚本代码就运行在 non-interactive shell 中。

词汇表
- terminal n. 终端
- emulator n. 模拟器
- console n. 控制台
- virtual adj. 虚拟的
- shell n. 外壳
- teletypewriter n. 电传打字机
- teletype n. 电传打字机
- interactive adj. 交互的
- non-interactive adj. 非交互的
- tty  缩写 teletypewriter 或 teletype
- vty 缩写 virtual teletype
- vt 缩写 virtual terminal
- vt 缩写 video terminal
- pty 缩写 pseudo tty 伪电传打字机，通常翻译成伪终端 (pseudo terminal)
- ptms 缩写 pty master
- pts 缩写 pty slave

参考

https://www.zhihu.com/question/65280843

https://www.cnblogs.com/sparkdev/p/11605804.html

https://www.cnblogs.com/sparkdev/p/11460821.html

http://docs.linuxtone.org/ebooks/C&CPP/c/ch34s01.html

https://blog.csdn.net/dog250/article/details/78818612

https://taoshu.in/tty.html

## 各种 unix like shell

|全称|简称|备注|
|-|-|-|
|thompson shell|sh|第一个 unix like shell 。1971年至1975年随 Unix 第一版至第六版发布|
|borune shell|sh|1978年随Version 7 Unix首次发布|
|borune again shell|bash|在1987年由布莱恩·福克斯（Brian Fox）为了GNU计划而编写，是当前最常用的 shell|
|almquist shell|ash|派生于 borune shell ，最初作为 bsd 的 shell ，目前已不再被广泛使用|
|debian almquist shell|dash|派生于 almquist shell ，是 debian 的 shell|
|c shell|csh|语法类似于C语言， c shell 目前已不再被广泛使用|
|tenex c shell|tcsh| csh 的增强版， FreeBSD 中的默认 shell|
|korn shell|ksh|AIX 中的默认 shell ，兼容 borune shell ，同时加入了一些 c shell 的特性|
|zsh|zsh|zsh 对 borune shell 做出了大量改进，同时加入了 bash ， ksh 及 tcsh 的某些功能。 zsh 现在是 mac 的默认 shell|
|friendly interactive shell|fish|fish 的语法既不派生于 borune shell 也不派生于 c shell ，故被分类为一种“外来” shell 。|

各种 shell 的发展脉络
```
+------------------------------------------------------------------------------------------------------------------+
|                                                                                                                  |
|                                                                                                                  |
|                                                                                                                  |
|                          Thompson shell                                                                          |
|                 +----------+     +--------------------------+                                                    |
|                 |                                           |                                                    |
|                 |                                           |                                                    |
|                 v                                           v                                                    |
|                c shell                                  Bourne shell                                             |
|                  +                                           +                                                   |
|                  |                                           |                                                   |
|            +-----+-----------------+                         | +------------------>                              |
|            |                       |                         |                    |                              |
|            v                       v                         v                    v                              |
|     tenex c shell             korn shell           Bourne-Again shell       almquist shell                       |
|         +                          +                        +                     +                              |
|         |                          |                        |                     |                              |
|         +--------------------------v--------+---------------+                     |                              |
|                                             |                                     v                              |
|                                             |                              debian almquist shell                 |
|                                             v                                                                    |
|                                            zsh                                                       fish        |
|                                                                                                                  |
+------------------------------------------------------------------------------------------------------------------+
```

sh 通常是指遵循 POSIX 标准的 shell 。
bash 有 3 种方式使其遵循 POSIX 标准 https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
- 启动时增加 --posix 参数，像这样 bash --posix
- 启动后，使用 set -o posix 指令
- 以 sh 的程序名来启动，只要程序的名字叫 sh ，就会遵循 POSIX 标准，与路径无关

通常情况下 shell 脚本以这句开头 #!/bin/sh ，就是表示这份脚本遵循 POSIX 标准。
如果想脚本足够的通用，最好不要用 bash 的语法。

现在绝大部分 unix like 系统中， /bin/sh 和 /usr/bin/sh 一般都是链接文件，指向真正的默认 shell 。
现在绝大部分 shell 都兼容 POSIX 标准，但同时又会有一些自己的拓展。

新版本的 powershell 也能运行在 linux 上。

## linux 实现后台不间断运行
- supervisor
- Screen/Tmux 这类终端复用的软件
- 把代码改写成支持以 守护进程 的形式运行
- nohup 配合 &
- systemctl
- cron ******

## gcc 编译流程

编译的四个步骤
1. 预处理 由 .c 文件到 .i 文件。
    - 对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等
1. 编译 由 .i 文件到 .s 文件。
    - 将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件
1. 汇编 由 .s 文件到 .o 文件。
    - 将汇编代码翻译成了机器码，但是还不可以运行
1. 链接 由 .o 文件到可执行文件。
    - 处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址

编译的四个步骤对应的 gcc 命令
```
gcc -E test.c -o test.i
gcc -S test.i -o test.s
gcc -c test.s -o test.o
gcc test.o -o test
```

实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预处理器cpp、预编译程序cc1、汇编器as、链接器ld
```
cpp test.c -o test.i
cc1 test.i -o test.s
as test.s -o test.o
ld test.o -o test
```

- 头文件应该是在预处理阶段加上去的
- 各种库应该是在链接阶段加上去的

## GNU 工具链
- glib
- gcc
- gdb
- make
- bison
- binutils 二进制实用程序
    - as  汇编
    - ld 连接
    - ar 静态库归档
    - objdump 反汇编
    - readelf elf 结构分析工具
- autotools
    - autoscan
    - aclocal
    - autoconf
    - autoheader
    - automake
- coreutils
    - 文件处理
    - 文本处理
    - shell 工具
- bash
- gzip
- grep
- ...

其它
- flex（快速词法分析产生器，英语：fast lexical analyzer generator）是一种词法分析程序。
它是lex的开放源代码版本，以BSD许可证发布。
通常与 GNU bison 一同运作，但是它本身不是 GNU 计划的一部分。
- pkg-config 是一个在源代码编译时查询已安装的库的使用接口的计算机工具软件。 pkg-config 托管在 freedesktop.org 。 php 编译需要这个
    - 使用的效果大概像这样
    ```
    # 没使用 pkg-config
    gcc test.c -o test -I/usr/local/Cellar/opencv3/3.1.0_4/include/opencv -I/usr/local/Cellar/opencv3/3.1.0_4/include
    # 使用了 pkg-config
    gcc test.c -o test $(pkg-config opencv --cflags)
    ```
- BusyBox 是 GNU Core Utilities 的另一个开源替代，通常用在嵌入式系统里

参考
- https://zh.wikipedia.org/wiki/GNU%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8
- https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84

感觉 GNU 真的除了内核之外，什么都有了。

## 让网站支持 ipv6
1. 拥有一个 ipv6 地址
1. 域名解释 aaaa 记录指向 ipv6 的地址
1. 让网站程序支持 ipv6 地址
    - 通过网关翻译
        - 代码里用 ipv4 地址，域名解释 aaaa 记录到 网关，网关把 ipv6 的流量翻译成 ipv4 的流量再传递给网站
        - 代码里用 ipv6 地址，域名解释 a 记录到 网关，网关把 ipv4 的流量翻译成 ipv6 的流量再传递给网站
    - 让 web 服务器同时监听两个地址，代码里和 ip 相关的部分，都改成能兼容 ipv4 和 ipv6

用来测试网站对 ipv6 的支持，也可以用来查看 DNSSEC 的支持
https://ipv6.ustc.edu.cn/onlinechecklog.php
